<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>MK Track Generator • Iso 2D + 3D Preview + Pro Bezier + OBJ</title>
  <style>
    :root{--bg:#0b0f19;--ink:#e9ecf6;--muted:#aab4d4;--btn:#1b2440;--btn2:#151c32;--accent:#7aa2ff;--gold:#ffd36e;--red:#ff6e6e;--grn:#78ffa0;--blu:#78aaff;--split-l:1.05fr;--split-r:1.05fr;--dock-w:clamp(320px,30vw,430px);--bottom-ui-h:74px}
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    body{margin:0;background:var(--bg);color:var(--ink);padding-bottom:calc(var(--bottom-ui-h) + 20px)}
    .wrap{max-width:1500px;margin:0 auto;padding:14px;display:grid;gap:12px;grid-template-columns:1fr;align-items:start}
    @media(min-width:1200px){.wrap{grid-template-columns:minmax(0,var(--split-l)) 8px minmax(0,var(--split-r)) minmax(320px,0.8fr)}}
    .card{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:18px;overflow:hidden;min-height:520px}
    .hidden{display:none!important}
    .splitter{display:none}
    @media(min-width:1200px){
      .splitter{display:block;cursor:col-resize;position:sticky;top:12px;height:calc(100vh - 24px);border-radius:999px;background:rgba(122,162,255,0.22);border:1px solid rgba(255,255,255,0.2)}
      .splitter::after{content:'';position:absolute;left:50%;top:12px;bottom:12px;width:2px;transform:translateX(-50%);background:rgba(255,255,255,0.6);border-radius:2px}
      #editCard,#viewCard{position:sticky;top:14px;height:calc(100vh - 24px - var(--bottom-ui-h));min-height:560px}
      #editCard .canvasWrap,#viewCard .canvasWrap{height:auto;min-height:340px}
    }
    .canvasWrap{position:relative;height:74vh;min-height:620px}
    #editCard,#viewCard{display:flex;flex-direction:column}
    #editCard .canvasWrap,#viewCard .canvasWrap{flex:1 1 auto}
    canvas{position:absolute;inset:0;width:100%;height:100%}
    .tools{position:absolute;left:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:5}
    .actions{position:absolute;right:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;z-index:5}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.35);backdrop-filter:blur(8px);padding:8px 10px;border-radius:14px;font-size:12px;color:rgba(255,255,255,0.9);z-index:5;max-width:90%}
    body.hints-hidden .hint{display:none}
    .viewerHelp{margin:8px 12px 12px;background:rgba(0,0,0,0.35);backdrop-filter:blur(8px);padding:8px 10px;border-radius:14px;font-size:12px;color:rgba(255,255,255,0.9)}
    body.hints-hidden .viewerHelp{display:none}
    button{border:1px solid rgba(255,255,255,0.12);background:var(--btn2);color:var(--ink);padding:10px 12px;border-radius:14px;cursor:pointer;user-select:none}
    button.primary{background:var(--btn);border-color:rgba(122,162,255,0.55)}
    button.active{outline:2px solid rgba(122,162,255,0.7)}
    .chip{display:inline-flex;align-items:center;gap:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);padding:8px 10px;border-radius:999px;font-size:12px;color:rgba(255,255,255,0.9)}
    .panel{padding:16px;background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02))}
    h2{margin:0 0 8px 0;font-size:18px}
    .small{font-size:12px;color:var(--muted);line-height:1.45}
    label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px}
    input[type="text"], input[type="number"], select{width:100%;padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.25);color:var(--ink)}
    input[type="range"]{width:100%}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .toggle{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-top:10px}
    .toggle input{transform:scale(1.1)}
    textarea{width:100%;height:190px;border-radius:14px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.25);color:var(--ink);padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;white-space:pre}
    .hr{height:1px;background:rgba(255,255,255,0.08);margin:12px 0}
    #err{position:fixed;left:12px;right:12px;bottom:12px;display:none;padding:10px 12px;border-radius:14px;background:rgba(255,80,80,0.14);border:1px solid rgba(255,80,80,0.35);color:rgba(255,255,255,0.92);font-size:12px;white-space:pre-wrap;z-index:9999}
    .row{display:flex;gap:10px;align-items:center}
    .row > *{flex:1}
    #ctrlCard .panel > h2{letter-spacing:.02em}
    #ctrlCard .panel{max-height:74vh;overflow:auto}
    #ctrlCard .panel{scrollbar-width:thin;scrollbar-color:rgba(122,162,255,0.62) rgba(255,255,255,0.06)}
    #ctrlCard .panel::-webkit-scrollbar{width:10px}
    #ctrlCard .panel::-webkit-scrollbar-track{background:rgba(255,255,255,0.06);border-radius:999px}
    #ctrlCard .panel::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#2a3f72,#1a294f);border:1px solid rgba(166,195,255,0.35);border-radius:999px}
    #ctrlCard .panel::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,#35508f,#203668)}
    #ctrlCard button{background:linear-gradient(180deg,#1a2340,#121a31)}
    #ctrlCard button:hover{border-color:rgba(122,162,255,0.7)}
    #ctrlCard .ctrlDockHeader{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px;position:sticky;top:0;padding:8px 0 10px;background:linear-gradient(180deg,rgba(11,15,25,0.96),rgba(11,15,25,0.7));backdrop-filter:blur(8px);z-index:3}
    #ctrlCard .ctrlDockTitle{font-size:17px;font-weight:700;letter-spacing:.02em}
    #ctrlCard .ctrlDockActions{display:flex;gap:8px}
    #ctrlCard .ctrlDockActions button{padding:6px 9px;border-radius:10px;font-size:12px}
    #ctrlCard .ctrlIntro{font-size:12px;color:var(--muted);margin-bottom:10px}
    #ctrlCard .ctrlSections{display:flex;flex-direction:column;gap:10px;padding-bottom:16px}
    #ctrlCard details.uiSection{border:1px solid rgba(255,255,255,0.10);border-radius:14px;background:rgba(9,14,25,0.45);overflow:hidden}
    #ctrlCard details.uiSection > summary{list-style:none;cursor:pointer;user-select:none;padding:10px 12px;font-weight:600;font-size:13px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:space-between}
    #ctrlCard details.uiSection > summary::-webkit-details-marker{display:none}
    #ctrlCard details.uiSection > summary::after{content:'▾';font-size:12px;color:rgba(233,236,246,0.72)}
    #ctrlCard details.uiSection:not([open]) > summary::after{content:'▸'}
    #ctrlCard .uiSectionBody{padding:10px 12px 12px}
    #ctrlCard .uiSectionBody > .hr:first-child{display:none}
    #ctrlCard .uiSectionBody > h2{display:none}
    #ctrlCard .uiSectionBody label{margin-top:8px}
    #ctrlCard .uiSectionBody .toggle{margin-top:8px}
    #ctrlToggle{position:fixed;top:14px;right:14px;z-index:60;display:none;align-items:center;justify-content:center;width:34px;height:34px;border-radius:999px;padding:0;font-size:16px}
    #genQuickBtn{position:fixed;right:14px;bottom:90px;z-index:61;padding:11px 16px;border-radius:999px;background:linear-gradient(180deg,#2c4fa8,#1f3e87);border-color:rgba(164,194,255,0.68);box-shadow:0 10px 26px rgba(16,30,70,0.45);font-weight:700}
    #bottomActions{position:fixed;left:12px;right:12px;bottom:10px;z-index:60;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:8px;border-radius:14px;background:rgba(7,12,22,0.88);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.12);min-height:var(--bottom-ui-h)}
    #bottomActions button{padding:9px 12px;border-radius:12px}
    #toggleHintsBtn{min-width:42px;font-weight:800;font-size:18px;line-height:1}
    .helpModal{position:fixed;inset:0;z-index:120;display:flex;align-items:center;justify-content:center;background:rgba(3,6,14,0.72);backdrop-filter:blur(4px);padding:18px}
    .helpModal.hidden{display:none}
    .helpCard{width:min(940px,96vw);max-height:min(82vh,840px);overflow:auto;background:linear-gradient(180deg,rgba(19,27,48,0.97),rgba(10,16,31,0.97));border:1px solid rgba(148,176,244,0.30);border-radius:16px;padding:16px 16px 14px;box-shadow:0 18px 45px rgba(0,0,0,0.45)}
    .helpTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .helpTitle b{font-size:18px}
    .helpGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .helpBlock{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.09);border-radius:12px;padding:10px}
    .helpBlock b{display:block;margin-bottom:6px}
    .helpBlock p{margin:0;font-size:13px;color:rgba(234,238,249,0.92);line-height:1.45}
    .helpActions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px;flex-wrap:wrap}
    @media(max-width:880px){.helpGrid{grid-template-columns:1fr}}
    #editWrap .editToolbar{left:12px;right:12px;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    #editWrap .editToolbar .toolGroup{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    #editWrap .editToolbar .primaryTools{flex:1 1 520px}
    #editWrap .editToolbar .statusTools{flex:0 1 auto}
    #editWrap .editToolbar .actionTools{margin-left:auto}
    #editWrap .editToolbar button{padding:9px 12px;border-radius:13px;white-space:nowrap}
    @media(max-width:1040px){
      #editWrap .editToolbar .actionTools{margin-left:0}
    }
    @media(min-width:1200px){
      .wrap{max-width:none;grid-template-columns:minmax(0,var(--split-l)) 8px minmax(0,var(--split-r));padding-right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed .wrap{padding-right:14px}
      #ctrlToggle{display:flex;right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #ctrlToggle{right:12px}
      #genQuickBtn{right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #genQuickBtn{right:12px}
      #ctrlCard{position:fixed;right:12px;top:12px;width:var(--dock-w);height:calc(100vh - 24px - var(--bottom-ui-h));min-height:unset;z-index:50;transition:transform .22s ease, opacity .22s ease}
      #ctrlCard .panel{height:100%;max-height:none;overflow:auto;padding:12px 14px 18px}
      body.ctrl-collapsed #ctrlCard{transform:translateX(calc(100% + 20px));opacity:0;pointer-events:none}
      #bottomActions{right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #bottomActions{right:12px}
    }
  </style>
</head>
<body>
<div id="err"></div>
<button id="ctrlToggle" title="Toggle controls">◀</button>
<button id="genQuickBtn" class="primary" title="Generate Track">Generate Track</button>

<div class="wrap">
  <!-- 2D ISO EDITOR -->
  <div class="card" id="editCard">
    <div class="canvasWrap" id="editWrap">
      <canvas id="edit"></canvas>
      <div class="tools editToolbar">
        <div class="toolGroup primaryTools">
          <button id="toolDraw" class="active">Draw</button>
          <button id="toolMove">Move</button>
          <button id="toolErase">Erase</button>
          <button id="toolJoin">Join</button>
          <button id="toolYSplit">Y Split</button>
          <button id="toolRound">Roundabout</button>
          <button id="toolFencePlace">Fence Place</button>
          <button id="toolTreePlace">Tree Place</button>
        </div>
        <div class="toolGroup statusTools">
          <span class="chip">Selected: <b id="selLabel">none</b> <span id="selCount">(0)</span></span>
          <span class="chip" id="snapStatus">Snap: XZ 1.00 • Y 0.25</span>
        </div>
      </div>
    </div>
    <div class="viewerHelp" id="editHint">
      <b>2D</b>: Click add/select • Draw: click yellow/blue curve to insert point • Shift/Ctrl click = multi-select • Drag move (XZ) • <b>Space+drag</b> pan • Shift+drag pan • Wheel zoom • Alt+wheel height<br/>
      <b>Tools</b>: Join = click point A then B to add a joining path section • Y Split = click point/section, then click point to add fork section • Y Split same-point second click = fork point into 2 • Ctrl/Cmd+click/click trim • Alt+click/click join • Roundabout = click point, drag size, click exit • Fence/Tree place in 3D by clicking terrain<br/>
      <b>Bezier</b>: select yellow or blue point then drag handle squares • <b>Alt-drag handle</b> rotate-only (keep length) • <b>1/2/3</b> set Smooth/Aligned/Corner
    </div>
  </div>

  <div id="splitter" class="splitter" title="Drag to resize 2D/3D panels"></div>

  <!-- 3D PREVIEW (offline software renderer) -->
  <div class="card" id="viewCard">
    <div class="canvasWrap" id="viewWrap">
      <canvas id="view"></canvas>
      <div class="actions"><button id="viewModeBtn">Mode: Normal</button></div>
    </div>
    <div class="viewerHelp" id="viewHint">
      <b>3D</b>: WASD + Q/Z move • RMB look • LMB look • MMB pan • Alt+RMB orbit selected • RMB+wheel speed • MMB click reset speed (scene-based) • F focus • Drag yellow gizmo center = free move • Drag Bezier handle dots to shape in 3D<br/>
      Offline 3D preview (no CDN). Export OBJ for Blender/Rhino. With Road iso snap on, gizmo snaps X/Z to grid and Y to Road level step. In Fence/Tree place mode, click terrain to place (fence uses 2 clicks).
    </div>
  </div>

  <!-- CONTROLS -->
  <div class="card" id="ctrlCard">
    <div class="panel">
      <h2>Controls</h2>
      <div class="small">Ribbon road with per-point <b>height</b> + <b>bank</b>. Curve is Illustrator-like cubic Bezier in XZ with node types (Smooth / Aligned / Corner).</div>

      <label>Track name</label>
      <input id="trackName" type="text" value="mk_track_3d"/>

      <label>Workspace view</label>
      <select id="workspaceMode">
        <option value="both">Both (2D + 3D)</option>
        <option value="2d">2D only</option>
        <option value="3d">3D only</option>
      </select>

      <div class="two">
        <div>
          <label>Grid snap (XZ)</label>
          <input id="grid" type="number" step="0.5" min="0.5" max="8" value="1"/>
        </div>
        <div>
          <label>Iso zoom</label>
          <input id="isoScale" type="range" min="0.02" max="240" step="0.02" value="5.98"/>
          <div class="small"><span id="isoScaleVal">5.98</span></div>
        </div>
      </div>
      <div class="toggle"><label style="margin:0">Road iso snap</label><input id="roadIsoSnap" type="checkbox" checked/></div>
      <div class="small">Snaps main/branch/roundabout/generation edits to grid; Y uses Road level step.</div>
      <label>Road level step (Y)</label>
      <input id="roadSnapY" type="number" step="0.05" min="0.05" max="10" value="0.25"/>
      <div class="small"><span id="roadSnapYVal">0.25</span></div>

      <div class="toggle"><label style="margin:0">Show grid</label><input id="showGrid" type="checkbox" checked/></div>
      <div class="toggle"><label style="margin:0">Closed loop</label><input id="closed" type="checkbox" checked/></div>

      <label>Road width</label>
      <input id="roadWidth" type="range" min="1" max="14" step="0.25" value="4.0"/>
      <div class="small"><span id="roadWidthVal">4.00</span></div>

      <label>Thickness (Y)</label>
      <input id="roadThickness" type="range" min="0.05" max="3" step="0.05" value="0.05"/>
      <div class="small"><span id="roadThicknessVal">0.05</span></div>

      <div class="toggle"><label style="margin:0">Include side walls</label><input id="includeSides" type="checkbox" checked/></div>

      <label>Spline smoothness</label>
      <input id="subdiv" type="range" min="2" max="30" step="1" value="25"/>
      <div class="small"><span id="subdivVal">25</span></div>

      <label>Path detail (performance)</label>
      <input id="pathDetail" type="range" min="0.30" max="1.00" step="0.01" value="0.51"/>
      <div class="small"><span id="pathDetailVal">0.51x</span></div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Generator</h2>
      <div class="small">Mario Kart/F1 templates with rule-checked banking and bridge clearance.</div>

      <label>Generator style</label>
      <select id="genStyle">
        <option value="figure8">Figure-8 (Mario Kart style)</option>
        <option value="clover">Cloverleaf</option>
        <option value="serpentine">Serpentine</option>
        <option value="mountainSpiral">Mountain spiral</option>
        <option value="splitS">Split-S</option>
        <option value="f1long">F1 long circuit</option>
        <option value="random" selected>Random style mix</option>
      </select>

      <div class="toggle"><label style="margin:0">Y-split modifier</label><input id="genModY" type="checkbox" checked/></div>
      <div class="toggle"><label style="margin:0">Roundabout modifier</label><input id="genModRound" type="checkbox"/></div>
      <div class="toggle"><label style="margin:0">Crossroads modifier</label><input id="genModCross" type="checkbox" checked/></div>

      <label>Layout variation</label>
      <input id="genRandomness" type="range" min="0" max="1" step="0.01" value="0.87"/>
      <div class="small"><span id="genRandomnessVal">0.87</span></div>

      <label>Track size</label>
      <input id="genScale" type="range" min="0.6" max="3.8" step="0.01" value="3.73"/>
      <div class="small"><span id="genScaleVal">3.73x</span></div>

      <label>Lap length</label>
      <input id="genLength" type="range" min="0.7" max="3.5" step="0.01" value="2.40"/>
      <div class="small"><span id="genLengthVal">2.40x</span></div>

      <label>Curve count</label>
      <input id="genCurves" type="range" min="2" max="16" step="1" value="7"/>
      <div class="small"><span id="genCurvesVal">7</span></div>

      <label>Generator point cap</label>
      <input id="genPointCap" type="range" min="16" max="120" step="1" value="27"/>
      <div class="small"><span id="genPointCapVal">27</span></div>

      <label>Design combo count</label>
      <input id="genComboCount" type="range" min="1" max="3" step="1" value="2"/>
      <div class="small"><span id="genComboCountVal">2</span></div>

      <label>Straight bias</label>
      <input id="genStraights" type="range" min="0" max="1" step="0.01" value="0.78"/>
      <div class="small"><span id="genStraightsVal">0.78</span></div>

      <label>Flow smoothing</label>
      <input id="genFlow" type="range" min="0" max="1" step="0.01" value="0.86"/>
      <div class="small"><span id="genFlowVal">0.86</span></div>

      <label>Roundabout exits</label>
      <input id="genRoundExits" type="range" min="2" max="4" step="1" value="3"/>
      <div class="small"><span id="genRoundExitsVal">3</span></div>

      <label>Crossroads frequency</label>
      <input id="genCrossFreq" type="range" min="1" max="4" step="1" value="3"/>
      <div class="small"><span id="genCrossFreqVal">3</span></div>

      <button id="genBtn" style="margin-top:8px">Generate Track</button>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Terrain</h2>
      <div class="small">Optional rough cliff terrain around the track footprint.</div>
      <div class="toggle"><label style="margin:0">Generate terrain</label><input id="terrainOn" type="checkbox" checked/></div>
      <label>Terrain roughness</label>
      <input id="terrainRough" type="range" min="0" max="4" step="0.1" value="4.0"/>
      <div class="small"><span id="terrainRoughVal">4.0</span></div>
      <label>Cliff height</label>
      <input id="terrainCliff" type="range" min="1" max="12" step="0.2" value="10.0"/>
      <div class="small"><span id="terrainCliffVal">10.0</span></div>
      <label>Road → terrain clearance</label>
      <input id="terrainClearance" type="range" min="0.05" max="1.20" step="0.01" value="1.20"/>
      <div class="small"><span id="terrainClearanceVal">1.20</span></div>
      <label>Terrain follow road</label>
      <input id="terrainFollow" type="range" min="0" max="1" step="0.01" value="0.88"/>
      <div class="small"><span id="terrainFollowVal">0.88</span></div>
      <label>Terrain detail (anti low-poly)</label>
      <input id="terrainDetail" type="range" min="0" max="1" step="0.01" value="0.62"/>
      <div class="small"><span id="terrainDetailVal">0.62</span></div>
      <label>Terrain presets</label>
      <div class="row">
        <button id="terrainPresetClean" type="button">Kart clean</button>
        <button id="terrainPresetCliffs" type="button">Steep cliffs</button>
        <button id="terrainPresetBridge" type="button">Wide clear</button>
      </div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Theme (Yoshi mock)</h2>
      <div class="small">Adds grass shoulders + curbs, with manual fence/tree placement in 3D.</div>
      <div class="toggle"><label style="margin:0">Enable theme dressing</label><input id="themeOn" type="checkbox" checked/></div>

      <label>Grass shoulder width</label>
      <input id="themeGrass" type="range" min="0.5" max="6.5" step="0.1" value="0.6"/>
      <div class="small"><span id="themeGrassVal">0.6</span></div>

      <label>Curb height</label>
      <input id="themeCurb" type="range" min="0.02" max="0.30" step="0.01" value="0.10"/>
      <div class="small"><span id="themeCurbVal">0.10</span></div>

      <label>Fence height scale</label>
      <input id="themeFence" type="range" min="0" max="1" step="0.01" value="0.55"/>
      <div class="small"><span id="themeFenceVal">0.55</span></div>

      <label>Tree size scale</label>
      <input id="themeTrees" type="range" min="0" max="1" step="0.01" value="0.60"/>
      <div class="small"><span id="themeTreesVal">0.60</span></div>
      <button id="clearPropsBtn" style="margin-top:8px">Clear placed props</button>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Selected point</h2>
      <div class="small">Height/bank + node type. Node type controls how opposite handle behaves.</div>

      <label>Node type</label>
      <select id="selNode">
        <option value="smooth">Smooth (mirrored)</option>
        <option value="aligned">Aligned (angle mirrored)</option>
        <option value="corner">Corner (independent)</option>
      </select>

      <div class="two">
        <div>
          <label>Height (Y)</label>
          <input id="selY" type="range" min="-10" max="20" step="0.1" value="0"/>
          <div class="small"><span id="selYVal">0.0</span></div>
        </div>
        <div>
          <label id="selBankLabel">Bank (deg)</label>
          <input id="selBank" type="range" min="-45" max="45" step="0.5" value="0"/>
          <div class="small"><span id="selBankVal">0.0</span></div>
        </div>
      </div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Auto bank (optional)</h2>
      <div class="small">Derives banking from curvature (turning). Blends with manual bank per point.</div>
      <div class="toggle"><label style="margin:0">Enable auto bank</label><input id="autoBank" type="checkbox" checked/></div>

      <label>Auto bank strength</label>
      <input id="autoBankStrength" type="range" min="0" max="1" step="0.01" value="0.72"/>
      <div class="small"><span id="autoBankStrengthVal">0.72</span></div>

      <label>Max auto bank (deg)</label>
      <input id="autoBankMax" type="range" min="0" max="60" step="1" value="16"/>
      <div class="small"><span id="autoBankMaxVal">16</span></div>

      <label>Curvature → bank scale</label>
      <input id="autoBankScale" type="range" min="0" max="4" step="0.05" value="1.40"/>
      <div class="small"><span id="autoBankScaleVal">1.40</span></div>

      <div class="hr"></div>

      <div class="small">If download is blocked, copy OBJ text into <b>.obj</b>:</div>
      <button id="toggleObj" style="margin-top:8px">Show OBJ</button>
      <textarea id="objText" style="display:none" readonly></textarea>

      <div class="hr"></div>
      <div class="small">Dev: open console for self-tests on load.</div>
    </div>
  </div>
</div>

<div id="bottomActions">
  <button id="saveBtn" type="button">Save</button>
  <button id="loadBtn" type="button" title="Load file (Shift+Click restores local cache)">Load</button>
  <button id="toggleHintsBtn" type="button" title="Help and tool guide">?</button>
  <button id="resetBtn" type="button">Reset</button>
  <button id="clearBtn" type="button">Clear</button>
  <button id="exportBtn" type="button" class="primary">Export OBJ</button>
  <input id="loadProjectFile" type="file" accept=".json,.mktrack,.mktrack.json,application/json" style="display:none"/>
</div>

<div id="helpModal" class="helpModal hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="helpCard">
    <div class="helpTitle">
      <b id="helpTitle">Tool Guide</b>
      <button id="helpCloseBtn" type="button">Close</button>
    </div>
    <div class="helpGrid">
      <div class="helpBlock"><b>2D Edit</b><p>Draw: click to add point. Move: drag selected. Erase: click point or Ctrl/Cmd-click trim section. Shift/Ctrl click adds to multi-select. Space+drag or Shift+drag pans. Wheel zooms. Alt+wheel changes point height.</p></div>
      <div class="helpBlock"><b>Join / Y Split / Roundabout</b><p>Join: click point A then B to make linking branch. Y Split: click point/section then click target to create fork; clicking same point twice forks node into two ends. Roundabout: click start point, drag radius, then click exit direction.</p></div>
      <div class="helpBlock"><b>Bezier / Node Types</b><p>Select a yellow or blue point to edit handles. Drag square handles to shape curvature. Alt-drag rotates handle without length change. Node types: Smooth mirrors angle+length, Aligned mirrors angle only, Corner is independent. Keys 1/2/3 switch node type.</p></div>
      <div class="helpBlock"><b>3D View + Gizmo</b><p>WASD + Q/Z moves camera. RMB or LMB look, MMB pan. Alt+RMB orbits selected point. Mouse wheel with RMB adjusts speed, MMB click resets speed. F focuses selected. Drag yellow gizmo center/axes to move points; with Road iso snap ON, X/Z snap to Grid and Y snaps to Road level step.</p></div>
      <div class="helpBlock"><b>Generation + Terrain</b><p>Generate Track builds templates and modifiers. Closed loop now stitches final segment back to start in mesh. Terrain detail increases terrain mesh resolution and smoothing to reduce sharp faceting on cliff transitions and shoulders.</p></div>
      <div class="helpBlock"><b>Props + Export</b><p>Fence/Tree Place: click terrain in 3D (fence uses two clicks). Export OBJ writes road, sides, terrain, curbs, shoulders, and placed props as manifold meshes where supported.</p></div>
    </div>
    <div class="helpActions">
      <button id="helpInlineToggle" type="button">Hide Inline Helpers</button>
      <button id="helpCloseBtn2" type="button">Done</button>
    </div>
  </div>
</div>

<script>
(() => {
  const errEl = document.getElementById('err');
  const showErr = (msg) => {
    errEl.style.display = 'block';
    errEl.textContent = String(msg);
  };
  window.addEventListener('error', (e) => {
    const message = (e && (e.message || (e.error && e.error.message) || e.error)) || e;
    showErr('JS error:\n' + String(message));
  });

  // ---------- math helpers ----------
  const v3 = (x = 0, y = 0, z = 0) => ({ x, y, z });
  const vv = (a) => (a && Number.isFinite(a.x) && Number.isFinite(a.y) && Number.isFinite(a.z)) ? a : v3(0, 0, 0);
  const add = (a, b) => { a = vv(a); b = vv(b); return v3(a.x + b.x, a.y + b.y, a.z + b.z); };
  const sub = (a, b) => { a = vv(a); b = vv(b); return v3(a.x - b.x, a.y - b.y, a.z - b.z); };
  const mul = (a, s) => { a = vv(a); return v3(a.x * s, a.y * s, a.z * s); };
  const dot = (a, b) => { a = vv(a); b = vv(b); return a.x * b.x + a.y * b.y + a.z * b.z; };
  const cross = (a, b) => { a = vv(a); b = vv(b); return v3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x); };
  const len = (a) => { a = vv(a); return Math.hypot(a.x, a.y, a.z); };
  const norm = (a) => {
    a = vv(a);
    const l = len(a) || 1;
    return v3(a.x / l, a.y / l, a.z / l);
  };
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  function rotateAxis(v, axis, rad) {
    const k = norm(axis);
    const c = Math.cos(rad), s = Math.sin(rad);
    return add(add(mul(v, c), mul(cross(k, v), s)), mul(k, dot(k, v) * (1 - c)));
  }

  // ---------- iso projection (2D editor) ----------
  function isoProject(p, s) {
    const ix = (p.x - p.z) * s;
    const iy = (p.x + p.z) * s * 0.5;
    return { x: ix, y: iy - p.y * s };
  }

  // Inverse for a given fixed height (y). This fixes picking/editing when points have height.
  function worldFromScreenXZWithY(sx, sy, org, s, y) {
    const syAdj = sy + y * s;
    const xIso = (sx - org.x) / s;
    const yIso = (syAdj - org.y) / (s * 0.5);
    const x = (xIso + yIso) / 2;
    const z = (yIso - xIso) / 2;
    return { x, z };
  }

  // ---------- cubic bezier sampling ----------
  function bezier(p0, c0, c1, p1, t) {
    const u = 1 - t;
    const uu = u * u, tt = t * t;
    const uuu = uu * u, ttt = tt * t;
    return add(add(add(mul(p0, uuu), mul(c0, 3 * uu * t)), mul(c1, 3 * u * tt)), mul(p1, ttt));
  }

  function bezierDeriv(p0, c0, c1, p1, t) {
    const u = 1 - t;
    const a = mul(sub(c0, p0), 3 * u * u);
    const b = mul(sub(c1, c0), 6 * u * t);
    const c = mul(sub(p1, c1), 3 * t * t);
    return add(add(a, b), c);
  }

  function ensurePointShape(p) {
    if (!p.hin) p.hin = { x: 0, z: 0 };
    if (!p.hout) p.hout = { x: 0, z: 0 };
    if (!p.node) p.node = 'smooth'; // smooth | aligned | corner
    if (typeof p.bank !== 'number') p.bank = 0;
    if (typeof p.pos?.y !== 'number') p.pos.y = 0;
  }

  function ensureHandles(ctrl) {
    const baseLen = 1.2;
    for (const p of ctrl) ensurePointShape(p);
    for (let i = 0; i < ctrl.length; i++) {
      const p = ctrl[i];
      const prev = ctrl[Math.max(0, i - 1)];
      const next = ctrl[Math.min(ctrl.length - 1, i + 1)];
      if (Math.hypot(p.hout.x, p.hout.z) < 1e-6) {
        const d = norm(sub(next.pos, p.pos));
        p.hout = { x: d.x * baseLen, z: d.z * baseLen };
      }
      if (Math.hypot(p.hin.x, p.hin.z) < 1e-6) {
        const d = norm(sub(prev.pos, p.pos));
        p.hin = { x: d.x * baseLen, z: d.z * baseLen };
      }
    }
  }

  function signedTurnXZ(a, b, c) {
    // signed angle between (b-a) and (c-b) in XZ
    const v1 = norm(v3(b.x - a.x, 0, b.z - a.z));
    const v2 = norm(v3(c.x - b.x, 0, c.z - b.z));
    const cr = cross(v1, v2);
    const d = clamp(dot(v1, v2), -1, 1);
    const ang = Math.acos(d);
    const sign = cr.y >= 0 ? 1 : -1;
    return ang * sign; // radians
  }

  function computeAutoBank(samples, maxDeg, scale) {
    if (samples.length < 3) return samples.map(() => 0);
    const out = new Array(samples.length).fill(0);
    for (let i = 1; i < samples.length - 1; i++) {
      const a = samples[i - 1].pos;
      const b = samples[i].pos;
      const c = samples[i + 1].pos;
      const ang = signedTurnXZ(a, b, c); // rad
      // curvature proxy: signed angle per segment
      const bank = clamp((ang * (180 / Math.PI)) * scale, -maxDeg, maxDeg);
      out[i] = bank;
    }
    out[0] = out[1];
    out[out.length - 1] = out[out.length - 2];
    return out;
  }

  function sampleSpline(ctrl, subdiv, closed, autoBankCfg) {
    const n = ctrl.length;
    if (n < 2) return [];
    ensureHandles(ctrl);

    const out = [];
    const segs = closed ? n : n - 1;
    const get = (i) => ctrl[(i % n + n) % n];

    for (let i = 0; i < segs; i++) {
      const a = get(i);
      const b = get(i + 1);
      const p0 = a.pos;
      const p1 = b.pos;
      const c0 = add(p0, v3(a.hout.x, 0, a.hout.z));
      const c1 = add(p1, v3(b.hin.x, 0, b.hin.z));
      for (let s = 0; s < subdiv; s++) {
        const t = s / subdiv;
        out.push({ pos: bezier(p0, c0, c1, p1, t), bank: (1 - t) * a.bank + t * b.bank });
      }
    }
    const last = closed ? ctrl[0] : ctrl[n - 1];
    out.push({ pos: last.pos, bank: last.bank });

    // Auto bank derived from curvature (blend)
    if (autoBankCfg?.enabled) {
      const maxDeg = autoBankCfg.maxDeg;
      const scale = autoBankCfg.scale;
      const strength = autoBankCfg.strength;
      const banks = computeAutoBank(out, maxDeg, scale);
      for (let i = 0; i < out.length; i++) {
        out[i].bank = (1 - strength) * out[i].bank + strength * banks[i];
      }
    }

    return out;
  }

  function effectiveSubdiv() {
    return clamp(Math.round(num('subdiv') * num('pathDetail')), 2, 30);
  }

  function branchAnchors(sec) {
    const a = points[sec.a];
    const b = points[sec.b];
    if (!a || !b) return [];
    const mids = Array.isArray(sec.mids) ? sec.mids.slice().sort((m1, m2) => m1.u - m2.u) : [];
    const AB = sub(b.pos, a.pos);
    const flat = v3(AB.x, 0, AB.z);
    const L = Math.max(0.01, len(flat));
    const t = norm(flat);
    const n = norm(v3(-t.z, 0, t.x));
    const bendSide = (Number(sec.bend) || 1) >= 0 ? 1 : -1;
    const bendAmt = Math.min(L * 0.30, Math.max(num('roadWidth') * 0.95, L * 0.13));
    const bend = mul(n, bendAmt * bendSide * (sec.kind === 'fork' ? 1.15 : 0.8));
    const endScale = 0.30;
    return [
      {
        x: a.pos.x, y: a.pos.y, z: a.pos.z, u: 0, node: 'smooth', bevel: 0.65,
        hin: { x: -t.x * L * endScale - bend.x * 0.45, z: -t.z * L * endScale - bend.z * 0.45 },
        hout: { x: t.x * L * endScale + bend.x, z: t.z * L * endScale + bend.z },
      },
      ...mids.map((m) => ({
        x: m.x, y: m.y, z: m.z, u: clamp(Number(m.u || 0), 0.001, 0.999),
        bevel: clamp(Number(m.bevel ?? 0.55), 0, 1),
        node: (m.node === 'aligned' || m.node === 'corner') ? m.node : 'smooth',
        hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
        hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
      })),
      {
        x: b.pos.x, y: b.pos.y, z: b.pos.z, u: 1, node: 'smooth', bevel: 0.65,
        hin: { x: -t.x * L * endScale + bend.x, z: -t.z * L * endScale + bend.z },
        hout: { x: t.x * L * endScale - bend.x * 0.45, z: t.z * L * endScale - bend.z * 0.45 },
      },
    ];
  }

  function sampleBranchSection(sec, subdiv) {
    const a = points[sec.a];
    const b = points[sec.b];
    if (!a || !b) return [];
    const anchors = branchAnchors(sec);
    const lift = Math.max(0, Number(sec.lift) || 0);
    const steps = Math.max(8, Math.round(subdiv * (sec.kind === 'fork' ? 2.3 : 2.0)));
    const out = [];
    const spans = anchors.length - 1;
    for (let si = 0; si < spans; si++) {
      const p0 = anchors[si];
      const p1 = anchors[si + 1];
      const spanSteps = Math.max(4, Math.round(steps / spans));
      const s0 = 0.08 + clamp(Number(p0.bevel ?? 0.55), 0, 1) * 1.15;
      const s1 = 0.08 + clamp(Number(p1.bevel ?? 0.55), 0, 1) * 1.15;
      const c0 = v3(p0.x + p0.hout.x * s0, p0.y, p0.z + p0.hout.z * s0);
      const c1 = v3(p1.x + p1.hin.x * s1, p1.y, p1.z + p1.hin.z * s1);
      for (let k = 0; k <= spanSteps; k++) {
        if (si > 0 && k === 0) continue;
        const tLocal = k / spanSteps;
        const u = (si + tLocal) / spans;
        const p = bezier(v3(p0.x, p0.y, p0.z), c0, c1, v3(p1.x, p1.y, p1.z), tLocal);
        p.y += Math.sin(u * Math.PI) * lift;
        out.push({ pos: p, bank: (1 - u) * (a.bank || 0) + u * (b.bank || 0), u });
      }
    }
    return out;
  }

  function nearestBranchCurveHitScreen(sx, sy, org, s, maxPix = 12) {
    sanitizeBranchSections();
    const subdiv = effectiveSubdiv();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const sec = branchSections[si];
      const smp = sampleBranchSection(sec, subdiv);
      if (smp.length < 2) continue;
      let prev = smp[0];
      let prevSp = screenFromWorld2(prev.pos, org, s);
      for (let i = 1; i < smp.length; i++) {
        const cur = smp[i];
        const curSp = screenFromWorld2(cur.pos, org, s);
        const hit = closestPointOnScreenSegment(sx, sy, prevSp.x, prevSp.y, curSp.x, curSp.y);
        if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
          const u = prev.u + (cur.u - prev.u) * hit.t;
          const pos = add(mul(prev.pos, 1 - hit.t), mul(cur.pos, hit.t));
          const tan = norm(sub(cur.pos, prev.pos));
          best = { dist: hit.d, sec: si, u, pos, tan };
        }
        prev = cur;
        prevSp = curSp;
      }
    }
    return best;
  }

  function nearestBranchMidpointScreen(sx, sy, org, s, maxPix = 12) {
    sanitizeBranchSections();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const mids = branchSections[si]?.mids || [];
      for (let mi = 0; mi < mids.length; mi++) {
        const m = mids[mi];
        const sp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const d = Math.hypot(sp.x - sx, sp.y - sy);
        if (d <= maxPix && (!best || d < best.dist)) best = { sec: si, mid: mi, dist: d };
      }
    }
    return best;
  }

  function insertBranchMidpoint(secIdx, u, pos, tanHint = null) {
    const sec = branchSections[secIdx];
    if (!sec || !pos) return false;
    const sp = snapRoadXYZ(pos.x, pos.y, pos.z);
    const midPos = v3(sp.x, sp.y, sp.z);
    if (!Array.isArray(sec.mids)) sec.mids = [];
    const prev = points[sec.a]?.pos || midPos;
    const next = points[sec.b]?.pos || midPos;
    const inDist = Math.max(0.08, len(sub(midPos, prev)));
    const outDist = Math.max(0.08, len(sub(next, midPos)));
    let t = tanHint ? norm(v3(tanHint.x, 0, tanHint.z)) : norm(sub(next, prev));
    if (!Number.isFinite(t.x) || !Number.isFinite(t.z) || Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
    const hIn = inDist * 0.34;
    const hOut = outDist * 0.34;
    sec.mids.push({
      u: clamp(Number(u || 0.5), 0.001, 0.999),
      x: midPos.x,
      y: midPos.y,
      z: midPos.z,
      bevel: 0.55,
      node: 'smooth',
      hin: { x: -t.x * hIn, z: -t.z * hIn },
      hout: { x: t.x * hOut, z: t.z * hOut },
    });
    sanitizeBranchSections();
    const mids = sec.mids || [];
    let best = 0;
    let bestD = 1e9;
    for (let i = 0; i < mids.length; i++) {
      const d = Math.abs(mids[i].u - u);
      if (d < bestD) { bestD = d; best = i; }
    }
    selectBranchMidpoint(secIdx, best);
    return true;
  }

  function cloneSampleNode(s) {
    return {
      pos: v3(s?.pos?.x || 0, s?.pos?.y || 0, s?.pos?.z || 0),
      bank: Number(s?.bank || 0),
      u: Number(s?.u || 0),
    };
  }

  function lerpSampleNode(a, b, t) {
    const ta = clamp(Number(t), 0, 1);
    const tb = 1 - ta;
    return {
      pos: v3(
        a.pos.x * tb + b.pos.x * ta,
        a.pos.y * tb + b.pos.y * ta,
        a.pos.z * tb + b.pos.z * ta
      ),
      bank: Number(a.bank || 0) * tb + Number(b.bank || 0) * ta,
      u: Number(a.u || 0) * tb + Number(b.u || 0) * ta,
    };
  }

  function sampleDistXZ(a, b) {
    return Math.hypot((a?.pos?.x || 0) - (b?.pos?.x || 0), (a?.pos?.z || 0) - (b?.pos?.z || 0));
  }

  function pushSampleUnique(out, s, epsXZ = 1e-3) {
    if (!out.length) { out.push(cloneSampleNode(s)); return; }
    const last = out[out.length - 1];
    if (sampleDistXZ(last, s) <= epsXZ && Math.abs((last.pos.y || 0) - (s?.pos?.y || 0)) <= epsXZ) {
      out[out.length - 1] = cloneSampleNode(s);
      return;
    }
    out.push(cloneSampleNode(s));
  }

  function sanitizeRoadSamples(samples, opts = {}) {
    if (!Array.isArray(samples) || samples.length < 2) return Array.isArray(samples) ? samples.slice() : [];
    const closed = !!opts.closed;
    const width = Math.max(1, Number(opts.width || 4));
    const maxTurn = clamp(Number(opts.maxTurnDeg || 33.33), 8, 160) * Math.PI / 180;
    const pass = Math.max(0, Math.min(4, Number(opts._pass || 0)));
    const minSeg = Math.max(0.04, width * 0.035);
    const dedupEps = Math.max(0.001, minSeg * 0.35);
    const filletScale = 0.42;
    const filletMin = Math.max(minSeg * 1.45, width * 0.34);

    const base = [];
    for (const s of samples) {
      if (!base.length) { base.push(cloneSampleNode(s)); continue; }
      const last = base[base.length - 1];
      if (sampleDistXZ(last, s) < minSeg * 0.65 && Math.abs((last.pos.y || 0) - (s?.pos?.y || 0)) < minSeg * 0.5) {
        base[base.length - 1] = lerpSampleNode(last, cloneSampleNode(s), 0.5);
      } else {
        base.push(cloneSampleNode(s));
      }
    }
    if (closed && base.length > 2 && sampleDistXZ(base[0], base[base.length - 1]) < minSeg * 0.65) base.pop();
    if (base.length < 3) return base;

    const out = [];
    const n = base.length;
    for (let i = 0; i < n; i++) {
      const isEnd = !closed && (i === 0 || i === n - 1);
      if (isEnd) {
        pushSampleUnique(out, base[i], dedupEps);
        continue;
      }
      const pi = (i - 1 + n) % n;
      const ni = (i + 1) % n;
      const P = base[pi];
      const C = base[i];
      const N = base[ni];
      const vin = v3(C.pos.x - P.pos.x, 0, C.pos.z - P.pos.z);
      const vout = v3(N.pos.x - C.pos.x, 0, N.pos.z - C.pos.z);
      const lin = Math.hypot(vin.x, vin.z);
      const lout = Math.hypot(vout.x, vout.z);
      if (lin < minSeg || lout < minSeg) {
        pushSampleUnique(out, C, dedupEps);
        continue;
      }
      const din = v3(vin.x / lin, 0, vin.z / lin);
      const dout = v3(vout.x / lout, 0, vout.z / lout);
      const ang = Math.acos(clamp(din.x * dout.x + din.z * dout.z, -1, 1));
      if (!Number.isFinite(ang) || ang <= maxTurn) {
        pushSampleUnique(out, C, dedupEps);
        continue;
      }

      const hard = clamp((ang - maxTurn) / Math.max(1e-6, Math.PI - maxTurn), 0, 1);
      const targetRadius = width * (0.58 + 0.34 * hard);
      const tanHalf = Math.max(0.10, Math.tan(ang * 0.5));
      const desiredCut = targetRadius / tanHalf;
      const baseCut = Math.min(lin, lout) * (0.18 + filletScale * hard);
      const cut = clamp(Math.max(baseCut, desiredCut), filletMin, Math.min(lin, lout) * 0.48);
      const tIn = clamp(cut / lin, 0.05, 0.45);
      const tOut = clamp(cut / lout, 0.05, 0.45);
      const A = lerpSampleNode(C, P, tIn);
      const B = lerpSampleNode(C, N, tOut);
      const segs = clamp(Math.round(3 + hard * 5), 3, 8);

      pushSampleUnique(out, A, dedupEps);
      for (let k = 1; k < segs; k++) {
        const t = k / segs;
        const qa = lerpSampleNode(A, C, t);
        const qb = lerpSampleNode(C, B, t);
        const q = lerpSampleNode(qa, qb, t);
        pushSampleUnique(out, q, dedupEps);
      }
      pushSampleUnique(out, B, dedupEps);
    }

    if (closed && out.length > 2 && sampleDistXZ(out[0], out[out.length - 1]) < dedupEps * 2) out.pop();
    const sanitized = out.length >= 2 ? out : base;
    if (pass >= 2 || sanitized.length < 3) return sanitized;

    let hasHard = false;
    const n2 = sanitized.length;
    for (let i = 0; i < n2; i++) {
      if (!closed && (i === 0 || i === n2 - 1)) continue;
      const pi = (i - 1 + n2) % n2;
      const ni = (i + 1) % n2;
      const P = sanitized[pi];
      const C = sanitized[i];
      const N = sanitized[ni];
      const vin = v3(C.pos.x - P.pos.x, 0, C.pos.z - P.pos.z);
      const vout = v3(N.pos.x - C.pos.x, 0, N.pos.z - C.pos.z);
      const lin = Math.hypot(vin.x, vin.z);
      const lout = Math.hypot(vout.x, vout.z);
      if (lin < minSeg || lout < minSeg) continue;
      const d = clamp((vin.x * vout.x + vin.z * vout.z) / (lin * lout), -1, 1);
      const ang = Math.acos(d);
      if (Number.isFinite(ang) && ang > maxTurn * 1.03) { hasHard = true; break; }
    }
    if (!hasHard) return sanitized;
    return sanitizeRoadSamples(sanitized, { ...opts, _pass: pass + 1 });
  }

  function sampleRoadNetwork() {
    sanitizeBranchSections();
    const subdiv = effectiveSubdiv();
    const roadW = Math.max(1, num('roadWidth'));
    const cornerDeg = 33.33;
    const mainRaw = sampleSpline(points, subdiv, chk('closed'), autoBankCfg());
    const main = sanitizeRoadSamples(mainRaw, { closed: chk('closed'), width: roadW, maxTurnDeg: cornerDeg });
    const branches = [];
    for (const sec of branchSections) {
      const raw = sampleBranchSection(sec, subdiv);
      const samples = sanitizeRoadSamples(raw, { closed: false, width: roadW, maxTurnDeg: cornerDeg });
      if (samples.length > 1) branches.push(samples);
    }
    const all = main.slice();
    for (const s of branches) all.push(...s);
    return { main, branches, all, subdiv };
  }

  function cloneMesh(mesh, nameOverride = null) {
    return {
      name: nameOverride || mesh.name,
      verts: mesh.verts.map((p) => v3(p.x, p.y, p.z)),
      uvs: mesh.uvs.map((uv) => ({ u: uv.u, v: uv.v })),
      faces: mesh.faces.map((f) => ({ ...f })),
    };
  }

  function mergeMeshInto(dst, src) {
    const vOff = dst.verts.length;
    const uvOff = dst.uvs.length;
    for (const p of src.verts) dst.verts.push(v3(p.x, p.y, p.z));
    for (const uv of src.uvs) dst.uvs.push({ u: uv.u, v: uv.v });
    for (const f of src.faces) {
      dst.faces.push({
        a: f.a + vOff,
        b: f.b + vOff,
        c: f.c + vOff,
        au: f.au + uvOff,
        bu: f.bu + uvOff,
        cu: f.cu + uvOff,
      });
    }
  }

  function addJunctionPads(roadTop, width) {
    sanitizeBranchSections();
    if (!roadTop || !Array.isArray(roadTop.verts) || !branchSections.length) return;
    const used = new Set();
    const junctionIdx = [];
    for (const sec of branchSections) {
      if (Number.isInteger(sec.a) && !used.has(sec.a)) { used.add(sec.a); junctionIdx.push(sec.a); }
      if (Number.isInteger(sec.b) && !used.has(sec.b)) { used.add(sec.b); junctionIdx.push(sec.b); }
    }
    if (!junctionIdx.length) return;

    const addRingStrip = (mesh, inner, outer) => {
      const n = Math.min(inner.length, outer.length);
      if (n < 3) return;
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const a0 = inner[i], a1 = inner[j];
        const b0 = outer[i], b1 = outer[j];
        meshAddTri(mesh, a0, b0, b1);
        meshAddTri(mesh, a0, b1, a1);
      }
    };

    const ringSteps = 22;
    const yLift = 0.014;
    const r0 = Math.max(0.14, width * 0.16);
    const r1 = Math.max(r0 + 0.08, width * 0.40);
    const r2 = Math.max(r1 + 0.08, width * 0.70);
    for (const idx of junctionIdx) {
      const p = points[idx]?.pos;
      if (!p) continue;
      let t = tangentAtIndex(idx);
      t = norm(v3(t.x, 0, t.z));
      if (Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
      const r = norm(v3(-t.z, 0, t.x));
      const rings = [[], [], []];
      const radii = [r0, r1, r2];
      for (let ri = 0; ri < radii.length; ri++) {
        const rr = radii[ri];
        const vv = ri / Math.max(1, radii.length - 1);
        for (let k = 0; k < ringSteps; k++) {
          const a = (k / ringSteps) * Math.PI * 2;
          const offs = add(mul(r, Math.cos(a) * rr), mul(t, Math.sin(a) * rr));
          const vx = p.x + offs.x;
          const vz = p.z + offs.z;
          const vy = p.y + yLift - vv * 0.006;
          rings[ri].push(meshAddVertex(roadTop, v3(vx, vy, vz), (k / ringSteps), vv));
        }
      }
      addRingStrip(roadTop, rings[0], rings[1]);
      addRingStrip(roadTop, rings[1], rings[2]);
    }
  }

  // ---------- mesh generation ----------
  function buildRoadMesh(samples, opts) {
    const { width, thickness, includeSides, uvScale, capEnds = false, closed = false } = opts;
    const half = width / 2;
    const pointCount = samples.length;
    if (pointCount < 2) return { roadTop: { name: 'road_top', verts: [], uvs: [], faces: [] }, roadSides: null, frames: [] };
    const dists = [0];
    for (let i = 1; i < pointCount; i++) dists.push(dists[i - 1] + len(sub(samples[i].pos, samples[i - 1].pos)));
    const segCount = closed ? pointCount : pointCount - 1;

    const roadTop = { name: 'road_top', verts: [], uvs: [], faces: [] };
    const frames = [];
    const worldUp = v3(0, 1, 0);
    let prevR = v3(1, 0, 0);
    const triEps = Math.max(1e-6, width * 0.0008);
    const triArea = (a, b, c) => len(cross(sub(b, a), sub(c, a)));
    const pushFaceSafe = (mesh, a, b, c, au, bu, cu) => {
      const A = mesh.verts[a - 1];
      const B = mesh.verts[b - 1];
      const C = mesh.verts[c - 1];
      if (!A || !B || !C) return;
      if (triArea(A, B, C) <= triEps) return;
      mesh.faces.push({ a, b, c, au, bu, cu });
    };

    for (let i = 0; i < pointCount; i++) {
      const prev = samples[closed ? ((i - 1 + pointCount) % pointCount) : Math.max(0, i - 1)].pos;
      const next = samples[closed ? ((i + 1) % pointCount) : Math.min(pointCount - 1, i + 1)].pos;
      const T = norm(sub(next, prev));
      let R = cross(worldUp, T);
      if (len(R) < 1e-6) R = prevR; else R = norm(R);
      let U = norm(cross(T, R));
      const bankRad = (samples[i].bank || 0) * Math.PI / 180;
      R = rotateAxis(R, T, bankRad);
      U = rotateAxis(U, T, bankRad);
      prevR = R;
      frames.push({ T, R, U });
    }

    for (let i = 0; i < pointCount; i++) {
      const P = samples[i].pos;
      const R = frames[i].R;
      const left = add(P, mul(R, half));
      const right = add(P, mul(R, -half));
      const u = ((dists[i] / uvScale) % 1 + 1) % 1;
      roadTop.verts.push(left); roadTop.uvs.push({ u, v: 0 });
      roadTop.verts.push(right); roadTop.uvs.push({ u, v: 1 });
    }
    for (let i = 0; i < segCount; i++) {
      const j = closed ? ((i + 1) % pointCount) : (i + 1);
      const aL = i * 2 + 1, aR = i * 2 + 2, bL = j * 2 + 1, bR = j * 2 + 2;
      // Corner-aware quad split: choose the diagonal that better conforms to local curve geometry.
      const pAL = roadTop.verts[aL - 1];
      const pAR = roadTop.verts[aR - 1];
      const pBL = roadTop.verts[bL - 1];
      const pBR = roadTop.verts[bR - 1];
      const dMain = Math.hypot(pAL.x - pBR.x, pAL.y - pBR.y, pAL.z - pBR.z);
      const dAlt = Math.hypot(pAR.x - pBL.x, pAR.y - pBL.y, pAR.z - pBL.z);
      if (dMain <= dAlt) {
        pushFaceSafe(roadTop, aL, bL, bR, aL, bL, bR);
        pushFaceSafe(roadTop, aL, bR, aR, aL, bR, aR);
      } else {
        pushFaceSafe(roadTop, aL, bL, aR, aL, bL, aR);
        pushFaceSafe(roadTop, aR, bL, bR, aR, bL, bR);
      }
    }

    let roadSides = null;
    if (includeSides) {
      roadSides = { name: 'road_sides', verts: [], uvs: [], faces: [] };
      for (let i = 0; i < pointCount; i++) {
        const P = samples[i].pos;
        const R = frames[i].R;
        const lt = add(P, mul(R, half));
        const lb = add(lt, v3(0, -thickness, 0));
        const rt = add(P, mul(R, -half));
        const rb = add(rt, v3(0, -thickness, 0));
        const u = ((dists[i] / uvScale) % 1 + 1) % 1;
        roadSides.verts.push(lt); roadSides.uvs.push({ u, v: 0 });
        roadSides.verts.push(lb); roadSides.uvs.push({ u, v: 1 });
        roadSides.verts.push(rt); roadSides.uvs.push({ u, v: 0 });
        roadSides.verts.push(rb); roadSides.uvs.push({ u, v: 1 });
      }
      for (let i = 0; i < segCount; i++) {
        const j = closed ? ((i + 1) % pointCount) : (i + 1);
        const base0 = i * 4, base1 = j * 4;
        const lt0 = base0 + 1, lb0 = base0 + 2, rt0 = base0 + 3, rb0 = base0 + 4;
        const lt1 = base1 + 1, lb1 = base1 + 2, rt1 = base1 + 3, rb1 = base1 + 4;
        pushFaceSafe(roadSides, lt0, lb1, lb0, lt0, lb1, lb0);
        pushFaceSafe(roadSides, lt0, lt1, lb1, lt0, lt1, lb1);
        pushFaceSafe(roadSides, rt0, rb0, rb1, rt0, rb0, rb1);
        pushFaceSafe(roadSides, rt0, rb1, rt1, rt0, rb1, rt1);
        // Bottom strip for closed manifold road volume.
        pushFaceSafe(roadSides, lb0, lb1, rb1, lb0, lb1, rb1);
        pushFaceSafe(roadSides, lb0, rb1, rb0, lb0, rb1, rb0);
      }
      if (capEnds && !closed && pointCount >= 2) {
        const ltS = 1, lbS = 2, rtS = 3, rbS = 4;
        const bE = (pointCount - 1) * 4;
        const ltE = bE + 1, lbE = bE + 2, rtE = bE + 3, rbE = bE + 4;
        pushFaceSafe(roadSides, ltS, rbS, lbS, ltS, rbS, lbS);
        pushFaceSafe(roadSides, ltS, rtS, rbS, ltS, rtS, rbS);
        pushFaceSafe(roadSides, ltE, lbE, rbE, ltE, lbE, rbE);
        pushFaceSafe(roadSides, ltE, rbE, rtE, ltE, rbE, rtE);
      }
    }

    return { roadTop, roadSides, frames };
  }

  function buildTerrainMesh(samples, opts) {
    if (!samples || samples.length < 2) return null;
    const roadWidth = Math.max(1, opts.roadWidth || 4);
    const roadThickness = Math.max(0.02, opts.roadThickness || 0.7);
    const shoulderWidth = Math.max(0.2, opts.shoulderWidth || 2.4);
    const roughness = Math.max(0, opts.roughness || 1);
    const cliffHeight = Math.max(0.5, opts.cliffHeight || 4);
    const kartStyle = clamp(Number.isFinite(opts.kartStyle) ? opts.kartStyle : 0.78, 0, 1);
    const detail = clamp(Number.isFinite(opts.detail) ? opts.detail : 0.62, 0, 1);
    const margin = Math.max(22, roadWidth * 7.5);
    const cellBase = 2.35 - 0.55 * kartStyle;
    const cell = clamp(cellBase * (1.18 - detail * 0.58), 0.85, 2.6);

    let minX = +1e9, minY = +1e9, minZ = +1e9, maxX = -1e9, maxZ = -1e9;
    for (const s of samples) {
      minX = Math.min(minX, s.pos.x); minY = Math.min(minY, s.pos.y); minZ = Math.min(minZ, s.pos.z);
      maxX = Math.max(maxX, s.pos.x); maxZ = Math.max(maxZ, s.pos.z);
    }
    minX -= margin; maxX += margin; minZ -= margin; maxZ += margin;

    const maxGrid = Math.round((samples.length > 1100 ? 108 : 148) + detail * 70);
    const minGrid = Math.round(24 + detail * 18);
    const nx = clamp(Math.floor((maxX - minX) / cell) + 1, minGrid, maxGrid);
    const nz = clamp(Math.floor((maxZ - minZ) / cell) + 1, minGrid, maxGrid);
    const sx = (maxX - minX) / (nx - 1);
    const sz = (maxZ - minZ) / (nz - 1);
    const probeStep = samples.length > 1200 ? 3 : (samples.length > 700 ? 2 : 1);
    const curbWidth = clamp(0.22 + shoulderWidth * 0.2, 0.18, 0.95);
    const supportPad = Math.max(0.8, roadWidth * 0.46);
    const supportEdge = roadWidth * 0.5 + curbWidth + shoulderWidth + supportPad;
    const strictProbeRadiusBase = roadWidth * 1.45 + shoulderWidth * 1.05 + curbWidth * 0.9;
    const halfRoad = roadWidth * 0.5;
    const slopeLen = 4.8 + cliffHeight * 0.8;
    const baseY = minY - (1.4 + cliffHeight * 0.55);
    const bridgeGap = Math.max(1.05, roadThickness + 0.55);
    const terrainUnderRoadBias = 0.14 + roadThickness * 0.05;
    const postSmoothGap = 0.02 + roadThickness * 0.02;
    const roadClearance = clamp(
      Number.isFinite(opts.roadClearance) ? opts.roadClearance : (0.12 + roadThickness * 0.18),
      0.05,
      1.6
    );
    const followRoad = clamp(Number.isFinite(opts.followRoad) ? opts.followRoad : 0.88, 0, 1);
    const shoulderBevelDepth = 0.16 + shoulderWidth * 0.08;

    const terrain = { name: 'terrain_cliffs', verts: [], uvs: [], faces: [] };
    const smoothstep = (a, b, x) => {
      const t = clamp((x - a) / Math.max(1e-6, b - a), 0, 1);
      return t * t * (3 - 2 * t);
    };
    const noise2 = (x, z) => {
      const a = Math.sin(x * 0.31 + z * 0.19);
      const b = Math.cos(x * 0.17 - z * 0.27);
      return (a + b) * 0.5;
    };
    const crossingZones = (() => {
      const zones = [];
      const nS = samples.length;
      const minSep = Math.max(14, Math.floor(nS * 0.08));
      const pairStep = nS > 520 ? 3 : 2;
      const hitDist = Math.max(1.8, roadWidth * 0.95 + shoulderWidth * 0.45);
      const maxParallelDot = Math.cos(18 * Math.PI / 180);
      const tangentAt = (idx) => {
        const a = samples[Math.max(0, idx - 1)].pos;
        const b = samples[Math.min(nS - 1, idx + 1)].pos;
        let t = v3(b.x - a.x, 0, b.z - a.z);
        if (len(t) < 1e-6) t = v3(1, 0, 0);
        return norm(t);
      };
      for (let i = 0; i < nS; i += pairStep) {
        const pi = samples[i].pos;
        const ti = tangentAt(i);
        for (let j = i + minSep; j < nS; j += pairStep) {
          if (Math.abs(j - i) < minSep) continue;
          const pj = samples[j].pos;
          const d = Math.hypot(pi.x - pj.x, pi.z - pj.z);
          if (d > hitDist) continue;
          const tj = tangentAt(j);
          if (Math.abs(dot(ti, tj)) > maxParallelDot) continue;
          const dy = pj.y - pi.y;
          if (Math.abs(dy) < bridgeGap) continue;
          const lowerIdx = dy > 0 ? i : j;
          const lowerP = samples[lowerIdx].pos;
          const lowerT = tangentAt(lowerIdx);
          const zone = {
            cx: lowerP.x,
            cz: lowerP.z,
            lowerY: lowerP.y,
            t: lowerT,
            major: roadWidth * 5.6 + shoulderWidth * 3.1 + Math.abs(dy) * 1.35,
            minor: roadWidth * 2.6 + shoulderWidth * 1.55,
            weight: clamp(Math.abs(dy) / Math.max(1e-6, bridgeGap * 2.1), 0.55, 1.15),
          };
          let merged = false;
          for (const z of zones) {
            if (Math.hypot(z.cx - zone.cx, z.cz - zone.cz) < roadWidth * 1.8) {
              if (zone.weight > z.weight) {
                z.cx = zone.cx; z.cz = zone.cz; z.lowerY = zone.lowerY; z.t = zone.t;
              }
              z.major = Math.max(z.major, zone.major);
              z.minor = Math.max(z.minor, zone.minor);
              z.weight = Math.max(z.weight, zone.weight);
              merged = true;
              break;
            }
          }
          if (!merged) zones.push(zone);
        }
      }
      return zones;
    })();
    const junctionZones = (() => {
      const out = [];
      if (!Array.isArray(branchSections) || !branchSections.length) return out;
      const used = new Set();
      for (const sec of branchSections) {
        for (const i of [sec.a, sec.b]) {
          if (!Number.isInteger(i) || i < 0 || i >= points.length || used.has(i)) continue;
          used.add(i);
          const p = points[i]?.pos;
          if (!p) continue;
          out.push({
            x: p.x,
            z: p.z,
            y: p.y,
            r: roadWidth * 0.95 + shoulderWidth * 1.05 + curbWidth * 0.95,
          });
        }
      }
      return out;
    })();

    const hField = new Float64Array(nx * nz);
    const capField = new Float64Array(nx * nz);
    const dField = new Float64Array(nx * nz);
    const boostField = new Float64Array(nx * nz);

    for (let iz = 0; iz < nz; iz++) {
      for (let ix = 0; ix < nx; ix++) {
        const x = minX + ix * sx;
        const z = minZ + iz * sz;
        let d1 = 1e9, d2 = 1e9, d3 = 1e9, d4 = 1e9;
        let y1 = minY, y2 = minY, y3 = minY, y4 = minY;
        let b1 = 0, b2 = 0, b3 = 0, b4 = 0;
        // Primary distance from road polyline segments (not only sample points),
        // so terrain shoulders conform smoothly to the road curve shape.
        let dSeg = 1e9;
        let ySeg = minY;
        let bSeg = 0;
        let deckSegY = minY;
        let edgeDistSeg = 1e9;
        for (let k = 0; k < samples.length - 1; k += probeStep) {
          const a = samples[k];
          const b = samples[Math.min(samples.length - 1, k + probeStep)];
          const ax = a.pos.x, az = a.pos.z;
          const bx = b.pos.x, bz = b.pos.z;
          const vx = bx - ax, vz = bz - az;
          const vLen2 = vx * vx + vz * vz;
          if (vLen2 < 1e-8) continue;
          let t = ((x - ax) * vx + (z - az) * vz) / vLen2;
          t = clamp(t, 0, 1);
          const qx = ax + vx * t;
          const qz = az + vz * t;
          const d = Math.hypot(x - qx, z - qz);
          if (d < dSeg) {
            dSeg = d;
            const yL = a.pos.y * (1 - t) + b.pos.y * t;
            const bankL = (a.bank || 0) * (1 - t) + (b.bank || 0) * t;
            const tx = vx / Math.sqrt(vLen2);
            const tz = vz / Math.sqrt(vLen2);
            const rx = -tz, rz = tx;
            const dx = x - qx, dz = z - qz;
            const lateral = dx * rx + dz * rz;
            const lateralDeck = clamp(lateral, -halfRoad, halfRoad);
            const deckY = yL + Math.tan(bankL * Math.PI / 180) * lateralDeck;
            ySeg = yL;
            bSeg = bankL;
            deckSegY = deckY;
            edgeDistSeg = Math.max(0, Math.abs(lateral) - halfRoad);
          }
        }
        for (let k = 0; k < samples.length; k += probeStep) {
          const p = samples[k].pos;
          const d = Math.hypot(x - p.x, z - p.z);
          if (d < d1) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d2; y3 = y2; b3 = b2;
            d2 = d1; y2 = y1; b2 = b1;
            d1 = d; y1 = p.y; b1 = samples[k].bank || 0;
          } else if (d < d2) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d2; y3 = y2; b3 = b2;
            d2 = d; y2 = p.y; b2 = samples[k].bank || 0;
          } else if (d < d3) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d; y3 = p.y; b3 = samples[k].bank || 0;
          } else if (d < d4) {
            d4 = d; y4 = p.y; b4 = samples[k].bank || 0;
          }
        }
        if (dSeg < d1) {
          d4 = d3; y4 = y3; b4 = b3;
          d3 = d2; y3 = y2; b3 = b2;
          d2 = d1; y2 = y1; b2 = b1;
          d1 = dSeg; y1 = ySeg; b1 = bSeg;
        }
        let crossingBoost = 0;
        let zoneLowerY = +1e9;
        for (const cz of crossingZones) {
          const vx = x - cz.cx;
          const vz = z - cz.cz;
          const u = vx * cz.t.x + vz * cz.t.z;
          const v = -vx * cz.t.z + vz * cz.t.x;
          const e = (u * u) / (cz.major * cz.major) + (v * v) / (cz.minor * cz.minor);
          if (e >= 1) continue;
          const b = Math.pow(1 - e, 0.55) * cz.weight;
          if (b > crossingBoost) crossingBoost = b;
          zoneLowerY = Math.min(zoneLowerY, cz.lowerY);
        }
        let junctionBoost = 0;
        let junctionY = +1e9;
        for (const jz of junctionZones) {
          const dd = Math.hypot(x - jz.x, z - jz.z);
          if (dd >= jz.r) continue;
          const t = clamp(1 - dd / Math.max(1e-6, jz.r), 0, 1);
          const b = t * t;
          if (b > junctionBoost) junctionBoost = b;
          junctionY = Math.min(junctionY, jz.y);
        }
        const crossing = ((d2 < supportEdge * 0.92) && (Math.abs(y1 - y2) > bridgeGap)) || crossingBoost > 0.015;
        const useFirst = !crossing || y1 <= y2;
        let laneY = useFirst ? y1 : y2;
        if (crossingBoost > 0.06 && zoneLowerY < 1e8) laneY = Math.min(laneY, zoneLowerY);
        if (junctionBoost > 0.02 && junctionY < 1e8) laneY = Math.min(laneY, junctionY);
        const laneBank = useFirst ? b1 : b2;
        const bankDrop = Math.abs(Math.sin((laneBank || 0) * Math.PI / 180)) * (roadWidth * 0.56) * (1 - crossingBoost * 0.7);
        const laneLowY = Math.min(laneY - bankDrop, deckSegY - roadClearance * 0.18);

        let edgeLocal =
          supportEdge +
          (crossing ? roadWidth * 1.2 + shoulderWidth * 0.8 : 0) +
          crossingBoost * (roadWidth * 4.2 + shoulderWidth * 2.2) +
          junctionBoost * (roadWidth * 1.35 + shoulderWidth * 1.05);
        let slopeLenLocal =
          slopeLen +
          (crossing ? roadWidth * 2.1 : 0) +
          crossingBoost * (roadWidth * 4.8 + shoulderWidth * 2.4) +
          junctionBoost * (roadWidth * 2.2 + shoulderWidth * 1.35);
        if (crossingBoost > 0.12 || (crossing && Math.abs(y1 - y2) > bridgeGap * 1.15)) {
          edgeLocal = Math.max(edgeLocal, supportEdge + roadWidth * 2.35 + shoulderWidth * 1.45);
          slopeLenLocal = Math.max(slopeLenLocal, slopeLen + roadWidth * 4.4 + shoulderWidth * 2.7);
        }
        const dEdgeBased = Math.min(d1, edgeDistSeg + halfRoad);
        const dForShape = d1 * (1 - followRoad) + dEdgeBased * followRoad;
        const insideT = clamp(dForShape / Math.max(0.01, edgeLocal), 0, 1);
        const bevel = (1 - Math.cos(insideT * Math.PI)) * 0.5;
        const shoulderEdgeDrop = 0.24 + shoulderWidth * 0.09;
        const nearRoadDeck = deckSegY - (roadClearance * (1 - insideT * 0.52)) - (shoulderEdgeDrop * Math.pow(bevel, 0.95));
        const nearRoadLane = laneLowY - (roadClearance * (1 - insideT) * (1 - insideT));
        const nearRoadY = nearRoadLane * (1 - followRoad) + Math.min(nearRoadDeck, nearRoadLane) * followRoad;

        const tfar = clamp((dForShape - edgeLocal) / (margin * 0.62), 0, 1);
        const ridge = cliffHeight * Math.pow(tfar, 1.16);
        const macroNoise = noise2(x * 0.16 - 13.7, z * 0.14 + 8.9);
        const mountainNoise = Math.abs(noise2(x * 0.055 + 17.1, z * 0.051 - 11.8));
        const ridgeNoise = Math.abs(noise2(x * 0.094 - 6.4, z * 0.088 + 9.2));
        const roughScale = 1 - 0.52 * kartStyle;
        const terrainNoise = (noise2(x, z) * 0.62 + noise2(x * 0.73 + 4.1, z * 0.81 - 3.7) * 0.38) * 0.72 + macroNoise * 0.28;
        const mountainLift = (cliffHeight * (0.56 + 0.55 * roughness)) * Math.pow(tfar, 1.35) * (0.28 + mountainNoise * 0.72);
        const ridgeLift = cliffHeight * 0.44 * Math.pow(tfar, 1.72) * Math.pow(ridgeNoise, 1.8);
        const hillNoise = terrainNoise * roughness * roughScale * (0.10 + 0.90 * Math.pow(tfar, 0.8 + 0.4 * kartStyle));
        const hillY = baseY + ridge + hillNoise + mountainLift + ridgeLift;

        const slopeT = clamp((dForShape - edgeLocal) / slopeLenLocal, 0, 1);
        const elev = Math.max(0, nearRoadY - baseY);
        const dropDepth = 1.2 + cliffHeight * 0.95 + elev * 0.42 + (crossing ? roadWidth * 0.45 : 0) + crossingBoost * roadWidth * 0.95;
        const crossExp = clamp(1.02 - crossingBoost * 0.38, 0.68, 1.02);
        const supportY = nearRoadY - Math.pow(slopeT, crossing ? crossExp : 1.22) * dropDepth;

        let y = Math.max(hillY, supportY);

        // Force terrain to meet road-side shoulders cleanly.
        const joinBlend = smoothstep(edgeLocal - (1.25 + crossingBoost * 0.9), edgeLocal + (0.95 + crossingBoost * 1.2), dForShape);
        y = nearRoadY * (1 - joinBlend) + y * joinBlend;

        // For stacked crossings, widen/lower the local base so the lower pass is smoother.
        if (crossing) {
          const carve = smoothstep(roadWidth * 0.03, edgeLocal * (0.98 + 0.25 * crossingBoost), dForShape);
          y -= (1 - carve) * (0.2 + roadWidth * 0.05 + crossingBoost * roadWidth * 0.16);
        }

        // Keep a wider, smoother playable apron around the road before cliffs start.
        const apronRange = slopeLenLocal * (0.45 + 0.25 * kartStyle) + shoulderWidth * (0.8 + 0.7 * kartStyle);
        const apronT = 1 - smoothstep(edgeLocal + shoulderWidth * 0.15, edgeLocal + apronRange, dForShape);
        const apronStrength = 0.22 + 0.42 * kartStyle;
        if (apronT > 1e-4) {
          const mix = clamp(apronT * apronStrength, 0, 0.88);
          y = y * (1 - mix) + nearRoadY * mix;
        }

        // Enforce a rounded, always-down outer shoulder bevel into terrain.
        const shoulderOuter = roadWidth * 0.5 + curbWidth + shoulderWidth;
        const shoulderBevelWidth = clamp(0.85 + shoulderWidth * 0.52 + crossingBoost * 0.8, 0.85, 6.8);
        if (dForShape > shoulderOuter - 0.22 && dForShape < shoulderOuter + shoulderBevelWidth + 0.34) {
          const st = smoothstep(shoulderOuter - 0.10, shoulderOuter + shoulderBevelWidth, dForShape);
          const sround = (1 - Math.cos(st * Math.PI)) * 0.5;
          const shoulderBase = laneLowY - roadClearance * 0.62 - shoulderEdgeDrop * 0.58;
          const shoulderTarget = shoulderBase - (shoulderBevelDepth + 0.24 + crossingBoost * 0.3) * sround;
          y = Math.min(y, shoulderTarget);
        }

        // Hard safety cap: terrain must stay below nearby road deck to prevent clipping.
        const capClear = (roadClearance * (1 - insideT * 0.35)) + terrainUnderRoadBias + crossingBoost * 0.14 + junctionBoost * 0.20;
        let hardCap = laneLowY - capClear;
        const probeRadius = strictProbeRadiusBase + crossingBoost * (roadWidth * 1.3 + shoulderWidth * 0.9);
        const probeDs = [d1, d2, d3, d4];
        const probeYs = [y1, y2, y3, y4];
        const probeBanks = [b1, b2, b3, b4];
        for (let qi = 0; qi < 4; qi++) {
          const pd = probeDs[qi];
          if (!Number.isFinite(pd) || pd > probeRadius) continue;
          const pInside = clamp(pd / Math.max(0.01, roadWidth * 0.5 + curbWidth + shoulderWidth * 0.9), 0, 1);
          const pBankDrop = Math.abs(Math.sin((probeBanks[qi] || 0) * Math.PI / 180)) * (roadWidth * 0.58);
          const pClear = roadClearance * (1 - pInside * 0.42) + terrainUnderRoadBias + (1 - pInside) * 0.05 + junctionBoost * 0.08;
          const pCap = probeYs[qi] - pBankDrop - pClear;
          if (pCap < hardCap) hardCap = pCap;
        }
        if (y > hardCap) y = hardCap;
        const idx = iz * nx + ix;
        hField[idx] = y;
        capField[idx] = hardCap;
        dField[idx] = d1;
        boostField[idx] = Math.max(crossingBoost, junctionBoost * 0.8);
      }
    }

    // Post-smooth terrain for kart-like readability while preserving shoulders/clearance.
    const smoothPasses = 2 + Math.round(kartStyle * 2 + detail * 2);
    for (let pass = 0; pass < smoothPasses; pass++) {
      const prev = hField.slice();
      for (let iz = 1; iz < nz - 1; iz++) {
        for (let ix = 1; ix < nx - 1; ix++) {
          const idx = iz * nx + ix;
          const d = dField[idx];
          const crossingBoost = boostField[idx];
          const protectRoad = 1 - smoothstep(roadWidth * 0.45, supportEdge + shoulderWidth * 0.55, d);
          const protectShoulder = 1 - smoothstep(
            roadWidth * 0.5 + curbWidth + shoulderWidth * 0.35,
            roadWidth * 0.5 + curbWidth + shoulderWidth * 1.15,
            d
          );
          let w = (0.08 + 0.20 * kartStyle) * (1 - protectRoad * 0.88) * (1 - protectShoulder * 0.45);
          if (crossingBoost > 0.05) w *= 0.52;
          if (w < 1e-4) continue;
          const nsum = prev[idx - 1] + prev[idx + 1] + prev[idx - nx] + prev[idx + nx];
          const dsum = prev[idx - nx - 1] + prev[idx - nx + 1] + prev[idx + nx - 1] + prev[idx + nx + 1];
          const nAvg = nsum * 0.25;
          const dAvg = dsum * 0.25;
          const avg = nAvg * 0.66 + dAvg * 0.34;
          let ny = prev[idx] * (1 - w) + avg * w;
          const cap = capField[idx];
          if (ny > cap) ny = cap;
          hField[idx] = ny;
        }
      }
    }
    for (let i = 0; i < hField.length; i++) {
      const cap = capField[i] - postSmoothGap;
      if (hField[i] > cap) hField[i] = cap;
    }

    for (let iz = 0; iz < nz; iz++) {
      for (let ix = 0; ix < nx; ix++) {
        const idx = iz * nx + ix;
        const x = minX + ix * sx;
        const z = minZ + iz * sz;
        terrain.verts.push(v3(x, hField[idx], z));
        terrain.uvs.push({ u: ix / Math.max(1, nx - 1), v: iz / Math.max(1, nz - 1) });
      }
    }

    for (let iz = 0; iz < nz - 1; iz++) {
      for (let ix = 0; ix < nx - 1; ix++) {
        const a = iz * nx + ix + 1;
        const b = a + 1;
        const c = a + nx;
        const d = c + 1;
        const pA = terrain.verts[a - 1];
        const pB = terrain.verts[b - 1];
        const pC = terrain.verts[c - 1];
        const pD = terrain.verts[d - 1];
        const dMain = Math.hypot(pA.x - pD.x, pA.y - pD.y, pA.z - pD.z);
        const dAlt = Math.hypot(pB.x - pC.x, pB.y - pC.y, pB.z - pC.z);
        if (dMain <= dAlt) {
          // Keep winding consistent (up-facing normals) for the alternate diagonal.
          terrain.faces.push({ a, b: d, c: b, au: a, bu: d, cu: b });
          terrain.faces.push({ a, b: c, c: d, au: a, bu: c, cu: d });
        } else {
          terrain.faces.push({ a, b: c, c: b, au: a, bu: c, cu: b });
          terrain.faces.push({ a: b, b: c, c: d, au: b, bu: c, cu: d });
        }
      }
    }
    return terrain;
  }

  function makeMesh(name) {
    return { name, verts: [], uvs: [], faces: [] };
  }

  function meshAddVertex(mesh, p, u = 0, v = 0) {
    mesh.verts.push(v3(p.x, p.y, p.z));
    mesh.uvs.push({ u, v });
    return mesh.verts.length;
  }

  function meshAddTri(mesh, a, b, c) {
    mesh.faces.push({ a, b, c, au: a, bu: b, cu: c });
  }

  function meshAddQuad(mesh, p0, p1, p2, p3, u0 = 0, u1 = 1, v0 = 0, v1 = 1) {
    const a = meshAddVertex(mesh, p0, u0, v0);
    const b = meshAddVertex(mesh, p1, u1, v0);
    const c = meshAddVertex(mesh, p2, u1, v1);
    const d = meshAddVertex(mesh, p3, u0, v1);
    meshAddTri(mesh, a, b, c);
    meshAddTri(mesh, a, c, d);
  }

  function meshAddOrientedBox(mesh, center, ax, ay, az, hx, hy, hz) {
    const x = norm(ax), y = norm(ay), z = norm(az);
    const sx = mul(x, hx), sy = mul(y, hy), sz = mul(z, hz);
    const p000 = add(add(add(center, mul(sx, -1)), mul(sy, -1)), mul(sz, -1));
    const p001 = add(add(add(center, mul(sx, -1)), mul(sy, -1)), sz);
    const p010 = add(add(add(center, mul(sx, -1)), sy), mul(sz, -1));
    const p011 = add(add(add(center, mul(sx, -1)), sy), sz);
    const p100 = add(add(add(center, sx), mul(sy, -1)), mul(sz, -1));
    const p101 = add(add(add(center, sx), mul(sy, -1)), sz);
    const p110 = add(add(add(center, sx), sy), mul(sz, -1));
    const p111 = add(add(add(center, sx), sy), sz);
    meshAddQuad(mesh, p000, p100, p110, p010, 0, 1, 0, 1);
    meshAddQuad(mesh, p101, p001, p011, p111, 0, 1, 0, 1);
    meshAddQuad(mesh, p001, p000, p010, p011, 0, 1, 0, 1);
    meshAddQuad(mesh, p100, p101, p111, p110, 0, 1, 0, 1);
    meshAddQuad(mesh, p010, p110, p111, p011, 0, 1, 0, 1);
    meshAddQuad(mesh, p001, p101, p100, p000, 0, 1, 0, 1);
  }

  function meshAddPyramid(mesh, baseCenter, radius, height, rot = 0) {
    const y0 = baseCenter.y;
    const tip = v3(baseCenter.x, y0 + height, baseCenter.z);
    const a0 = rot;
    const a1 = rot + Math.PI * 0.5;
    const a2 = rot + Math.PI;
    const a3 = rot + Math.PI * 1.5;
    const p0 = v3(baseCenter.x + Math.cos(a0) * radius, y0, baseCenter.z + Math.sin(a0) * radius);
    const p1 = v3(baseCenter.x + Math.cos(a1) * radius, y0, baseCenter.z + Math.sin(a1) * radius);
    const p2 = v3(baseCenter.x + Math.cos(a2) * radius, y0, baseCenter.z + Math.sin(a2) * radius);
    const p3 = v3(baseCenter.x + Math.cos(a3) * radius, y0, baseCenter.z + Math.sin(a3) * radius);
    meshAddQuad(mesh, p0, p1, p2, p3, 0, 1, 0, 1);
    const i0 = meshAddVertex(mesh, p0, 0, 0);
    const i1 = meshAddVertex(mesh, p1, 1, 0);
    const i2 = meshAddVertex(mesh, p2, 1, 1);
    const i3 = meshAddVertex(mesh, p3, 0, 1);
    const it = meshAddVertex(mesh, tip, 0.5, 1);
    meshAddTri(mesh, i0, i1, it);
    meshAddTri(mesh, i1, i2, it);
    meshAddTri(mesh, i2, i3, it);
    meshAddTri(mesh, i3, i0, it);
  }

  function hash01(n) {
    const s = Math.sin(n * 127.1 + 311.7) * 43758.5453123;
    return s - Math.floor(s);
  }

  function buildThemeMeshes(samples, frames, opts) {
    if (!samples || samples.length < 2 || !frames || !opts?.enabled) return [];
    const out = [];
    const roadWidth = Math.max(1, opts.roadWidth || 4.5);
    const half = roadWidth * 0.5;
    const shoulderWidth = Math.max(0.2, opts.shoulderWidth || 2.6);
    const curbHeight = Math.max(0.01, opts.curbHeight || 0.1);
    const roadThickness = Math.max(0.02, opts.roadThickness || 0.7);
    const segCount = samples.length - 1;
    const closedTheme = !!opts.closed;
    const curbWidth = clamp(0.22 + shoulderWidth * 0.2, 0.18, 0.95);

    const dists = [0];
    for (let i = 1; i < samples.length; i++) dists.push(dists[i - 1] + len(sub(samples[i].pos, samples[i - 1].pos)));

    const shoulders = makeMesh('theme_grass_shoulders');
    const curbs = makeMesh('theme_curbs');
    const shoulderBandTs = [0.00, 0.22, 0.48, 0.74, 1.00];
    const shoulderBandCount = shoulderBandTs.length;
    const shoulderStride = shoulderBandCount * 2;
    const nearestRoadFrame = (p) => {
      let best = 0;
      let bestD = 1e18;
      for (let i = 0; i < samples.length; i++) {
        const q = samples[i].pos;
        const d = (p.x - q.x) * (p.x - q.x) + (p.z - q.z) * (p.z - q.z);
        if (d < bestD) { bestD = d; best = i; }
      }
      return { i: best, s: samples[best], f: frames[best] };
    };
    const flipFace = (f) => {
      const nb = f.c, nbu = f.cu;
      f.c = f.b; f.cu = f.bu;
      f.b = nb;  f.bu = nbu;
    };
    const enforceCurbOutwardNormals = () => {
      const hTol = Math.max(0.006, curbHeight * 0.18);
      const baseYBias = 0.0015 + hTol;
      for (const face of curbs.faces) {
        const a = curbs.verts[face.a - 1], b = curbs.verts[face.b - 1], c = curbs.verts[face.c - 1];
        if (!a || !b || !c) continue;
        const ctr = v3((a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3, (a.z + b.z + c.z) / 3);
        const n = norm(cross(sub(b, a), sub(c, a)));
        const rf = nearestRoadFrame(ctr);
        const p = rf.s.pos;
        const R = rf.f.R;
        const topY = p.y + curbHeight * 0.35;
        const bottomY = p.y + baseYBias;
        const isTop = ctr.y >= topY;
        const isBottom = ctr.y <= bottomY;
        let shouldFlip = false;
        if (isTop) {
          shouldFlip = n.y < 0;
        } else if (isBottom) {
          shouldFlip = n.y > 0;
        } else {
          const lateral = dot(sub(ctr, p), R);
          const outSign = lateral >= 0 ? 1 : -1;
          const nSign = dot(n, R) >= 0 ? 1 : -1;
          shouldFlip = nSign !== outSign;
        }
        if (shouldFlip) flipFace(face);
      }
    };
    const nS = samples.length;
    const bridgeSupp = new Float32Array(nS);
    const minSep = Math.max(14, Math.floor(nS * 0.08));
    const hitDist = Math.max(1.8, roadWidth * 0.95 + shoulderWidth * 0.45);
    const bridgeGap = Math.max(1.05, roadThickness + 0.55);
    const suppWin = Math.max(2, Math.round(nS * 0.012));
    for (let i = 0; i < nS; i += 2) {
      const pi = samples[i].pos;
      for (let j = i + minSep; j < nS; j += 2) {
        const pj = samples[j].pos;
        const d = Math.hypot(pi.x - pj.x, pi.z - pj.z);
        if (d > hitDist) continue;
        const dy = pi.y - pj.y;
        if (Math.abs(dy) < bridgeGap) continue;
        const upper = dy > 0 ? i : j;
        const boost = clamp(1 - d / Math.max(1e-6, hitDist), 0, 1);
        for (let k = -suppWin; k <= suppWin; k++) {
          const idx = upper + k;
          if (idx < 0 || idx >= nS) continue;
          const w = boost * (1 - Math.abs(k) / (suppWin + 1));
          if (w > bridgeSupp[idx]) bridgeSupp[idx] = w;
        }
      }
    }
    const shoulderWBy = new Float32Array(nS);
    const curbWBy = new Float32Array(nS);
    const curbHBy = new Float32Array(nS);

    for (let i = 0; i < samples.length; i++) {
      const P = samples[i].pos;
      const R = frames[i].R;
      const u = ((dists[i] / 7) % 1 + 1) % 1;
      const wig = (Math.sin(i * 0.41) + Math.cos(i * 0.29)) * 0.025;
      const supp = clamp(bridgeSupp[i], 0, 1);
      const shoulderW = shoulderWidth * (1 - supp);
      const curbW = curbWidth * (1 - supp * 0.97);
      const curbH = curbHeight * (1 - supp * 0.95);
      shoulderWBy[i] = shoulderW;
      curbWBy[i] = curbW;
      curbHBy[i] = curbH;
      const shoulderDropInner = 0.09;
      const shoulderDropOuter = 0.36 + shoulderWidth * 0.04;
      for (let bi = 0; bi < shoulderBandCount; bi++) {
        const t = shoulderBandTs[bi];
        const round = (1 - Math.cos(t * Math.PI * 0.96)) * 0.5;
        const drop = shoulderDropInner + (shoulderDropOuter - shoulderDropInner) * round;
        const wigScale = (1 - t) * 0.9 + 0.1;
        const yOff = -drop + wig * wigScale;
        const d = half + curbW + shoulderW * t;
        shoulders.verts.push(add(add(P, mul(R, d)), v3(0, yOff, 0)));
        shoulders.uvs.push({ u, v: t });
      }
      for (let bi = 0; bi < shoulderBandCount; bi++) {
        const t = shoulderBandTs[bi];
        const round = (1 - Math.cos(t * Math.PI * 0.96)) * 0.5;
        const drop = shoulderDropInner + (shoulderDropOuter - shoulderDropInner) * round;
        const wigScale = (1 - t) * 0.9 + 0.1;
        const yOff = -drop + wig * wigScale;
        const d = half + curbW + shoulderW * t;
        shoulders.verts.push(add(add(P, mul(R, -d)), v3(0, yOff, 0)));
        shoulders.uvs.push({ u, v: t });
      }

      const clI = add(P, mul(R, half + 0.03));
      const clO = add(P, mul(R, half + curbW));
      const crI = add(P, mul(R, -half - 0.03));
      const crO = add(P, mul(R, -half - curbW));
      const topLift = v3(0, curbH, 0);
      const baseLift = v3(0, 0.0015, 0);
      // 8 verts/sample for solid curb ribbons:
      // L inner top, L outer top, R inner top, R outer top, L inner base, L outer base, R inner base, R outer base
      curbs.verts.push(add(clI, topLift));  curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(clO, topLift));  curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(crI, topLift));  curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(crO, topLift));  curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(clI, baseLift)); curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(clO, baseLift)); curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(crI, baseLift)); curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(crO, baseLift)); curbs.uvs.push({ u, v: 1 });
    }

    for (let i = 0; i < segCount; i++) {
      const segSupp = Math.max(bridgeSupp[i], bridgeSupp[i + 1]);
      if (segSupp > 0.96) continue;
      const s0 = i * shoulderStride + 1;
      const s1 = (i + 1) * shoulderStride + 1;
      for (let band = 0; band < shoulderBandCount - 1; band++) {
        const a0 = s0 + band;
        const b0 = s0 + band + 1;
        const a1 = s1 + band;
        const b1 = s1 + band + 1;
        meshAddTri(shoulders, a0, b0, b1);
        meshAddTri(shoulders, a0, b1, a1);
      }
      for (let band = 0; band < shoulderBandCount - 1; band++) {
        const a0 = s0 + shoulderBandCount + band;
        const b0 = s0 + shoulderBandCount + band + 1;
        const a1 = s1 + shoulderBandCount + band;
        const b1 = s1 + shoulderBandCount + band + 1;
        meshAddTri(shoulders, a0, b1, b0);
        meshAddTri(shoulders, a0, a1, b1);
      }

      const c0 = i * 8 + 1;
      const c1 = (i + 1) * 8 + 1;
      // Left top strip
      meshAddTri(curbs, c0 + 0, c1 + 1, c0 + 1);
      meshAddTri(curbs, c0 + 0, c1 + 0, c1 + 1);
      // Left base strip
      meshAddTri(curbs, c0 + 4, c0 + 5, c1 + 5);
      meshAddTri(curbs, c0 + 4, c1 + 5, c1 + 4);
      // Left inner wall
      meshAddTri(curbs, c0 + 0, c0 + 4, c1 + 4);
      meshAddTri(curbs, c0 + 0, c1 + 4, c1 + 0);
      // Left outer wall
      meshAddTri(curbs, c0 + 1, c1 + 1, c1 + 5);
      meshAddTri(curbs, c0 + 1, c1 + 5, c0 + 5);

      // Right top strip
      meshAddTri(curbs, c0 + 2, c0 + 3, c1 + 3);
      meshAddTri(curbs, c0 + 2, c1 + 3, c1 + 2);
      // Right base strip
      meshAddTri(curbs, c0 + 6, c1 + 7, c0 + 7);
      meshAddTri(curbs, c0 + 6, c1 + 6, c1 + 7);
      // Right inner wall
      meshAddTri(curbs, c0 + 2, c1 + 2, c1 + 6);
      meshAddTri(curbs, c0 + 2, c1 + 6, c0 + 6);
      // Right outer wall
      meshAddTri(curbs, c0 + 3, c0 + 7, c1 + 7);
      meshAddTri(curbs, c0 + 3, c1 + 7, c1 + 3);
    }
    if (!closedTheme && samples.length >= 2) {
      const s0 = 1;
      const sN = (samples.length - 1) * 8 + 1;
      // Start caps
      meshAddTri(curbs, s0 + 0, s0 + 5, s0 + 4);
      meshAddTri(curbs, s0 + 0, s0 + 1, s0 + 5);
      meshAddTri(curbs, s0 + 2, s0 + 6, s0 + 7);
      meshAddTri(curbs, s0 + 2, s0 + 7, s0 + 3);
      // End caps
      meshAddTri(curbs, sN + 0, sN + 4, sN + 5);
      meshAddTri(curbs, sN + 0, sN + 5, sN + 1);
      meshAddTri(curbs, sN + 2, sN + 7, sN + 6);
      meshAddTri(curbs, sN + 2, sN + 3, sN + 7);
    }

    // Fill shoulder/curb around branch junctions so all surfaces meet cleanly.
    if (Array.isArray(branchSections) && branchSections.length) {
      const used = new Set();
      const junctionIdx = [];
      for (const sec of branchSections) {
        for (const i of [sec.a, sec.b]) {
          if (!Number.isInteger(i) || i < 0 || i >= points.length || used.has(i)) continue;
          used.add(i);
          junctionIdx.push(i);
        }
      }
      const steps = 20;
      const addStrip = (mesh, inner, outer, flip = false) => {
        const n = Math.min(inner.length, outer.length);
        if (n < 3) return;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          const a0 = inner[i], a1 = inner[j];
          const b0 = outer[i], b1 = outer[j];
          if (!flip) {
            meshAddTri(mesh, a0, b0, b1);
            meshAddTri(mesh, a0, b1, a1);
          } else {
            meshAddTri(mesh, a0, b1, b0);
            meshAddTri(mesh, a0, a1, b1);
          }
        }
      };
      for (const idx of junctionIdx) {
        if (bridgeSupp[idx] > 0.90) continue;
        const p = points[idx]?.pos;
        if (!p) continue;
        let t = tangentAtIndex(idx);
        t = norm(v3(t.x, 0, t.z));
        if (Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
        const r = norm(v3(-t.z, 0, t.x));

        const curbInnerR = half + 0.03;
        const curbOuterR = half + curbWBy[idx];
        const curbInnerTop = [];
        const curbOuterTop = [];
        const curbInnerBase = [];
        const curbOuterBase = [];
        const curbLift = curbHBy[idx];
        for (let k = 0; k < steps; k++) {
          const a = (k / steps) * Math.PI * 2;
          const ca = Math.cos(a), sa = Math.sin(a);
          const inOff = add(mul(r, ca * curbInnerR), mul(t, sa * curbInnerR));
          const outOff = add(mul(r, ca * curbOuterR), mul(t, sa * curbOuterR));
          curbInnerTop.push(meshAddVertex(curbs, v3(p.x + inOff.x, p.y + curbLift, p.z + inOff.z), k / steps, 0));
          curbOuterTop.push(meshAddVertex(curbs, v3(p.x + outOff.x, p.y + curbLift, p.z + outOff.z), k / steps, 1));
          curbInnerBase.push(meshAddVertex(curbs, v3(p.x + inOff.x, p.y + 0.0015, p.z + inOff.z), k / steps, 0));
          curbOuterBase.push(meshAddVertex(curbs, v3(p.x + outOff.x, p.y + 0.0015, p.z + outOff.z), k / steps, 1));
        }
        addStrip(curbs, curbInnerTop, curbOuterTop, false);
        addStrip(curbs, curbInnerBase, curbOuterBase, true);
        addStrip(curbs, curbInnerTop, curbInnerBase, false);
        addStrip(curbs, curbOuterTop, curbOuterBase, true);

        const grassTs = [0.00, 0.50, 1.00];
        const grassRings = [];
        for (let gi = 0; gi < grassTs.length; gi++) {
          const tt = grassTs[gi];
          const rr = half + curbWBy[idx] + shoulderWBy[idx] * tt;
          const round = (1 - Math.cos(tt * Math.PI * 0.96)) * 0.5;
          const drop = 0.09 + (0.36 + shoulderWidth * 0.04 - 0.09) * round;
          const y = p.y - drop;
          const ring = [];
          for (let k = 0; k < steps; k++) {
            const a = (k / steps) * Math.PI * 2;
            const ca = Math.cos(a), sa = Math.sin(a);
            const off = add(mul(r, ca * rr), mul(t, sa * rr));
            ring.push(meshAddVertex(shoulders, v3(p.x + off.x, y, p.z + off.z), k / steps, tt));
          }
          grassRings.push(ring);
        }
        addStrip(shoulders, grassRings[0], grassRings[1], false);
        addStrip(shoulders, grassRings[1], grassRings[2], false);
      }
    }

    enforceCurbOutwardNormals();
    if (shoulders.faces.length) out.push({ mesh: shoulders, kind: 'grass' });
    if (curbs.faces.length) out.push({ mesh: curbs, kind: 'curb' });
    return out;
  }

  function meshAddSphere(mesh, center, radius, rings = 6, segs = 10) {
    const ring = [];
    for (let iy = 0; iy <= rings; iy++) {
      const v = iy / rings;
      const th = v * Math.PI;
      const y = Math.cos(th) * radius;
      const rr = Math.sin(th) * radius;
      const row = [];
      for (let ix = 0; ix <= segs; ix++) {
        const u = ix / segs;
        const ph = u * Math.PI * 2;
        const p = v3(center.x + Math.cos(ph) * rr, center.y + y, center.z + Math.sin(ph) * rr);
        row.push(meshAddVertex(mesh, p, u, v));
      }
      ring.push(row);
    }
    for (let iy = 0; iy < rings; iy++) {
      for (let ix = 0; ix < segs; ix++) {
        const a = ring[iy][ix];
        const b = ring[iy][ix + 1];
        const c = ring[iy + 1][ix + 1];
        const d = ring[iy + 1][ix];
        meshAddTri(mesh, a, b, c);
        meshAddTri(mesh, a, c, d);
      }
    }
  }

  function buildPlacedPropMeshes(opts, placements) {
    if (!opts?.enabled) return [];
    const out = [];
    const fences = placements?.fences || [];
    const trees = placements?.trees || [];
    const fenceScale = clamp(opts.fenceScale ?? 0.55, 0, 1);
    const treeScale = clamp(opts.treeScale ?? 0.60, 0, 1);

    if (fences.length) {
      const fence = makeMesh('placed_fences');
      const railH = 0.95 + fenceScale * 1.0;
      const spacing = 1.7;
      for (const seg of fences) {
        const a = seg.a, b = seg.b;
        const ab = sub(b, a);
        const L = len(ab);
        if (L < 0.6) continue;
        const dir = norm(ab);
        let side = cross(v3(0, 1, 0), dir);
        if (len(side) < 1e-6) side = v3(1, 0, 0); else side = norm(side);
        const posts = Math.max(2, Math.floor(L / spacing) + 1);
        const anchors = [];
        for (let i = 0; i < posts; i++) {
          const t = i / (posts - 1);
          const p = add(a, mul(ab, t));
          const postH = railH + 0.08 * Math.sin(i * 0.7);
          const c = v3(p.x, p.y + postH * 0.5, p.z);
          meshAddOrientedBox(fence, c, v3(1, 0, 0), v3(0, 1, 0), v3(0, 0, 1), 0.06, postH * 0.5, 0.06);
          anchors.push(v3(p.x, p.y + railH * 0.86, p.z));
        }
        for (let i = 0; i < anchors.length - 1; i++) {
          const p0 = anchors[i], p1 = anchors[i + 1];
          const vv = sub(p1, p0);
          const ll = len(vv);
          if (ll < 0.1) continue;
          const axis = norm(vv);
          const mid = mul(add(p0, p1), 0.5);
          meshAddOrientedBox(fence, mid, axis, v3(0, 1, 0), side, ll * 0.5, 0.035, 0.035);
          meshAddOrientedBox(fence, add(mid, v3(0, -0.26, 0)), axis, v3(0, 1, 0), side, ll * 0.5, 0.028, 0.03);
        }
      }
      if (fence.faces.length) out.push({ mesh: fence, kind: 'fence' });
    }

    if (trees.length) {
      const trunks = makeMesh('placed_tree_trunks');
      const leaves = makeMesh('placed_tree_leaves');
      for (const tr of trees) {
        const p = tr.pos;
        const s = (tr.scale || 1) * (0.75 + treeScale * 1.05);
        const trunkH = 0.9 * s;
        const trunkR = 0.11 * s;
        meshAddOrientedBox(trunks, v3(p.x, p.y + trunkH * 0.5, p.z), v3(1, 0, 0), v3(0, 1, 0), v3(0, 0, 1), trunkR, trunkH * 0.5, trunkR);
        meshAddSphere(leaves, v3(p.x, p.y + trunkH + 0.38 * s, p.z), 0.55 * s, 5, 9);
        meshAddSphere(leaves, v3(p.x + 0.16 * s, p.y + trunkH + 0.86 * s, p.z - 0.08 * s), 0.40 * s, 5, 8);
      }
      if (trunks.faces.length) out.push({ mesh: trunks, kind: 'treeTrunk' });
      if (leaves.faces.length) out.push({ mesh: leaves, kind: 'treeLeaf' });
    }
    return out;
  }

  function meshesToOBJ(meshes) {
    let out = '# Track Generator OBJ (Y up)\n';
    let vOff = 0, vtOff = 0;
    for (const m of meshes) {
      out += `\no ${m.name}\n`;
      for (const v of m.verts) out += `v ${v.x.toFixed(6)} ${v.y.toFixed(6)} ${v.z.toFixed(6)}\n`;
      for (const uv of m.uvs) out += `vt ${uv.u.toFixed(6)} ${uv.v.toFixed(6)}\n`;
      for (const f of m.faces) {
        const a = f.a + vOff, b = f.b + vOff, c = f.c + vOff;
        const au = (f.au ?? f.a) + vtOff, bu = (f.bu ?? f.b) + vtOff, cu = (f.cu ?? f.c) + vtOff;
        out += `f ${a}/${au} ${b}/${bu} ${c}/${cu}\n`;
      }
      vOff += m.verts.length;
      vtOff += m.uvs.length;
    }
    return out;
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.rel = 'noopener';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ---------- DOM ----------
  const $ = (id) => document.getElementById(id);
  const num = (id) => Number($(id).value);
  const chk = (id) => $(id).checked;
  const txt = (id) => $(id).value;

  const editWrap = $('editWrap');
  const editCard = $('editCard');
  const edit = $('edit');
  const ectx = edit.getContext('2d');
  const ctrlCard = $('ctrlCard');
  const ctrlToggleBtn = $('ctrlToggle');
  const genQuickBtn = $('genQuickBtn');
  const saveBtn = $('saveBtn');
  const loadBtn = $('loadBtn');
  const loadProjectFile = $('loadProjectFile');
  const toggleHintsBtn = $('toggleHintsBtn');
  const helpModal = $('helpModal');
  const helpCloseBtn = $('helpCloseBtn');
  const helpCloseBtn2 = $('helpCloseBtn2');
  const helpInlineToggleBtn = $('helpInlineToggle');
  const viewWrap = $('viewWrap');
  const viewCard = $('viewCard');
  const splitter = $('splitter');
  const view = $('view');
  const vctx = view.getContext('2d');
  const wrapEl = document.querySelector('.wrap');
  if (!ectx || !vctx) throw new Error('Canvas context failed');

  // keyboard state
  const keysDown = new Set();
  window.addEventListener('keydown', (e) => { keysDown.add(e.code); });
  window.addEventListener('keyup', (e) => { keysDown.delete(e.code); });
  const isSpace = () => keysDown.has('Space');

  // state
  let mode = 'draw';
  let points = [
    { pos: v3(-6, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(-2, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(4, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(7, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(4, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(-2, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
  ];
  let selected = -1;
  let selectedBranch = null; // { sec:number, mid:number }
  let selectedBranchSet = new Set(); // key: "sec:mid"
  let selectedSet = new Set();
  let dragIndex = null;
  let dragBranch = null; // { sec:number, mid:number }
  let dragBranchGroupOffsets = null; // [{sec,mid,dx,dz}]
  let dragGroupOffsets = null;
  let dragHandle = null; // {i, which:'in'|'out', len:number}
  let pan2 = { x: 0, y: 0 };
  let isPanning2 = false;
  let last2 = null;
  let cached = null;
  let joinTool = { phase: 0, startIdx: -1 };
  let ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
  let splitEnds = [];
  let branchSections = []; // { a:number, b:number, kind:'join'|'fork', bend:number, lift:number, mids:[{u,x,y,z}] }
  let roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
  let placedTrees = [];   // { pos:v3, scale:number }
  let placedFences = [];  // { a:v3, b:v3 }
  let fencePlaceStart = null;

  // 3D camera (free look + orbit selected)
  const CAM_SPEED_DEFAULT = 22;
  const camBaseSpeedFromRadius = (r) => clamp(Number(r || 0) * 2.2, 18, 120);
  let camEye = v3(24, 12, -24);
  let camYaw = 0.75, camPitch = 0.35;
  let camSpeedBase = CAM_SPEED_DEFAULT;
  let camMoveSpeed = CAM_SPEED_DEFAULT;
  let isLookR = false, isLookL = false, isPan3 = false, isOrbitSel = false;
  let last3 = null;
  let lmbMoved = false, mmbMoved = false;
  let pickOnRelease = -1;

  // gizmo
  let gizmo = { active: false, axis: null, startMouse: null, startPos: null, depth: 1 };
  let gizmoHoverAxis = null;
  let gizmoGhost = null; // {pos, axis}
  let bezier3DHover = null; // {kind:'main'|'branch', i?|sec?|mid?, which:'in'|'out'}
  let bezier3DDrag = null;  // {target, which, depth, startMouse, startHX, startHZ}
  let viewMode = 'normal'; // render | normal | wireframe
  const PROJECT_STORAGE_KEY = 'mk_track_project_v1';
  let autoSaveTimer = null;

  // ---------- undo / redo ----------
  const undoStack = [];
  const redoStack = [];
  function deepClonePoints(ps) {
    return ps.map(p => ({
      pos: v3(p.pos.x, p.pos.y, p.pos.z),
      bank: Number(p.bank || 0),
      node: p.node || 'smooth',
      hin: { x: Number(p.hin?.x || 0), z: Number(p.hin?.z || 0) },
      hout: { x: Number(p.hout?.x || 0), z: Number(p.hout?.z || 0) },
    }));
  }
  function cloneTrees(ts) {
    return (ts || []).map(t => ({ pos: v3(t.pos.x, t.pos.y, t.pos.z), scale: Number(t.scale || 1) }));
  }
  function cloneFences(fs) {
    return (fs || []).map(f => ({ a: v3(f.a.x, f.a.y, f.a.z), b: v3(f.b.x, f.b.y, f.b.z) }));
  }
  function snapshot() {
    return {
      points: deepClonePoints(points),
      placedTrees: cloneTrees(placedTrees),
      placedFences: cloneFences(placedFences),
      fencePlaceStart: fencePlaceStart ? v3(fencePlaceStart.x, fencePlaceStart.y, fencePlaceStart.z) : null,
      selected,
      selectedIndices: Array.from(selectedSet),
      selectedBranchIndices: Array.from(selectedBranchSet),
      splitEnds: Array.from(splitEnds),
      branchSections: branchSections.map((s) => ({
        a: s.a,
        b: s.b,
        kind: s.kind || 'join',
        bend: Number(s.bend || 0),
        lift: Number(s.lift || 0),
        mids: Array.isArray(s.mids) ? s.mids.map((m) => ({
          u: Number(m.u || 0),
          x: Number(m.x || 0),
          y: Number(m.y || 0),
          z: Number(m.z || 0),
          bevel: Number(m.bevel ?? 0.55),
          node: m.node || 'smooth',
          hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
          hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
        })) : [],
      })),
      pan2: { x: pan2.x, y: pan2.y },
      cam: { camEye: v3(camEye.x, camEye.y, camEye.z), camYaw, camPitch, camMoveSpeed },
    };
  }
  function restoreSnap(s) {
    points = deepClonePoints(s.points || []);
    placedTrees = cloneTrees(s.placedTrees || []);
    placedFences = cloneFences(s.placedFences || []);
    fencePlaceStart = s.fencePlaceStart ? v3(s.fencePlaceStart.x, s.fencePlaceStart.y, s.fencePlaceStart.z) : null;
    selected = typeof s.selected === 'number' ? s.selected : -1;
    selectedSet = new Set((s.selectedIndices || []).filter((i) => Number.isInteger(i) && i >= 0 && i < points.length));
    if (selected >= 0) selectedSet.add(selected);
    selectedBranchSet = new Set((s.selectedBranchIndices || []).filter((k) => typeof k === 'string'));
    selectedBranch = null;
    splitEnds = Array.from(new Set((s.splitEnds || []).filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
    branchSections = Array.isArray(s.branchSections) ? s.branchSections.map((x) => ({
      a: Number(x.a),
      b: Number(x.b),
      kind: x.kind === 'fork' ? 'fork' : 'join',
      bend: Number(x.bend || 0),
      lift: Number(x.lift || 0),
      mids: Array.isArray(x.mids) ? x.mids.map((m) => ({
        u: Number(m.u || 0),
        x: Number(m.x || 0),
        y: Number(m.y || 0),
        z: Number(m.z || 0),
        bevel: Number(m.bevel ?? 0.55),
        node: m.node || 'smooth',
        hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
        hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
      })) : [],
    })) : [];
    pan2 = { x: Number(s.pan2?.x || 0), y: Number(s.pan2?.y || 0) };
    if (s.cam) {
      // Back-compat: camTarget/camDist snapshots from earlier builds.
      if (s.cam.camEye) camEye = v3(s.cam.camEye?.x || 0, s.cam.camEye?.y || 0, s.cam.camEye?.z || 0);
      else {
        const ct = v3(s.cam.camTarget?.x || 0, s.cam.camTarget?.y || 0, s.cam.camTarget?.z || 0);
        const cy = Math.cos(Number(s.cam.camYaw ?? camYaw)), sy = Math.sin(Number(s.cam.camYaw ?? camYaw));
        const cp = Math.cos(Number(s.cam.camPitch ?? camPitch)), sp = Math.sin(Number(s.cam.camPitch ?? camPitch));
        const dist = Number(s.cam.camDist ?? 28);
        const dir = v3(cy * cp, sp, -sy * cp);
        camEye = add(ct, mul(dir, dist));
      }
      camYaw = Number(s.cam.camYaw ?? camYaw);
      camPitch = Number(s.cam.camPitch ?? camPitch);
      camMoveSpeed = Number(s.cam.camMoveSpeed ?? camMoveSpeed);
    }
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    sanitizeBranchSections();
    selectedBranch = null;
    if (mode !== 'fenceplace') fencePlaceStart = null;
    gizmo.active = false;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    cached = null;
  }
  function pushUndo() {
    undoStack.push(snapshot());
    if (undoStack.length > 160) undoStack.shift();
    redoStack.length = 0;
  }
  function undo() {
    if (!undoStack.length) return;
    redoStack.push(snapshot());
    restoreSnap(undoStack.pop());
  }
  function redo() {
    if (!redoStack.length) return;
    undoStack.push(snapshot());
    restoreSnap(redoStack.pop());
  }

  function isTypingTarget(el) {
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
  }

  window.addEventListener('keydown', (e) => {
    // node type hotkeys (when not typing)
    if (!isTypingTarget(document.activeElement) && selected >= 0) {
      if (e.key === '1') { e.preventDefault(); setSelectedNode('smooth'); }
      if (e.key === '2') { e.preventDefault(); setSelectedNode('aligned'); }
      if (e.key === '3') { e.preventDefault(); setSelectedNode('corner'); }
    }

    // Reforger-like camera discrete rotate
    if (!isTypingTarget(document.activeElement)) {
      const step = 7.5 * Math.PI / 180;
      if (e.code === 'Numpad8') { e.preventDefault(); camPitch = clamp(camPitch + step, -1.48, 1.48); }
      if (e.code === 'Numpad2') { e.preventDefault(); camPitch = clamp(camPitch - step, -1.48, 1.48); }
      if (e.code === 'Numpad4') { e.preventDefault(); camYaw += step; }
      if (e.code === 'Numpad6') { e.preventDefault(); camYaw -= step; }
      if (e.key.toLowerCase() === 'f') { e.preventDefault(); frame3D(); }
      if (e.key === 'Escape' && mode === 'fenceplace') { fencePlaceStart = null; }
    }

    // Undo/redo
    if ((e.ctrlKey || e.metaKey) && !isTypingTarget(document.activeElement)) {
      const k = e.key.toLowerCase();
      if (k === 'z') {
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
        return;
      }
      if (k === 'y') {
        e.preventDefault();
        redo();
        return;
      }
    }

    // Delete selected point(s)
    if ((e.key === 'Delete' || e.key === 'Backspace') && !isTypingTarget(document.activeElement)) {
      sanitizeBranchSelection();
      if (selectedBranchSet.size || selectedBranch) {
        e.preventDefault();
        pushUndo();
        const all = selectedBranchSet.size ? Array.from(selectedBranchSet) : [branchSelKey(selectedBranch.sec, selectedBranch.mid)];
        const pairs = all.map(parseBranchSelKey).filter(Boolean)
          .sort((a, b) => (b.sec - a.sec) || (b.mid - a.mid));
        for (const p of pairs) {
          const mids = branchSections[p.sec]?.mids;
          if (!Array.isArray(mids) || !mids[p.mid]) continue;
          mids.splice(p.mid, 1);
        }
        sanitizeBranchSections();
        selectedBranch = null;
        selectedBranchSet.clear();
        syncSelectedUI();
        cached = null;
        return;
      }
      if (selectedSet.size > 0 || selected >= 0) {
        e.preventDefault();
        pushUndo();
        const del = selectedSet.size ? new Set(selectedSet) : new Set(selected >= 0 ? [selected] : []);
        const idxs = Array.from(del).sort((a, b) => b - a);
        for (const idx of idxs) {
          if (idx < 0 || idx >= points.length) continue;
          points.splice(idx, 1);
          remapSplitEndsForSplice(idx, 1, 0);
        }
        selected = -1;
        selectedSet.clear();
        syncSelectedUI();
        cached = null;
      }
    }
  });

  // ---------- selection / picking ----------
  function origin2() {
    const r = editWrap.getBoundingClientRect();
    return { x: r.width / 2 + pan2.x, y: r.height / 2 + pan2.y };
  }
  function screenFromWorld2(p, org, s) {
    const iso = isoProject(p, s);
    return { x: org.x + iso.x, y: org.y + iso.y };
  }

  function nearestPointScreen(sx, sy, org, s, maxPix) {
    let best = -1;
    let bd = maxPix;
    for (let i = 0; i < points.length; i++) {
      const sp = screenFromWorld2(points[i].pos, org, s);
      const d = Math.hypot(sp.x - sx, sp.y - sy);
      if (d < bd) { bd = d; best = i; }
    }
    return best;
  }

  function closestPointOnScreenSegment(sx, sy, ax, ay, bx, by) {
    const vx = bx - ax;
    const vy = by - ay;
    const len2 = vx * vx + vy * vy;
    if (len2 < 1e-8) return { t: 0, x: ax, y: ay, d: Math.hypot(sx - ax, sy - ay) };
    let t = ((sx - ax) * vx + (sy - ay) * vy) / len2;
    t = clamp(t, 0, 1);
    const x = ax + vx * t;
    const y = ay + vy * t;
    return { t, x, y, d: Math.hypot(sx - x, sy - y) };
  }

  function nearestCurveHitScreen(sx, sy, org, s, maxPix = 12) {
    const n = points.length;
    if (n < 2) return null;
    const closed = chk('closed');
    ensureHandles(points);
    const segs = closed ? n : n - 1;
    const steps = Math.max(10, Math.min(48, Math.round(effectiveSubdiv() * 2)));
    let best = null;

    for (let i = 0; i < segs; i++) {
      const a = points[i];
      const b = points[(i + 1) % n];
      const p0 = a.pos;
      const p1 = b.pos;
      const c0 = add(p0, v3(a.hout.x, 0, a.hout.z));
      const c1 = add(p1, v3(b.hin.x, 0, b.hin.z));
      let prev = bezier(p0, c0, c1, p1, 0);
      let prevSp = screenFromWorld2(prev, org, s);
      for (let k = 1; k <= steps; k++) {
        const t1 = k / steps;
        const cur = bezier(p0, c0, c1, p1, t1);
        const curSp = screenFromWorld2(cur, org, s);
        const hit = closestPointOnScreenSegment(sx, sy, prevSp.x, prevSp.y, curSp.x, curSp.y);
        if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
          const t0 = (k - 1) / steps;
          const t = t0 + (t1 - t0) * hit.t;
          const pos = bezier(p0, c0, c1, p1, t);
          const tan = bezierDeriv(p0, c0, c1, p1, t);
          best = {
            dist: hit.d,
            seg: i,
            t,
            pos,
            tan,
            insertIndex: i + 1,
            bank: (1 - t) * a.bank + t * b.bank,
          };
        }
        prev = cur;
        prevSp = curSp;
      }
    }
    return best;
  }


  function selectOnly(i) {
    selectedBranch = null;
    selectedBranchSet.clear();
    selected = i;
    selectedSet.clear();
    if (i >= 0) selectedSet.add(i);
  }

  function branchSelKey(sec, mid) { return `${sec}:${mid}`; }
  function parseBranchSelKey(k) {
    const m = /^(-?\d+):(-?\d+)$/.exec(String(k || ''));
    if (!m) return null;
    return { sec: Number(m[1]), mid: Number(m[2]) };
  }
  function sanitizeBranchSelection() {
    const next = new Set();
    for (const key of selectedBranchSet) {
      const p = parseBranchSelKey(key);
      if (!p) continue;
      if (p.sec < 0 || p.mid < 0) continue;
      if (!branchSections[p.sec]?.mids?.[p.mid]) continue;
      next.add(branchSelKey(p.sec, p.mid));
    }
    selectedBranchSet = next;
    if (selectedBranch) {
      const key = branchSelKey(selectedBranch.sec, selectedBranch.mid);
      if (!selectedBranchSet.has(key)) {
        if (branchSections[selectedBranch.sec]?.mids?.[selectedBranch.mid]) selectedBranchSet.add(key);
        else selectedBranch = null;
      }
    }
  }

  function selectBranchMidpoint(sec, mid) {
    selected = -1;
    selectedSet.clear();
    selectedBranchSet.clear();
    selectedBranchSet.add(branchSelKey(sec, mid));
    selectedBranch = { sec, mid };
  }

  function toggleBranchSelection(sec, mid) {
    selected = -1;
    selectedSet.clear();
    const key = branchSelKey(sec, mid);
    if (selectedBranchSet.has(key)) selectedBranchSet.delete(key);
    else selectedBranchSet.add(key);
    if (selectedBranchSet.size) {
      const first = parseBranchSelKey(Array.from(selectedBranchSet).sort()[0]);
      selectedBranch = first ? { sec: first.sec, mid: first.mid } : null;
    } else {
      selectedBranch = null;
    }
  }

  function collectActiveBranchSelection(anchor = null) {
    const out = [];
    sanitizeBranchSelection();
    if (selectedBranchSet.size) {
      for (const k of Array.from(selectedBranchSet).sort()) {
        const p = parseBranchSelKey(k);
        if (!p) continue;
        if (branchSections[p.sec]?.mids?.[p.mid]) out.push({ sec: p.sec, mid: p.mid });
      }
    }
    if (!out.length && anchor && branchSections[anchor.sec]?.mids?.[anchor.mid]) out.push(anchor);
    if (!out.length && selectedBranch && branchSections[selectedBranch.sec]?.mids?.[selectedBranch.mid]) out.push({ sec: selectedBranch.sec, mid: selectedBranch.mid });
    return out;
  }

  function toggleSelection(i) {
    if (i < 0) return;
    selectedBranch = null;
    selectedBranchSet.clear();
    if (selectedSet.has(i)) selectedSet.delete(i);
    else selectedSet.add(i);
    selected = selectedSet.size ? Array.from(selectedSet).sort((a, b) => a - b)[0] : -1;
  }

  function collectActiveSelection(anchorIndex = -1) {
    const out = selectedSet.size ? Array.from(selectedSet).sort((a, b) => a - b) : [];
    if (!out.length && anchorIndex >= 0) out.push(anchorIndex);
    if (!out.length && selected >= 0) out.push(selected);
    return out;
  }

  function selYRange() {
    const lo = Number($('selY').min);
    const hi = Number($('selY').max);
    return {
      lo: Number.isFinite(lo) ? lo : -20,
      hi: Number.isFinite(hi) ? hi : 40,
    };
  }

  function applyHeightDeltaToMainSelection(delta) {
    const { lo, hi } = selYRange();
    for (const idx of collectActiveSelection()) {
      const p = points[idx];
      if (!p) continue;
      const y0 = clamp(Number(p.pos.y || 0) + delta, lo, hi);
      p.pos.y = clamp(snapRoadY(y0), lo, hi);
    }
  }

  function applyHeightDeltaToBranchSelection(delta) {
    sanitizeBranchSelection();
    const { lo, hi } = selYRange();
    const active = collectActiveBranchSelection();
    for (const a of active) {
      const m = branchSections[a.sec]?.mids?.[a.mid];
      if (!m) continue;
      const y0 = clamp(Number(m.y || 0) + delta, lo, hi);
      m.y = clamp(snapRoadY(y0), lo, hi);
    }
  }

  function handleWorld(i, which) {
    const p = points[i];
    ensurePointShape(p);
    const h = which === 'in' ? p.hin : p.hout;
    return v3(p.pos.x + (h?.x || 0), p.pos.y, p.pos.z + (h?.z || 0));
  }

  function branchMidRef(sel = selectedBranch) {
    if (!sel) return null;
    const sec = branchSections[sel.sec];
    const mid = sec?.mids?.[sel.mid];
    if (!sec || !mid) return null;
    return { sec, mid };
  }

  function branchHandleWorld(sel, which) {
    const ref = branchMidRef(sel);
    if (!ref) return null;
    const m = ref.mid;
    const h = which === 'in' ? m.hin : m.hout;
    return v3(m.x + (h?.x || 0), m.y, m.z + (h?.z || 0));
  }

  function nearestHandle2D(sx, sy, org, s, maxPix) {
    if (selectedBranch) {
      const hiW = branchHandleWorld(selectedBranch, 'in');
      const hoW = branchHandleWorld(selectedBranch, 'out');
      if (hiW && hoW) {
        const hi = screenFromWorld2(hiW, org, s);
        const ho = screenFromWorld2(hoW, org, s);
        const di = Math.hypot(hi.x - sx, hi.y - sy);
        const doo = Math.hypot(ho.x - sx, ho.y - sy);
        if (di <= maxPix) return { kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'in' };
        if (doo <= maxPix) return { kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'out' };
      }
    }
    if (selected < 0) return null;
    const hi = screenFromWorld2(handleWorld(selected, 'in'), org, s);
    const ho = screenFromWorld2(handleWorld(selected, 'out'), org, s);
    const di = Math.hypot(hi.x - sx, hi.y - sy);
    const doo = Math.hypot(ho.x - sx, ho.y - sy);
    if (di <= maxPix) return { kind: 'main', i: selected, which: 'in' };
    if (doo <= maxPix) return { kind: 'main', i: selected, which: 'out' };
    return null;
  }

  function snapXZ(x, z, g) { return { x: Math.round(x / g) * g, z: Math.round(z / g) * g }; }
  function roadSnapCfg() {
    return {
      enabled: chk('roadIsoSnap'),
      xzStep: Math.max(0.01, Math.abs(num('grid')) || 1),
      yStep: clamp(Math.abs(num('roadSnapY')) || 0.5, 0.05, 10),
    };
  }
  function snapRoadXZ(x, z) {
    const cfg = roadSnapCfg();
    if (!cfg.enabled) return { x, z };
    return snapXZ(x, z, cfg.xzStep);
  }
  function snapRoadY(y) {
    const cfg = roadSnapCfg();
    if (!cfg.enabled) return y;
    const step = Math.max(1e-6, cfg.yStep);
    return Math.round(y / step) * step;
  }
  function snapRoadXYZ(x, y, z) {
    const p = snapRoadXZ(x, z);
    return { x: p.x, y: snapRoadY(y), z: p.z };
  }
  function updateSnapStatus() {
    const el = $('snapStatus');
    if (!el) return;
    const cfg = roadSnapCfg();
    if (!cfg.enabled) {
      el.textContent = 'Snap: Off';
      return;
    }
    el.textContent = `Snap: XZ ${cfg.xzStep.toFixed(2)} • Y ${cfg.yStep.toFixed(2)}`;
  }

  function tangentAtIndex(i) {
    if (points.length < 2) return v3(1, 0, 0);
    const ip = Math.max(0, i - 1), inx = Math.min(points.length - 1, i + 1);
    let t = sub(points[inx].pos, points[ip].pos);
    t.y = 0;
    if (len(t) < 1e-6) t = v3(1, 0, 0);
    return norm(t);
  }

  function smoothPointHandles(i) {
    if (i < 0 || i >= points.length) return;
    const closed = chk('closed');
    const n = points.length;
    const p = points[i];
    ensurePointShape(p);
    p.node = 'smooth';
    const pi = closed ? (i - 1 + n) % n : (i > 0 ? i - 1 : -1);
    const ni = closed ? (i + 1) % n : (i < n - 1 ? i + 1 : -1);
    const prev = pi >= 0 ? points[pi] : null;
    const next = ni >= 0 ? points[ni] : null;
    const inVec = prev ? sub(p.pos, prev.pos) : v3(0, 0, 0);
    const outVec = next ? sub(next.pos, p.pos) : v3(0, 0, 0);

    let t;
    if (prev && next) t = norm(add(norm(inVec), norm(outVec)));
    else if (next) t = norm(outVec);
    else if (prev) t = norm(inVec);
    else t = v3(1, 0, 0);
    if (len(t) < 1e-6) t = v3(1, 0, 0);

    const inLen = prev ? Math.max(0.05, len(inVec) * 0.30) : 0.8;
    const outLen = next ? Math.max(0.05, len(outVec) * 0.30) : 0.8;
    p.hin = { x: -t.x * inLen, z: -t.z * inLen };
    p.hout = { x: t.x * outLen, z: t.z * outLen };
  }

  function smoothNeighborhood(indices) {
    const unique = Array.from(new Set(indices.filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
    for (const i of unique) smoothPointHandles(i);
  }

  function smoothAllPointHandles() {
    for (let i = 0; i < points.length; i++) smoothPointHandles(i);
  }

  function mkCtrlPoint(x, y, z, bank = 0) {
    return { pos: v3(x, y, z), bank, node: 'smooth', hin: { x: 0, z: 0 }, hout: { x: 0, z: 0 } };
  }

  function cloneCtrlPoint(p) {
    ensurePointShape(p);
    return {
      pos: v3(p.pos.x, p.pos.y, p.pos.z),
      bank: Number(p.bank || 0),
      node: p.node || 'smooth',
      hin: { x: Number(p.hin?.x || 0), z: Number(p.hin?.z || 0) },
      hout: { x: Number(p.hout?.x || 0), z: Number(p.hout?.z || 0) },
    };
  }

  function sanitizeSplitEnds() {
    splitEnds = Array.from(new Set(splitEnds.filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
  }

  function sanitizeBranchSections() {
    const seen = new Set();
    const next = [];
    for (const s of branchSections) {
      const a = Number(s?.a);
      const b = Number(s?.b);
      if (!Number.isInteger(a) || !Number.isInteger(b)) continue;
      if (a < 0 || b < 0 || a >= points.length || b >= points.length || a === b) continue;
      const kind = s?.kind === 'fork' ? 'fork' : 'join';
      const lo = Math.min(a, b), hi = Math.max(a, b);
      const key = `${kind}:${lo}:${hi}`;
      if (seen.has(key)) continue;
      seen.add(key);
      next.push({
        a, b, kind,
        bend: Number.isFinite(s?.bend) ? Number(s.bend) : 1,
        lift: Number.isFinite(s?.lift) ? Number(s.lift) : 0.8,
        mids: Array.isArray(s?.mids)
          ? s.mids
            .map((m) => ({
              u: clamp(Number(m?.u || 0), 0.001, 0.999),
              x: Number(m?.x || 0),
              y: Number(m?.y || 0),
              z: Number(m?.z || 0),
              bevel: clamp(Number.isFinite(m?.bevel) ? Number(m.bevel) : 0.55, 0, 1),
              node: (m?.node === 'aligned' || m?.node === 'corner') ? m.node : 'smooth',
              hin: { x: Number(m?.hin?.x || 0), z: Number(m?.hin?.z || 0) },
              hout: { x: Number(m?.hout?.x || 0), z: Number(m?.hout?.z || 0) },
            }))
            .filter((m) => Number.isFinite(m.x) && Number.isFinite(m.y) && Number.isFinite(m.z) && Number.isFinite(m.hin.x) && Number.isFinite(m.hin.z) && Number.isFinite(m.hout.x) && Number.isFinite(m.hout.z))
            .sort((m1, m2) => m1.u - m2.u)
          : [],
      });
    }
    branchSections = next;
  }

  function remapBranchSectionsForSplice(start, deleteCount, insertCount) {
    const delta = insertCount - deleteCount;
    const cutEnd = start + deleteCount;
    const mapIdx = (idx) => {
      if (!Number.isInteger(idx)) return -1;
      if (idx < start) return idx;
      if (idx >= cutEnd) return idx + delta;
      return -1;
    };
    branchSections = branchSections.map((s) => ({
      ...s,
      a: mapIdx(s.a),
      b: mapIdx(s.b),
    }));
    sanitizeBranchSections();
  }

  function remapSplitEndsForSplice(start, deleteCount, insertCount, insertedRel = []) {
    const next = [];
    const delta = insertCount - deleteCount;
    const cutEnd = start + deleteCount;
    for (const idx of splitEnds) {
      if (!Number.isInteger(idx)) continue;
      if (idx < start) next.push(idx);
      else if (idx >= cutEnd) next.push(idx + delta);
    }
    for (const rel of insertedRel) next.push(start + rel);
    splitEnds = next;
    sanitizeSplitEnds();
    remapBranchSectionsForSplice(start, deleteCount, insertCount);
  }

  function addBranchSection(iA, iB, kind = 'join') {
    if (iA === iB) return false;
    if (!Number.isInteger(iA) || !Number.isInteger(iB)) return false;
    if (iA < 0 || iB < 0 || iA >= points.length || iB >= points.length) return false;
    const A = points[iA]?.pos;
    const B = points[iB]?.pos;
    if (!A || !B) return false;
    const d = Math.hypot(B.x - A.x, B.z - A.z);
    const liftBase = Math.max(num('roadThickness') * 1.25, 0.7);
    const sec = {
      a: iA,
      b: iB,
      kind: kind === 'fork' ? 'fork' : 'join',
      bend: iA < iB ? 1 : -1,
      lift: liftBase + Math.min(2.4, d * 0.035),
      mids: [],
    };
    branchSections.push(sec);
    sanitizeBranchSections();
    if (sec.kind === 'fork') {
      splitEnds.push(iA, iB);
      sanitizeSplitEnds();
    } else {
      splitEnds = splitEnds.filter((idx) => idx !== iA && idx !== iB);
      sanitizeSplitEnds();
    }
    return true;
  }

  function splitPointForFork(i) {
    if (!Number.isInteger(i) || i < 0 || i >= points.length) return false;
    const src = points[i];
    if (!src) return false;
    const dupe = cloneCtrlPoint(src);
    const t = tangentAtIndex(i);
    const n = norm(v3(-t.z, 0, t.x));
    const side = (Math.hypot(n.x, n.z) > 1e-5) ? n : v3(1, 0, 0);
    const sep = clamp(num('roadWidth') * 0.55, 0.35, 2.8);
    src.pos.x += side.x * sep * 0.5;
    src.pos.z += side.z * sep * 0.5;
    dupe.pos.x -= side.x * sep * 0.5;
    dupe.pos.z -= side.z * sep * 0.5;
    const srcSnap = snapRoadXYZ(src.pos.x, src.pos.y, src.pos.z);
    src.pos.x = srcSnap.x; src.pos.y = srcSnap.y; src.pos.z = srcSnap.z;
    const dupSnap = snapRoadXYZ(dupe.pos.x, dupe.pos.y, dupe.pos.z);
    dupe.pos.x = dupSnap.x; dupe.pos.y = dupSnap.y; dupe.pos.z = dupSnap.z;
    points.splice(i + 1, 0, dupe);
    remapSplitEndsForSplice(i + 1, 0, 1);
    splitEnds.push(i, i + 1);
    sanitizeSplitEnds();
    smoothNeighborhood([i - 1, i, i + 1, i + 2]);
    selectOnly(i + 1);
    return true;
  }

  function insertYSplitModule(iA, iB) {
    if (iA === iB || points.length < 2) return;
    let a = iA, b = iB;
    if (a > b) { const t = a; a = b; b = t; }
    const S = points[a].pos, J = points[b].pos;
    const d = sub(J, S);
    const flat = v3(d.x, 0, d.z);
    const L = Math.max(0.01, len(flat));
    const t = norm(flat);
    const n = v3(-t.z, 0, t.x);
    const w = Math.max(num('roadWidth') * 2.6, L * 0.22);
    const ySpan = Math.abs(J.y - S.y);

    const p = (u, v) => {
      const px = S.x + t.x * L * u + n.x * w * v;
      const pz = S.z + t.z * L * u + n.z * w * v;
      const py = S.y * (1 - u) + J.y * u + Math.sin(u * Math.PI) * (0.35 + ySpan * 0.15);
      const sp = snapRoadXYZ(px, py, pz);
      return mkCtrlPoint(sp.x, sp.y, sp.z, 0);
    };

    // Fork profile tuned to read as a clear Y split in top view.
    const modulePts = [
      p(0.12, 0.06),
      p(0.28, 0.82),
      p(0.47, 1.30),
      p(0.71, 0.50),
      p(0.73, -0.50),
      p(0.49, -1.30),
      p(0.31, -0.82),
      p(0.14, -0.06),
    ];
    const start = a + 1;
    const delCount = Math.max(0, b - a - 1);
    points.splice(start, delCount, ...modulePts);
    remapSplitEndsForSplice(start, delCount, modulePts.length, [2, 5]);
    selectOnly(a + Math.ceil(modulePts.length / 2));
  }

  function trimSection(iA, iB) {
    if (iA === iB) return false;
    let a = iA, b = iB;
    if (a > b) { const t = a; a = b; b = t; }
    if (b - a <= 1) return false;
    const start = a + 1;
    const delCount = b - a - 1;
    points.splice(start, delCount);
    splitEnds = [a, b];
    remapSplitEndsForSplice(start, delCount, 0);
    selectOnly(a);
    return true;
  }

  function joinSection(iA, iB) {
    const ok = addBranchSection(iA, iB, 'join');
    if (ok) selectOnly(iB);
    return ok;
  }

  function insertRoundaboutAt(startIdx, center, radius, exitAngle, dir) {
    if (startIdx < 0 || !center || radius < 0.5) return;
    const S = points[startIdx].pos;
    const entry = Math.atan2(S.z - center.z, S.x - center.x);
    let delta = exitAngle - entry;
    if (dir > 0) while (delta <= 0) delta += Math.PI * 2;
    else while (delta >= 0) delta -= Math.PI * 2;
    const minSweep = Math.PI * 1.08;
    const maxSweep = Math.PI * 1.88;
    if (Math.abs(delta) < minSweep) delta += dir * (minSweep - Math.abs(delta));
    if (Math.abs(delta) > maxSweep) delta = dir * maxSweep;

    const segs = clamp(Math.round(Math.abs(delta) / (Math.PI / 11)), 8, 26);
    const pts = [];
    for (let i = 1; i <= segs; i++) {
      const a = entry + delta * (i / segs);
      const sp = snapRoadXYZ(center.x + Math.cos(a) * radius, S.y, center.z + Math.sin(a) * radius);
      pts.push(mkCtrlPoint(sp.x, sp.y, sp.z, 0));
    }
    points.splice(startIdx + 1, 0, ...pts);
    remapSplitEndsForSplice(startIdx + 1, 0, pts.length);
    splitEnds = [];
    selectOnly(startIdx + pts.length);
  }

  // ---------- UI / controls ----------
  function setTool(t) {
    mode = t;
    $('toolDraw').classList.toggle('active', t === 'draw');
    $('toolMove').classList.toggle('active', t === 'move');
    $('toolErase').classList.toggle('active', t === 'erase');
    $('toolJoin').classList.toggle('active', t === 'join');
    $('toolYSplit').classList.toggle('active', t === 'ysplit');
    $('toolRound').classList.toggle('active', t === 'roundabout');
    $('toolFencePlace').classList.toggle('active', t === 'fenceplace');
    $('toolTreePlace').classList.toggle('active', t === 'treeplace');
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    dragBranch = null;
    dragBranchGroupOffsets = null;
    if (t !== 'fenceplace') fencePlaceStart = null;
  }
  $('toolDraw').onclick = () => setTool('draw');
  $('toolMove').onclick = () => setTool('move');
  $('toolErase').onclick = () => setTool('erase');
  $('toolJoin').onclick = () => setTool('join');
  $('toolYSplit').onclick = () => setTool('ysplit');
  $('toolRound').onclick = () => setTool('roundabout');
  $('toolFencePlace').onclick = () => setTool('fenceplace');
  $('toolTreePlace').onclick = () => setTool('treeplace');
  $('clearPropsBtn').onclick = () => {
    if (!placedTrees.length && !placedFences.length) return;
    pushUndo();
    placedTrees = [];
    placedFences = [];
    fencePlaceStart = null;
    cached = null;
  };

  function initControlPanelUI() {
    const panel = ctrlCard?.querySelector('.panel');
    if (!panel || panel.dataset.enhanced === '1') return;
    panel.dataset.enhanced = '1';

    const children = Array.from(panel.children);
    const rootHeading = children.find((n) => n.tagName === 'H2');
    const rootTitle = rootHeading ? rootHeading.textContent.trim() : 'Controls';
    let introText = '';
    if (rootHeading) {
      const next = rootHeading.nextElementSibling;
      if (next && next.classList.contains('small')) {
        introText = next.innerHTML;
        next.remove();
      }
      rootHeading.remove();
    }

    const header = document.createElement('div');
    header.className = 'ctrlDockHeader';
    header.innerHTML = `
      <div class="ctrlDockTitle">${rootTitle}</div>
      <div class="ctrlDockActions">
        <button id="ctrlExpandAllBtn" type="button">Expand</button>
        <button id="ctrlCollapseAllBtn" type="button">Collapse</button>
      </div>`;
    panel.prepend(header);

    if (introText) {
      const intro = document.createElement('div');
      intro.className = 'ctrlIntro';
      intro.innerHTML = introText;
      panel.insertBefore(intro, header.nextSibling);
    }

    const sectionsWrap = document.createElement('div');
    sectionsWrap.className = 'ctrlSections';
    panel.appendChild(sectionsWrap);

    const sectionOpen = (name) => /project|generator|selected point/i.test(name);
    let currentBody = null;
    const beginSection = (name) => {
      const details = document.createElement('details');
      details.className = 'uiSection';
      details.open = sectionOpen(name);
      const summary = document.createElement('summary');
      summary.textContent = name;
      currentBody = document.createElement('div');
      currentBody.className = 'uiSectionBody';
      details.appendChild(summary);
      details.appendChild(currentBody);
      sectionsWrap.appendChild(details);
    };

    const movable = Array.from(panel.children).filter((n) => !n.classList?.contains('ctrlDockHeader') && !n.classList?.contains('ctrlIntro') && !n.classList?.contains('ctrlSections'));
    for (const node of movable) {
      if (node.tagName === 'H2') {
        beginSection(node.textContent.trim());
        node.remove();
        continue;
      }
      if (!currentBody) beginSection('Project');
      currentBody.appendChild(node);
    }

    $('ctrlExpandAllBtn')?.addEventListener('click', () => {
      for (const sec of panel.querySelectorAll('details.uiSection')) sec.open = true;
    });
    $('ctrlCollapseAllBtn')?.addEventListener('click', () => {
      for (const sec of panel.querySelectorAll('details.uiSection')) sec.open = false;
    });
  }

  function syncCtrlToggleUI() {
    const collapsed = document.body.classList.contains('ctrl-collapsed');
    if (ctrlToggleBtn) {
      ctrlToggleBtn.textContent = collapsed ? '▶' : '◀';
      ctrlToggleBtn.title = collapsed ? 'Show controls' : 'Hide controls';
    }
  }

  function syncHintsUI() {
    const hidden = document.body.classList.contains('hints-hidden');
    if (toggleHintsBtn) {
      toggleHintsBtn.textContent = '?';
      toggleHintsBtn.title = 'Help and tool guide';
    }
    if (helpInlineToggleBtn) helpInlineToggleBtn.textContent = hidden ? 'Show Inline Helpers' : 'Hide Inline Helpers';
  }

  function openHelpModal() {
    helpModal?.classList.remove('hidden');
  }

  function closeHelpModal() {
    helpModal?.classList.add('hidden');
  }

  ctrlToggleBtn?.addEventListener('click', () => {
    document.body.classList.toggle('ctrl-collapsed');
    syncCtrlToggleUI();
    resizeAll();
  });
  toggleHintsBtn?.addEventListener('click', () => openHelpModal());
  helpCloseBtn?.addEventListener('click', closeHelpModal);
  helpCloseBtn2?.addEventListener('click', closeHelpModal);
  helpInlineToggleBtn?.addEventListener('click', () => {
    document.body.classList.toggle('hints-hidden');
    syncHintsUI();
    resizeAll();
  });
  helpModal?.addEventListener('click', (e) => {
    if (e.target === helpModal) closeHelpModal();
  });
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && helpModal && !helpModal.classList.contains('hidden')) closeHelpModal();
  });
  initControlPanelUI();
  syncCtrlToggleUI();
  syncHintsUI();

  const viewModes = ['render', 'normal', 'wireframe'];
  function modeLabel(m) {
    if (m === 'normal') return 'Normal';
    if (m === 'wireframe') return 'Wireframe';
    return 'Render';
  }
  function syncViewModeUI() {
    $('viewModeBtn').textContent = `Mode: ${modeLabel(viewMode)}`;
  }
  $('viewModeBtn').addEventListener('click', () => {
    const i = viewModes.indexOf(viewMode);
    viewMode = viewModes[(i + 1) % viewModes.length];
    syncViewModeUI();
  });
  syncViewModeUI();

  function collectControlState() {
    const out = {};
    const nodes = ctrlCard?.querySelectorAll('input, select');
    if (!nodes) return out;
    for (const el of nodes) {
      if (!el.id) continue;
      if (el.type === 'checkbox') out[el.id] = !!el.checked;
      else out[el.id] = String(el.value);
    }
    return out;
  }

  function applyControlState(state) {
    if (!state || typeof state !== 'object') return;
    for (const [id, val] of Object.entries(state)) {
      const el = $(id);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = !!val;
      else el.value = String(val);
    }
  }

  function buildProjectState() {
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      mode,
      viewMode,
      ui: {
        hintsHidden: document.body.classList.contains('hints-hidden'),
        ctrlCollapsed: document.body.classList.contains('ctrl-collapsed'),
      },
      controls: collectControlState(),
      scene: snapshot(),
    };
  }

  function sanitizeLoadedProject(raw) {
    if (!raw || typeof raw !== 'object') return null;
    if (!raw.scene || typeof raw.scene !== 'object') return null;
    return raw;
  }

  function applyProjectState(raw, opts = {}) {
    const state = sanitizeLoadedProject(raw);
    if (!state) return false;
    const allowModes = new Set(['draw', 'move', 'erase', 'join', 'ysplit', 'roundabout', 'fenceplace', 'treeplace']);
    applyControlState(state.controls || {});
    const incomingMode = allowModes.has(state.mode) ? state.mode : 'draw';
    setTool(incomingMode);
    restoreSnap(state.scene);
    if (state.ui && typeof state.ui === 'object') {
      document.body.classList.toggle('hints-hidden', !!state.ui.hintsHidden);
      document.body.classList.toggle('ctrl-collapsed', !!state.ui.ctrlCollapsed);
    }
    if (viewModes.includes(state.viewMode)) viewMode = state.viewMode;
    syncViewModeUI();
    syncCtrlToggleUI();
    syncHintsUI();
    updateLabels();
    syncWorkspaceMode();
    resizeAll();
    cached = null;
    frame3D();
    if (!opts.skipPersist) {
      try { localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(state)); } catch {}
    }
    return true;
  }

  function saveProjectToLocal(silent = true) {
    try {
      localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(buildProjectState()));
      return true;
    } catch (e) {
      if (!silent) showErr('Save failed: ' + String(e?.message || e));
      return false;
    }
  }

  function loadProjectFromLocal(silent = true) {
    try {
      const raw = localStorage.getItem(PROJECT_STORAGE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      const ok = applyProjectState(data, { skipPersist: true });
      if (!ok && !silent) showErr('Saved project is invalid.');
      return ok;
    } catch (e) {
      if (!silent) showErr('Load failed: ' + String(e?.message || e));
      return false;
    }
  }

  function scheduleAutoSave(delay = 500) {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => { saveProjectToLocal(true); }, delay);
  }

  saveBtn?.addEventListener('click', () => {
    const state = buildProjectState();
    try { localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(state)); }
    catch (e) { showErr('Local save failed: ' + String(e?.message || e)); }
    const name = (txt('trackName') || 'track').trim().replace(/[^a-z0-9._-]+/gi, '_') || 'track';
    downloadText(name + '.mktrack.json', JSON.stringify(state, null, 2));
  });

  loadBtn?.addEventListener('click', (e) => {
    if (e.shiftKey) {
      loadProjectFromLocal(false);
      return;
    }
    if (loadProjectFile) {
      loadProjectFile.value = '';
      loadProjectFile.click();
    } else {
      loadProjectFromLocal(false);
    }
  });

  loadProjectFile?.addEventListener('change', async (e) => {
    const f = e.target?.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      const data = JSON.parse(text);
      if (!applyProjectState(data)) showErr('Invalid project file.');
    } catch (err) {
      showErr('Could not load project file: ' + String(err?.message || err));
    } finally {
      if (loadProjectFile) loadProjectFile.value = '';
    }
  });

  function syncWorkspaceMode() {
    const m = txt('workspaceMode');
    if (window.innerWidth < 1200) {
      wrapEl.style.gridTemplateColumns = '';
      editCard.classList.remove('hidden');
      viewCard.classList.remove('hidden');
      ctrlCard.classList.remove('hidden');
      splitter.classList.add('hidden');
      resizeAll();
      return;
    }
    if (m === '2d') {
      wrapEl.style.gridTemplateColumns = 'minmax(0,1fr)';
      editCard.classList.remove('hidden');
      viewCard.classList.add('hidden');
      splitter.classList.add('hidden');
      wrapEl.style.setProperty('--split-l', '2.1fr');
      wrapEl.style.setProperty('--split-r', '0fr');
    } else if (m === '3d') {
      wrapEl.style.gridTemplateColumns = 'minmax(0,1fr)';
      editCard.classList.add('hidden');
      viewCard.classList.remove('hidden');
      splitter.classList.add('hidden');
      wrapEl.style.setProperty('--split-l', '0fr');
      wrapEl.style.setProperty('--split-r', '2.1fr');
    } else {
      wrapEl.style.gridTemplateColumns = 'minmax(0,var(--split-l)) 8px minmax(0,var(--split-r))';
      editCard.classList.remove('hidden');
      viewCard.classList.remove('hidden');
      splitter.classList.remove('hidden');
      if (!wrapEl.style.getPropertyValue('--split-l')) {
        wrapEl.style.setProperty('--split-l', '1.05fr');
        wrapEl.style.setProperty('--split-r', '1.05fr');
      }
    }
    resizeAll();
  }
  $('workspaceMode').addEventListener('change', syncWorkspaceMode);

  function resizeAll() {
    const dpr = window.devicePixelRatio || 1;
    const re = editWrap.getBoundingClientRect();
    edit.width = Math.max(2, Math.floor(re.width * dpr));
    edit.height = Math.max(2, Math.floor(re.height * dpr));
    ectx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const rv = viewWrap.getBoundingClientRect();
    view.width = Math.max(2, Math.floor(rv.width * dpr));
    view.height = Math.max(2, Math.floor(rv.height * dpr));
    vctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { syncWorkspaceMode(); resizeAll(); });
  resizeAll();
  syncWorkspaceMode();

  // 2D/3D splitter drag (desktop only)
  let splitDrag = false, splitStartX = 0, splitL = 1.05, splitR = 1.05;
  splitter.addEventListener('mousedown', (e) => {
    if (window.innerWidth < 1200 || txt('workspaceMode') !== 'both') return;
    splitDrag = true;
    splitStartX = e.clientX;
    splitL = parseFloat((wrapEl.style.getPropertyValue('--split-l') || '1.05').replace('fr', '')) || 1.05;
    splitR = parseFloat((wrapEl.style.getPropertyValue('--split-r') || '1.05').replace('fr', '')) || 1.05;
    document.body.style.cursor = 'col-resize';
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e) => {
    if (!splitDrag) return;
    const dx = e.clientX - splitStartX;
    const total = Math.max(100, editWrap.getBoundingClientRect().width + viewWrap.getBoundingClientRect().width);
    const dfr = (dx / total) * (splitL + splitR);
    const nl = clamp(splitL + dfr, 0.45, 2.4);
    const nr = clamp((splitL + splitR) - nl, 0.45, 2.4);
    wrapEl.style.setProperty('--split-l', nl.toFixed(4) + 'fr');
    wrapEl.style.setProperty('--split-r', nr.toFixed(4) + 'fr');
    resizeAll();
  });
  window.addEventListener('mouseup', () => {
    if (!splitDrag) return;
    splitDrag = false;
    document.body.style.cursor = '';
  });

  function setSelectedNode(type) {
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (!ref) return;
      pushUndo();
      ref.mid.node = type;
      $('selNode').value = type;
      cached = null;
      return;
    }
    if (selected < 0) return;
    pushUndo();
    points[selected].node = type;
    $('selNode').value = type;
    cached = null;
  }

  function syncSelectedUI() {
    sanitizeBranchSelection();
    const selCount = selectedSet.size + selectedBranchSet.size;
    if (selectedBranch) $('selLabel').textContent = `b${selectedBranch.sec}.${selectedBranch.mid}`;
    else $('selLabel').textContent = selected >= 0 ? String(selected) : 'none';
    $('selCount').textContent = `(${selCount})`;
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      const m = ref?.mid;
      if (!m) {
        $('selNode').value = 'smooth';
        $('selY').value = '0'; $('selBank').value = '0';
        $('selYVal').textContent = '0.0'; $('selBankVal').textContent = '0.0';
        return;
      }
      $('selBankLabel').textContent = 'Bevel';
      $('selBank').min = '0';
      $('selBank').max = '1';
      $('selBank').step = '0.01';
      $('selNode').value = m.node || 'smooth';
      $('selY').value = String(m.y);
      $('selBank').value = String(clamp(Number(m.bevel ?? 0.55), 0, 1));
      $('selYVal').textContent = Number(m.y || 0).toFixed(1);
      $('selBankVal').textContent = clamp(Number(m.bevel ?? 0.55), 0, 1).toFixed(2);
      return;
    }
    if (selected < 0 || !points[selected]) {
      $('selBankLabel').textContent = 'Bank (deg)';
      $('selBank').min = '-45';
      $('selBank').max = '45';
      $('selBank').step = '0.5';
      $('selNode').value = 'smooth';
      $('selY').value = '0'; $('selBank').value = '0';
      $('selYVal').textContent = '0.0'; $('selBankVal').textContent = '0.0';
      return;
    }
    ensurePointShape(points[selected]);
    const p = points[selected];
    $('selBankLabel').textContent = 'Bank (deg)';
    $('selBank').min = '-45';
    $('selBank').max = '45';
    $('selBank').step = '0.5';
    $('selNode').value = p.node;
    $('selY').value = String(p.pos.y);
    $('selBank').value = String(p.bank);
    $('selYVal').textContent = p.pos.y.toFixed(1);
    $('selBankVal').textContent = p.bank.toFixed(1);
  }

  $('selNode').addEventListener('change', () => {
    if (selected < 0 && !selectedBranch) return;
    setSelectedNode($('selNode').value);
  });

  $('selY').addEventListener('input', () => {
    if (selectedBranchSet.size || selectedBranch) {
      let ref = branchMidRef(selectedBranch);
      if (!ref) {
        const first = collectActiveBranchSelection()[0];
        const m = first ? branchSections[first.sec]?.mids?.[first.mid] : null;
        if (m) ref = { sec: branchSections[first.sec], mid: m };
      }
      if (!ref || !ref.mid) return;
      pushUndo();
      const nextY = Number($('selY').value);
      const delta = nextY - Number(ref.mid.y || 0);
      applyHeightDeltaToBranchSelection(delta);
      syncSelectedUI();
      cached = null;
      return;
    }
    if (selected < 0 && !selectedSet.size) return;
    pushUndo();
    const refIdx = selected >= 0 && selectedSet.has(selected) ? selected : collectActiveSelection()[0];
    const ref = points[refIdx];
    if (!ref) return;
    const nextY = Number($('selY').value);
    const delta = nextY - Number(ref.pos.y || 0);
    applyHeightDeltaToMainSelection(delta);
    syncSelectedUI();
    cached = null;
  });
  $('selBank').addEventListener('input', () => {
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (!ref) return;
      pushUndo();
      ref.mid.bevel = clamp(Number($('selBank').value), 0, 1);
      $('selBankVal').textContent = ref.mid.bevel.toFixed(2);
      cached = null;
      return;
    }
    if (selected < 0) return;
    pushUndo();
    points[selected].bank = Number($('selBank').value);
    $('selBankVal').textContent = points[selected].bank.toFixed(1);
    cached = null;
  });

  function updateLabels() {
    $('isoScaleVal').textContent = String(num('isoScale'));
    $('roadWidthVal').textContent = num('roadWidth').toFixed(2);
    $('roadThicknessVal').textContent = num('roadThickness').toFixed(2);
    $('subdivVal').textContent = String(num('subdiv'));
    $('pathDetailVal').textContent = num('pathDetail').toFixed(2) + 'x';
    $('genRandomnessVal').textContent = num('genRandomness').toFixed(2);
    $('genScaleVal').textContent = num('genScale').toFixed(2) + 'x';
    $('genLengthVal').textContent = num('genLength').toFixed(2) + 'x';
    $('genCurvesVal').textContent = String(Math.round(num('genCurves')));
    $('genPointCapVal').textContent = String(Math.round(num('genPointCap')));
    $('genComboCountVal').textContent = String(Math.round(num('genComboCount')));
    $('genStraightsVal').textContent = num('genStraights').toFixed(2);
    $('genFlowVal').textContent = num('genFlow').toFixed(2);
    $('genRoundExitsVal').textContent = String(Math.round(num('genRoundExits')));
    $('genCrossFreqVal').textContent = String(Math.round(num('genCrossFreq')));
    $('terrainRoughVal').textContent = num('terrainRough').toFixed(1);
    $('terrainCliffVal').textContent = num('terrainCliff').toFixed(1);
    $('terrainClearanceVal').textContent = num('terrainClearance').toFixed(2);
    $('terrainFollowVal').textContent = num('terrainFollow').toFixed(2);
    $('terrainDetailVal').textContent = num('terrainDetail').toFixed(2);
    $('themeGrassVal').textContent = num('themeGrass').toFixed(1);
    $('themeCurbVal').textContent = num('themeCurb').toFixed(2);
    $('themeFenceVal').textContent = num('themeFence').toFixed(2);
    $('themeTreesVal').textContent = num('themeTrees').toFixed(2);
    $('autoBankStrengthVal').textContent = num('autoBankStrength').toFixed(2);
    $('autoBankMaxVal').textContent = String(Math.round(num('autoBankMax')));
    $('autoBankScaleVal').textContent = num('autoBankScale').toFixed(2);
    $('roadSnapYVal').textContent = num('roadSnapY').toFixed(2);
    updateSnapStatus();
    cached = null;
    scheduleAutoSave(450);
  }
  function applyTerrainPreset(kind) {
    if (kind === 'clean') {
      $('terrainRough').value = '1.0';
      $('terrainCliff').value = '3.6';
      $('terrainClearance').value = '0.34';
      $('terrainFollow').value = '0.84';
      $('terrainDetail').value = '0.78';
    } else if (kind === 'cliffs') {
      $('terrainRough').value = '3.3';
      $('terrainCliff').value = '10.8';
      $('terrainClearance').value = '0.44';
      $('terrainFollow').value = '0.82';
      $('terrainDetail').value = '0.58';
    } else if (kind === 'bridge') {
      $('terrainRough').value = '1.6';
      $('terrainCliff').value = '6.6';
      $('terrainClearance').value = '0.58';
      $('terrainFollow').value = '0.90';
      $('terrainDetail').value = '0.68';
    }
    updateLabels();
  }
  function applyDefaultGeneratorSetup() {
    const defaults = {
      workspaceMode: 'both',
      grid: 1.0,
      isoScale: 6.0,
      roadIsoSnap: true,
      roadSnapY: 0.25,
      showGrid: true,
      closed: true,
      includeSides: true,
      genStyle: 'random',
      genComboCount: 2,
      genRandomness: 0.84,
      genScale: 3.15,
      genLength: 2.15,
      genCurves: 9,
      genPointCap: 34,
      genStraights: 0.69,
      genFlow: 0.78,
      genRoundExits: 3,
      genCrossFreq: 2,
      genModY: true,
      genModRound: false,
      genModCross: true,
      roadWidth: 5.25,
      roadThickness: 0.22,
      subdiv: 22,
      pathDetail: 0.62,
      terrainOn: true,
      terrainRough: 2.8,
      terrainCliff: 8.4,
      terrainClearance: 0.82,
      terrainFollow: 0.90,
      terrainDetail: 0.66,
      themeOn: true,
      themeGrass: 0.75,
      themeCurb: 0.08,
      themeFence: 0.55,
      themeTrees: 0.60,
      autoBank: true,
      autoBankStrength: 0.74,
      autoBankMax: 18,
      autoBankScale: 1.65,
    };
    for (const [id, val] of Object.entries(defaults)) {
      const el = $(id);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = Boolean(val);
      else el.value = String(val);
    }
  }
  ['grid','isoScale','roadWidth','roadThickness','subdiv','pathDetail','genRandomness','genScale','genLength','genCurves','genPointCap','genComboCount','genStraights','genFlow','genRoundExits','genCrossFreq','genModY','genModRound','genModCross','terrainOn','terrainRough','terrainCliff','terrainClearance','terrainFollow','terrainDetail','themeOn','themeGrass','themeCurb','themeFence','themeTrees','closed','includeSides','showGrid','roadIsoSnap','roadSnapY','autoBank','autoBankStrength','autoBankMax','autoBankScale'].forEach(id => $(id).addEventListener('input', updateLabels));
  $('genStyle').addEventListener('change', () => {
    if ($('genStyle').value === 'f1long') {
      if (num('genLength') < 1.8) $('genLength').value = '1.80';
      if (num('genScale') < 1.4) $('genScale').value = '1.40';
      if (num('genStraights') < 0.68) $('genStraights').value = '0.68';
      if (num('genFlow') < 0.72) $('genFlow').value = '0.72';
      if (num('genCurves') < 7) $('genCurves').value = '7';
    }
    updateLabels();
  });
  $('terrainPresetClean').addEventListener('click', () => applyTerrainPreset('clean'));
  $('terrainPresetCliffs').addEventListener('click', () => applyTerrainPreset('cliffs'));
  $('terrainPresetBridge').addEventListener('click', () => applyTerrainPreset('bridge'));
  applyDefaultGeneratorSetup();
  updateLabels();
  loadProjectFromLocal(true);
  setInterval(() => saveProjectToLocal(true), 12000);
  window.addEventListener('beforeunload', () => { saveProjectToLocal(true); });

  $('resetBtn').onclick = () => {
    pushUndo();
    points = [
      { pos: v3(-6, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(-2, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(4, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(7, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(4, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(-2, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    ];
    smoothAllPointHandles();
    pan2 = { x: 0, y: 0 };
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    splitEnds = [];
    branchSections = [];
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    placedTrees = [];
    placedFences = [];
    fencePlaceStart = null;
    gizmo.active = false;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    cached = null;
    frame3D();
  };
  $('clearBtn').onclick = () => {
    pushUndo();
    points = [];
    placedTrees = [];
    placedFences = [];
    fencePlaceStart = null;
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    splitEnds = [];
    branchSections = [];
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    gizmo.active = false;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    cached = null;
  };

  function angDelta(a, b) {
    return Math.atan2(Math.sin(a - b), Math.cos(a - b));
  }

  function bridgeProfile(style, t, r, modY = false, modCross = false) {
    const sig = 0.22 + 0.08 * r;
    const g = (c) => {
      const d = angDelta(t, c);
      return Math.exp(-(d * d) / (2 * sig * sig));
    };
    const h = 3.2 + 2.0 * r;
    let y = 0;
    if (modY || style === 'figure8' || style === 'splitS') y += h * (g(0) - g(Math.PI));
    if (style === 'clover') y += (h * 0.55) * (g(Math.PI * 0.5) - g(Math.PI * 1.5));
    if (modCross) y += (h * 0.45) * (g(Math.PI * 0.5) - g(Math.PI * 1.5));
    if (style !== 'figure8') y *= 0.62;
    return y;
  }

  function applyTrackRules(ctrl) {
    const n = ctrl.length;
    if (n < 3) return ctrl;
    const maxBank = 18;
    const maxGrade = 0.11; // dy per horizontal unit

    // clamp + smooth bank so track never tries to roll over
    for (const p of ctrl) p.bank = clamp(p.bank, -maxBank, maxBank);
    for (let pass = 0; pass < 3; pass++) {
      const b = ctrl.map((p, i) => {
        const a = ctrl[(i - 1 + n) % n].bank;
        const c = ctrl[(i + 1) % n].bank;
        return a * 0.2 + p.bank * 0.6 + c * 0.2;
      });
      for (let i = 0; i < n; i++) ctrl[i].bank = clamp(b[i], -maxBank, maxBank);
    }

    // limit grade around the whole loop
    for (let pass = 0; pass < 6; pass++) {
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const a = ctrl[i].pos, b = ctrl[j].pos;
        const d = Math.max(0.01, Math.hypot(b.x - a.x, b.z - a.z));
        const lim = Math.max(0.25, d * maxGrade);
        const dy = b.y - a.y;
        if (dy > lim) b.y = a.y + lim;
        else if (dy < -lim) b.y = a.y - lim;
      }
      for (let i = n - 1; i >= 0; i--) {
        const j = (i - 1 + n) % n;
        const a = ctrl[i].pos, b = ctrl[j].pos;
        const d = Math.max(0.01, Math.hypot(b.x - a.x, b.z - a.z));
        const lim = Math.max(0.25, d * maxGrade);
        const dy = b.y - a.y;
        if (dy > lim) b.y = a.y + lim;
        else if (dy < -lim) b.y = a.y - lim;
      }
    }

    // final Y smoothing for race-course continuity
    for (let pass = 0; pass < 2; pass++) {
      const ys = ctrl.map((p, i) => {
        const yp = ctrl[(i - 1 + n) % n].pos.y;
        const yn = ctrl[(i + 1) % n].pos.y;
        return yp * 0.18 + p.pos.y * 0.64 + yn * 0.18;
      });
      for (let i = 0; i < n; i++) ctrl[i].pos.y = ys[i];
    }
    return ctrl;
  }

  function computeGeneratedBank(ctrl, intensity = 1) {
    const n = ctrl.length;
    if (n < 3) return ctrl;
    const maxBank = 18;
    const turnDeadzoneDeg = 1.2;
    const bankIntoTurnSign = -1; // negative maps bank direction toward inside of turn for this renderer
    for (let i = 0; i < n; i++) {
      const a = ctrl[(i - 1 + n) % n].pos;
      const b = ctrl[i].pos;
      const c = ctrl[(i + 1) % n].pos;
      const turn = signedTurnXZ(a, b, c) * (180 / Math.PI);
      if (Math.abs(turn) < turnDeadzoneDeg) {
        ctrl[i].bank = 0;
        continue;
      }
      // Bank strictly follows turn direction and always leans into the corner.
      ctrl[i].bank = clamp(turn * (1.15 * intensity) * bankIntoTurnSign, -maxBank, maxBank);
    }
    return ctrl;
  }

  function applyBezierHandles(ctrl, smoothness = 1) {
    const n = ctrl.length;
    if (n < 2) return ctrl;
    const s = clamp(smoothness, 0, 1.2);
    for (let i = 0; i < n; i++) {
      const prev = ctrl[(i - 1 + n) % n].pos;
      const curr = ctrl[i].pos;
      const next = ctrl[(i + 1) % n].pos;
      const inVec = sub(curr, prev);
      const outVec = sub(next, curr);
      const inLen = Math.max(0.001, len(inVec));
      const outLen = Math.max(0.001, len(outVec));

      const tangent = norm(add(norm(inVec), norm(outVec)));
      const t = (len(tangent) < 1e-5) ? norm(outVec) : tangent;
      const hIn = inLen * (0.22 + 0.22 * s);
      const hOut = outLen * (0.22 + 0.22 * s);

      ctrl[i].hin = { x: -t.x * hIn, z: -t.z * hIn };
      ctrl[i].hout = { x: t.x * hOut, z: t.z * hOut };
      ctrl[i].node = 'smooth';
    }
    return ctrl;
  }

  function smoothGeneratedLayout(ctrl, passes = 2, xyStrength = 0.34, yStrength = 0.18) {
    const n = ctrl.length;
    if (n < 4) return ctrl;
    for (let pass = 0; pass < passes; pass++) {
      const nx = new Array(n);
      const nz = new Array(n);
      const ny = new Array(n);
      for (let i = 0; i < n; i++) {
        const p = ctrl[(i - 1 + n) % n].pos;
        const c = ctrl[i].pos;
        const q = ctrl[(i + 1) % n].pos;
        const ax = (p.x + q.x) * 0.5;
        const az = (p.z + q.z) * 0.5;
        const ay = (p.y + q.y) * 0.5;
        nx[i] = c.x * (1 - xyStrength) + ax * xyStrength;
        nz[i] = c.z * (1 - xyStrength) + az * xyStrength;
        ny[i] = c.y * (1 - yStrength) + ay * yStrength;
      }
      for (let i = 0; i < n; i++) {
        ctrl[i].pos.x = nx[i];
        ctrl[i].pos.z = nz[i];
        ctrl[i].pos.y = ny[i];
      }
    }
    return ctrl;
  }


  function relaxSelfCollisions(ctrl, opts = {}) {
    const n = ctrl.length;
    if (n < 8) return ctrl;
    const minSep = Math.max(2, opts.minNeighborGap || 3);
    const targetDist = Math.max(2.2, opts.targetDist || 7.8);
    const passes = Math.max(1, Math.min(8, opts.passes || 4));
    for (let pass = 0; pass < passes; pass++) {
      for (let i = 0; i < n; i++) {
        for (let j = i + minSep; j < n; j++) {
          if (Math.abs(i - j) > n - minSep) continue;
          const a = ctrl[i].pos;
          const b = ctrl[j].pos;
          const dx = b.x - a.x;
          const dz = b.z - a.z;
          const d = Math.hypot(dx, dz);
          if (d < 1e-5 || d >= targetDist) continue;
          const push = (targetDist - d) * 0.15;
          const nx = dx / d;
          const nz = dz / d;
          a.x -= nx * push;
          a.z -= nz * push;
          b.x += nx * push;
          b.z += nz * push;
        }
      }
    }
    return ctrl;
  }

  function enforceCornerStepLimit(ctrl, maxTurnDeg = 33.33, maxPoints = 220) {
    const maxTurn = clamp(maxTurnDeg, 4, 170) * Math.PI / 180;
    if (!Array.isArray(ctrl) || ctrl.length < 3) return ctrl;
    let guard = 0;
    while (guard++ < 900 && ctrl.length < maxPoints) {
      let changed = false;
      const n = ctrl.length;
      for (let i = 0; i < n && ctrl.length < maxPoints; i++) {
        const pi = (i - 1 + ctrl.length) % ctrl.length;
        const ni = (i + 1) % ctrl.length;
        const P = ctrl[pi].pos;
        const C = ctrl[i].pos;
        const N = ctrl[ni].pos;
        const vin = v3(C.x - P.x, 0, C.z - P.z);
        const vout = v3(N.x - C.x, 0, N.z - C.z);
        const lin = Math.hypot(vin.x, vin.z);
        const lout = Math.hypot(vout.x, vout.z);
        if (lin < 0.7 || lout < 0.7) continue;
        const turn = Math.acos(clamp((vin.x * vout.x + vin.z * vout.z) / (lin * lout), -1, 1));
        if (turn <= maxTurn) continue;

        const t = clamp((turn - maxTurn) / Math.max(1e-6, Math.PI - maxTurn), 0, 1);
        const cut = 0.22 + 0.34 * t;
        const cutIn = Math.min(lin * cut, lin * 0.46);
        const cutOut = Math.min(lout * cut, lout * 0.46);
        const inDir = v3((P.x - C.x) / lin, 0, (P.z - C.z) / lin);
        const outDir = v3((N.x - C.x) / lout, 0, (N.z - C.z) / lout);
        const A = v3(C.x + inDir.x * cutIn, C.y * 0.72 + P.y * 0.28, C.z + inDir.z * cutIn);
        const B = v3(C.x + outDir.x * cutOut, C.y * 0.72 + N.y * 0.28, C.z + outDir.z * cutOut);

        const ins = cloneCtrlPoint(ctrl[i]);
        ctrl[i].pos = A;
        ins.pos = B;
        ctrl.splice(i + 1, 0, ins);
        changed = true;
        i++;
      }
      if (!changed) break;
    }
    return ctrl;
  }

  function enforceLayoutVariety(ctrl, strength = 1) {
    const n = ctrl.length;
    if (n < 12) return ctrl;
    let absSum = 0;
    const turns = [];
    for (let i = 0; i < n; i++) {
      const a = ctrl[(i - 1 + n) % n].pos;
      const b = ctrl[i].pos;
      const c = ctrl[(i + 1) % n].pos;
      const t = Math.abs(signedTurnXZ(a, b, c));
      turns.push(t);
      absSum += t;
    }
    const mean = absSum / n;
    if (mean < 1e-5) return ctrl;
    let v = 0;
    for (const t of turns) v += (t - mean) * (t - mean);
    const stdev = Math.sqrt(v / n);
    if (stdev / mean > 0.30) return ctrl; // already varied enough

    let cx = 0, cz = 0;
    for (const p of ctrl) { cx += p.pos.x; cz += p.pos.z; }
    cx /= n; cz /= n;
    const c1 = Math.random() * Math.PI * 2;
    const c2 = c1 + Math.PI * (0.55 + Math.random() * 0.5);
    const w1 = 0.26 + Math.random() * 0.35;
    const w2 = 0.24 + Math.random() * 0.34;
    const k1 = (0.10 + Math.random() * 0.18) * strength;
    const k2 = (0.08 + Math.random() * 0.16) * strength;

    for (let i = 0; i < n; i++) {
      const p = ctrl[i].pos;
      const t = (i / n) * Math.PI * 2;
      const d1 = angDelta(t, c1);
      const d2 = angDelta(t, c2);
      const g1 = Math.exp(-(d1 * d1) / (2 * w1 * w1));
      const g2 = Math.exp(-(d2 * d2) / (2 * w2 * w2));
      const dx = p.x - cx;
      const dz = p.z - cz;
      const rr = Math.max(0.001, Math.hypot(dx, dz));
      const nx = dx / rr, nz = dz / rr;
      const scale = 1 + k1 * g1 - k2 * g2;
      p.x = cx + dx * scale + nz * rr * 0.08 * (g1 - g2);
      p.z = cz + dz * scale - nx * rr * 0.08 * (g1 - g2);
    }
    return ctrl;
  }

  function generateOverlapPoints() {
    const out = [];
    const stylePool = ['figure8', 'clover', 'serpentine', 'mountainSpiral', 'splitS', 'f1long'];
    const pick = txt('genStyle');
    const style = pick === 'random'
      ? stylePool[Math.floor(Math.random() * stylePool.length)]
      : pick;
    const comboCount = clamp(Math.round(num('genComboCount')), 1, 3);
    const modY = chk('genModY');
    const modRound = chk('genModRound');
    const modCross = chk('genModCross');
    const r = clamp(num('genRandomness'), 0, 1);
    const sizeMul = clamp(num('genScale'), 0.6, 3.8);
    const lenMul = clamp(num('genLength'), 0.7, 3.5);
    const bends = clamp(Math.round(num('genCurves')), 2, 16);
    const pointCap = clamp(Math.round(num('genPointCap')), 16, 120);
    const straightBias = clamp(num('genStraights'), 0, 1);
    const flow = clamp(num('genFlow'), 0, 1);
    const roundExits = clamp(Math.round(num('genRoundExits')), 2, 4);
    const crossFreq = clamp(Math.round(num('genCrossFreq')), 1, 4);
    const comboStyles = (() => {
      const out = [style];
      if (comboCount <= 1) return out;
      const pool = stylePool.filter((s) => s !== style);
      while (out.length < comboCount && pool.length) {
        const k = Math.floor(Math.random() * pool.length);
        out.push(pool.splice(k, 1)[0]);
      }
      return out;
    })();
    const baseN = Math.max(14, (bends * 3.2) + 6 + Math.floor(4 * r));
    let n = Math.round(baseN * (0.86 + 0.64 * lenMul));
    const hasF1 = comboStyles.includes('f1long');
    if (hasF1) {
      n = Math.max(n, Math.round((34 + bends * 7 + Math.floor(10 * r)) * (1.0 + 0.45 * lenMul)));
    }
    n = clamp(n, 20, pointCap);
    let radius = (10 + r * 7 + Math.random() * (1.8 * r)) * sizeMul * (0.88 + 0.50 * lenMul);
    if (hasF1) radius *= (1.25 + 0.55 * straightBias);
    const twist = (Math.random() * 2 - 1) * (0.05 + 0.35 * r) * (hasF1 ? 0.55 : 1);
    const rot = Math.random() * Math.PI * 2;
    const c = Math.cos(rot), s = Math.sin(rot);
    const yAmp = (hasF1 ? (0.02 + Math.random() * 0.26) : (0.05 + Math.random() * 0.75)) * r * (0.85 + 0.35 * lenMul);
    const yFreq = 1 + Math.floor(Math.random() * 2);
    const bankAmp = hasF1 ? (2.4 + 6.2 * r) : (4 + 10 * r);
    const f1Variant = Math.floor(Math.random() * 4); // 0 superellipse, 1 dogbone, 2 tri-lobe, 3 chicane
    const asymSkewX = (Math.random() * 2 - 1) * (0.06 + 0.18 * r);
    const asymSkewZ = (Math.random() * 2 - 1) * (0.05 + 0.16 * r);
    const asymWarpA = (Math.random() * 2 - 1) * (0.05 + 0.11 * r);
    const asymWarpB = (Math.random() * 2 - 1) * (0.04 + 0.10 * r);
    const featureCount = hasF1 ? 2 + Math.floor(Math.random() * 2) : 1 + (Math.random() < 0.35 ? 1 : 0);
    const features = [];
    for (let fi = 0; fi < featureCount; fi++) {
      features.push({
        c: Math.random() * Math.PI * 2,
        w: 0.28 + Math.random() * 0.46,
        amp: (0.08 + Math.random() * 0.16) * (hasF1 ? (0.6 + 0.55 * (1 - flow)) : 0.42),
      });
    }

    const comboPhases = comboStyles.map((_, i) => ((i / comboStyles.length) * Math.PI * 2) + (Math.random() * 2 - 1) * 0.55);
    const comboOffsets = comboStyles.map((_, i) => {
      if (comboStyles.length <= 1) return { x: 0, z: 0 };
      const a = (i / comboStyles.length) * Math.PI * 2 + (Math.random() * 2 - 1) * 0.35;
      const m = 0.12 + 0.07 * Math.random();
      return { x: Math.cos(a) * m, z: Math.sin(a) * m };
    });

    function stylePoint(st, t) {
      let x, z;
      if (st === 'figure8') {
        x = Math.sin(t) * radius;
        z = Math.sin(2 * t) * radius * 0.66;
      } else if (st === 'clover') {
        const rr = radius * (1 + 0.11 * Math.cos((2 + Math.floor(bends * 0.5)) * t));
        x = Math.cos(t) * rr;
        z = Math.sin(t) * rr * 0.92;
      } else if (st === 'serpentine') {
        const k = clamp(2 + Math.floor(bends * 0.5), 2, 6);
        x = Math.sin(t) * radius * (1.15 + 0.10 * (1 - flow));
        z = (Math.sin(k * t) * 0.34 + Math.sin((k - 1) * t + 0.35) * 0.18) * radius * (0.98 + 0.16 * r);
      } else if (st === 'mountainSpiral') {
        const theta = t + 0.92 * Math.sin(t + 0.20) + 0.34 * Math.sin(2 * t - 0.35);
        const rBase = radius * (0.68 + 0.22 * Math.cos(t - 0.45) + 0.15 * Math.cos(2 * t + 0.95) + 0.10 * Math.sin(3 * t - 0.60));
        x = Math.cos(theta) * rBase * (1.08 + 0.10 * (1 - flow));
        z = Math.sin(theta) * rBase * 0.96;
        x += Math.sin(4 * t + 0.65) * radius * (0.09 + 0.08 * r);
        z += Math.sin(6 * t - 0.40) * radius * (0.06 + 0.07 * r);
      } else if (st === 'splitS') {
        x = Math.sin(t) * radius * 0.98;
        z = (Math.sin(2 * t) * 0.42 + Math.sin((2 + Math.floor(bends / 3)) * t) * 0.13) * radius;
      } else if (st === 'f1long') {
        const ct = Math.cos(t), stt = Math.sin(t);
        const longAxis = 1.30 + 1.00 * straightBias + 0.30 * (lenMul - 1);
        const shortAxis = 0.56 + 0.28 * (1 - straightBias) + 0.16 * r;
        if (f1Variant === 0) {
          const p = 1.9 + straightBias * 3.0 + 0.6 * r;
          const ex = 2 / p;
          const sx = Math.sign(ct) * Math.pow(Math.abs(ct), ex);
          const sz = Math.sign(stt) * Math.pow(Math.abs(stt), ex);
          x = sx * radius * longAxis;
          z = sz * radius * shortAxis;
        } else if (f1Variant === 1) {
          const pinch = 0.70 + 0.22 * Math.cos(2 * t + 0.35);
          const bulge = 1 + 0.22 * Math.cos(t - 0.45) * Math.cos(t - 0.45);
          x = ct * radius * longAxis * bulge;
          z = stt * radius * shortAxis * pinch;
        } else if (f1Variant === 2) {
          const l1 = 1 + 0.24 * Math.sin(3 * t + 0.4) + 0.10 * Math.sin(2 * t - 0.25);
          x = ct * radius * longAxis * (0.92 + 0.22 * Math.max(0, Math.cos(t - 0.2)));
          z = stt * radius * shortAxis * l1;
        } else {
          const p = 2.2 + straightBias * 2.4;
          const ex = 2 / p;
          const sx = Math.sign(ct) * Math.pow(Math.abs(ct), ex);
          const sz = Math.sign(stt) * Math.pow(Math.abs(stt), ex);
          x = sx * radius * longAxis;
          z = sz * radius * shortAxis;
          x += Math.sin(3 * t + 0.9) * radius * (0.10 + 0.12 * r);
          z += Math.sin(5 * t - 0.3) * radius * (0.06 + 0.10 * r);
        }
        const hk = 2 + Math.floor(bends * 0.38);
        const vk = 3 + Math.floor(bends * 0.50);
        x += Math.sin(hk * t + twist * 0.6) * radius * (0.04 + 0.07 * r * (1 - straightBias));
        z += Math.sin(vk * t - twist * 0.4) * radius * (0.06 + 0.10 * r);
        x += radius * (asymWarpA * Math.sin(t + 0.35) + asymWarpB * Math.sin(2 * t - 0.65));
        z += radius * (asymWarpB * Math.sin(t - 0.9) - asymWarpA * 0.65 * Math.cos(2 * t + 0.22));
        let localScale = 1;
        for (const f of features) {
          const d = angDelta(t, f.c);
          localScale += f.amp * Math.exp(-(d * d) / (2 * f.w * f.w));
        }
        x *= localScale;
        z *= localScale;
      } else {
        x = Math.sin(t) * radius;
        z = Math.sin((2 + Math.floor(bends / 3)) * t) * radius * 0.58;
      }
      return { x, z };
    }

    for (let i = 0; i < n; i++) {
      const t = (i / n) * Math.PI * 2;
      let x = 0, z = 0;
      if (comboStyles.length <= 1) {
        const p = stylePoint(style, t);
        x = p.x; z = p.z;
      } else {
        const sigma = (Math.PI / comboStyles.length) * 0.72;
        let wsum = 0;
        for (let ci = 0; ci < comboStyles.length; ci++) {
          const center = (ci / comboStyles.length) * Math.PI * 2;
          const d = angDelta(t, center);
          const w = Math.exp(-(d * d) / (2 * sigma * sigma));
          const p = stylePoint(comboStyles[ci], t + comboPhases[ci]);
          x += w * (p.x + comboOffsets[ci].x * radius);
          z += w * (p.z + comboOffsets[ci].z * radius);
          wsum += w;
        }
        if (wsum > 1e-6) {
          x /= wsum;
          z /= wsum;
        }
      }
      if (modY) {
        z += Math.max(0, Math.sin(t)) * radius * (0.1 + 0.13 * r);
      }
      if (modRound) {
        // Always bias wider roundabout geometry.
        const rr = radius * (0.66 + 0.12 * Math.cos(roundExits * t));
        const ringX = Math.cos(t) * rr;
        const ringZ = Math.sin(t) * rr;
        const arm = Math.max(0, Math.cos(roundExits * t));
        const ax = ringX + Math.cos(t) * arm * radius * (0.44 + 0.14 * r);
        const az = ringZ + Math.sin(t) * arm * radius * (0.32 + 0.12 * r);
        const blend = 0.36 + 0.24 * r;
        x = x * (1 - blend) + ax * blend;
        z = z * (1 - blend) + az * blend;
      }
      if (modCross) {
        const crossScale = (style === 'f1long' && comboStyles.length <= 1) ? 0.45 : 1.0;
        z += Math.sin(crossFreq * 2 * t + 0.5) * radius * (0.06 + 0.08 * r) * crossScale;
      }
      // Controlled wobble while keeping the layout drivable.
      const wob = comboStyles.length > 1 ? 0.19 : (style === 'figure8' ? 1.0 : (style === 'f1long' ? 0.08 : 0.24));
      x += Math.sin(t * 3 + twist) * (radius * (0.01 + 0.08 * r) * wob);
      z += Math.cos(t * 4 - twist) * (radius * (0.01 + 0.07 * r) * wob);

      // Rotate final shape.
      let rx = x * c - z * s;
      let rz = x * s + z * c;
      if (style === 'f1long' || comboStyles.includes('f1long')) {
        const sxw = rx + rz * asymSkewX;
        const szw = rz + rx * asymSkewZ;
        rx = sxw;
        rz = szw;
      }

      let y = Math.sin(t * yFreq + twist * 2) * yAmp + bridgeProfile(style, t, r, modY, modCross);
      if (style === 'serpentine') {
        // Keep one side consistently higher than the other.
        y += Math.sin(t) * (0.95 + 2.2 * r);
      } else if (style === 'mountainSpiral') {
        // Spiral-like climb/descent around center mountain.
        y += Math.sin(t * 1.55 - 0.3) * (1.2 + 2.0 * r) + Math.cos(t * 0.5 + 0.15) * (0.55 + 0.95 * r);
      } else if (comboStyles.includes('mountainSpiral')) {
        y += Math.sin(t * 1.28 - 0.18) * (0.65 + 1.25 * r);
      }
      const bank = Math.sin(t * 2 + twist) * bankAmp;
      out.push({
        pos: v3(rx, y, rz),
        bank,
        node: 'smooth',
        hin: { x: 0, z: 0 },
        hout: { x: 0, z: 0 },
      });
    }
    if (comboStyles.length > 1) {
      smoothGeneratedLayout(out, 2 + Math.round(flow * 2), 0.20 + 0.14 * flow, 0.16 + 0.08 * flow);
    } else if (style === 'f1long') {
      const varKeep = 1 - flow * 0.45;
      smoothGeneratedLayout(out, 3 + Math.round(flow * 2), 0.24 + 0.16 * flow * varKeep, 0.15 + 0.08 * flow);
    } else if (style === 'mountainSpiral') {
      smoothGeneratedLayout(out, 2 + Math.round(flow * 1.5), 0.22 + 0.14 * flow, 0.18 + 0.10 * flow);
    } else if (style !== 'figure8') {
      smoothGeneratedLayout(out, 3 + Math.round(flow * 2), 0.36 + 0.18 * flow + 0.06 * r, 0.20 + 0.08 * flow);
    } else {
      smoothGeneratedLayout(out, 1 + Math.round(flow), 0.16 + 0.12 * flow, 0.08 + 0.04 * flow);
    }
    const roadW = Math.max(1, num('roadWidth'));
    const overlapTarget = style === 'figure8'
      ? (roadW * (1.65 + 0.55 * (1 - flow)))
      : (style === 'serpentine'
        ? (roadW * (2.95 + 0.95 * (1 - flow)))
        : (style === 'mountainSpiral'
          ? (roadW * (2.75 + 0.90 * (1 - flow)))
          : (roadW * (2.1 + 0.7 * (1 - flow)))));
    const megaTarget = comboStyles.length > 1 ? overlapTarget * (1.14 + 0.08 * comboStyles.length) : overlapTarget;
    relaxSelfCollisions(out, {
      targetDist: megaTarget,
      minNeighborGap: comboStyles.length > 1 ? 4 : (style === 'f1long' ? 4 : ((style === 'serpentine' || style === 'mountainSpiral') ? 4 : 3)),
      passes: comboStyles.length > 1 ? 7 : (style === 'f1long' ? 5 : (style === 'serpentine' ? 6 : (style === 'mountainSpiral' ? 6 : 4))),
    });
    enforceCornerStepLimit(out, 33.33, pointCap + 36);
    if (style === 'f1long') {
      enforceLayoutVariety(out, 0.9 + 0.8 * (1 - flow));
    }
    smoothGeneratedLayout(out, 1 + Math.round(flow), 0.08, 0.03);
    applyTrackRules(out);
    const baseBankIntensity = style === 'f1long' ? (0.42 + 0.34 * r) : (0.65 + 0.55 * r);
    const bankFlowScale = 1 - flow * 0.2;
    computeGeneratedBank(out, baseBankIntensity * bankFlowScale);
    applyBezierHandles(out, 0.58 + 0.50 * flow);
    return out;
  }

  function runGenerateTrack() {
    pushUndo();
    points = generateOverlapPoints();
    if (chk('roadIsoSnap')) {
      for (const p of points) {
        const sp = snapRoadXYZ(p.pos.x, p.pos.y, p.pos.z);
        p.pos.x = sp.x;
        p.pos.y = sp.y;
        p.pos.z = sp.z;
      }
      smoothAllPointHandles();
    }
    splitEnds = [];
    branchSections = [];
    placedTrees = [];
    placedFences = [];
    fencePlaceStart = null;
    $('closed').checked = true;
    if (num('subdiv') < 8) $('subdiv').value = '8';
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    gizmo.active = false;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    updateLabels();
    cached = null;
    frame3D();
  }
  $('genBtn').onclick = runGenerateTrack;
  genQuickBtn?.addEventListener('click', runGenerateTrack);

  const objText = $('objText');
  let showOBJ = false;
  $('toggleObj').onclick = () => {
    showOBJ = !showOBJ;
    objText.style.display = showOBJ ? 'block' : 'none';
    $('toggleObj').textContent = showOBJ ? 'Hide OBJ' : 'Show OBJ';
  };

  function autoBankCfg() {
    return {
      enabled: chk('autoBank'),
      strength: num('autoBankStrength'),
      maxDeg: num('autoBankMax'),
      scale: num('autoBankScale'),
    };
  }

  $('exportBtn').onclick = () => {
    const net = sampleRoadNetwork();
    if (net.main.length < 2) return;
    const mainRoad = buildRoadMesh(net.main, {
      width: num('roadWidth'),
      thickness: num('roadThickness'),
      includeSides: chk('includeSides'),
      uvScale: 6,
      closed: chk('closed'),
      capEnds: !chk('closed'),
    });
    const roadTop = cloneMesh(mainRoad.roadTop, 'road_top');
    const roadSides = mainRoad.roadSides ? cloneMesh(mainRoad.roadSides, 'road_sides') : null;
    for (const bs of net.branches) {
      const extra = buildRoadMesh(bs, {
        width: num('roadWidth'),
        thickness: num('roadThickness'),
        includeSides: chk('includeSides'),
        uvScale: 6,
        closed: false,
        capEnds: true,
      });
      mergeMeshInto(roadTop, extra.roadTop);
      if (roadSides && extra.roadSides) mergeMeshInto(roadSides, extra.roadSides);
    }
    addJunctionPads(roadTop, num('roadWidth'));
    const terrain = chk('terrainOn')
      ? buildTerrainMesh(net.all, {
        roadWidth: num('roadWidth'),
        roadThickness: num('roadThickness'),
        shoulderWidth: chk('themeOn') ? num('themeGrass') : 1.8,
        roadClearance: num('terrainClearance'),
        followRoad: num('terrainFollow'),
        detail: num('terrainDetail'),
        roughness: num('terrainRough'),
        cliffHeight: num('terrainCliff'),
      })
      : null;
    const theme = buildThemeMeshes(net.main, mainRoad.frames, {
      enabled: chk('themeOn'),
      roadWidth: num('roadWidth'),
      roadThickness: num('roadThickness'),
      shoulderWidth: num('themeGrass'),
      curbHeight: num('themeCurb'),
      closed: chk('closed'),
    });
    const placed = buildPlacedPropMeshes({
      enabled: chk('themeOn'),
      fenceScale: num('themeFence'),
      treeScale: num('themeTrees'),
    }, {
      fences: placedFences,
      trees: placedTrees,
    });
    const themeMeshes = [...theme, ...placed].map(t => t.mesh);
    const obj = meshesToOBJ([roadTop, ...(roadSides ? [roadSides] : []), ...(terrain ? [terrain] : []), ...themeMeshes]);
    objText.value = obj;
    const name = (txt('trackName') || 'track').trim();
    try { downloadText(name + '.obj', obj); }
    catch {
      showOBJ = true;
      objText.style.display = 'block';
      $('toggleObj').textContent = 'Hide OBJ';
    }
  };

  // ---------- pro handle rules ----------
  function setHandle(target, which, hx, hz, opts = { rotateOnly: false, breakMirror: false }) {
    let p = null;
    if (target?.kind === 'branch') {
      const sec = branchSections[target.sec];
      p = sec?.mids?.[target.mid] || null;
      if (p) {
        if (!p.hin) p.hin = { x: 0, z: 0 };
        if (!p.hout) p.hout = { x: 0, z: 0 };
        if (!p.node) p.node = 'smooth';
      }
    } else {
      p = points[target?.i];
      if (p) ensurePointShape(p);
    }
    if (!p) return;
    const node = p.node || 'smooth';

    // rotateOnly: preserve original length
    const cur = which === 'in' ? p.hin : p.hout;
    let nx = hx, nz = hz;
    if (opts.rotateOnly) {
      const L = Math.hypot(cur.x, cur.z) || 1;
      const ang = Math.atan2(hz, hx);
      nx = Math.cos(ang) * L;
      nz = Math.sin(ang) * L;
    }

    if (which === 'in') p.hin = { x: nx, z: nz }; else p.hout = { x: nx, z: nz };

    // Corner (or breakMirror) => no coupling
    if (node === 'corner' || opts.breakMirror) return;

    // Mirror the opposite handle angle (and optionally length)
    const oppWhich = which === 'in' ? 'out' : 'in';
    const opp = oppWhich === 'in' ? p.hin : p.hout;

    const ang = Math.atan2(nz, nx);
    const oppAng = ang + Math.PI; // opposite direction

    if (node === 'smooth') {
      const L = Math.hypot(nx, nz) || 1;
      const ox = Math.cos(oppAng) * L;
      const oz = Math.sin(oppAng) * L;
      if (oppWhich === 'in') p.hin = { x: ox, z: oz }; else p.hout = { x: ox, z: oz };
    } else if (node === 'aligned') {
      const L = Math.hypot(opp.x, opp.z) || 1;
      const ox = Math.cos(oppAng) * L;
      const oz = Math.sin(oppAng) * L;
      if (oppWhich === 'in') p.hin = { x: ox, z: oz }; else p.hout = { x: ox, z: oz };
    }
  }

  // ---------- 3D preview (software renderer) ----------
  function getMesh() {
    if (cached) return cached;
    const net = sampleRoadNetwork();
    if (net.main.length < 2) { cached = null; return null; }
    const mainRoad = buildRoadMesh(net.main, {
      width: num('roadWidth'),
      thickness: num('roadThickness'),
      includeSides: chk('includeSides'),
      uvScale: 6,
      closed: chk('closed'),
      capEnds: !chk('closed'),
    });
    const roadTop = cloneMesh(mainRoad.roadTop, 'road_top');
    const roadSides = mainRoad.roadSides ? cloneMesh(mainRoad.roadSides, 'road_sides') : null;
    for (const bs of net.branches) {
      const extra = buildRoadMesh(bs, {
        width: num('roadWidth'),
        thickness: num('roadThickness'),
        includeSides: chk('includeSides'),
        uvScale: 6,
        closed: false,
        capEnds: true,
      });
      mergeMeshInto(roadTop, extra.roadTop);
      if (roadSides && extra.roadSides) mergeMeshInto(roadSides, extra.roadSides);
    }
    addJunctionPads(roadTop, num('roadWidth'));
    const terrain = chk('terrainOn')
      ? buildTerrainMesh(net.all, {
        roadWidth: num('roadWidth'),
        roadThickness: num('roadThickness'),
        shoulderWidth: chk('themeOn') ? num('themeGrass') : 1.8,
        roadClearance: num('terrainClearance'),
        followRoad: num('terrainFollow'),
        detail: num('terrainDetail'),
        roughness: num('terrainRough'),
        cliffHeight: num('terrainCliff'),
      })
      : null;
    const theme = buildThemeMeshes(net.main, mainRoad.frames, {
      enabled: chk('themeOn'),
      roadWidth: num('roadWidth'),
      roadThickness: num('roadThickness'),
      shoulderWidth: num('themeGrass'),
      curbHeight: num('themeCurb'),
      closed: chk('closed'),
    });
    const placed = buildPlacedPropMeshes({
      enabled: chk('themeOn'),
      fenceScale: num('themeFence'),
      treeScale: num('themeTrees'),
    }, {
      fences: placedFences,
      trees: placedTrees,
    });

    const tris = [];
    function pushMesh(mesh, kind) {
      for (const f of mesh.faces) {
        const a = mesh.verts[f.a - 1], b = mesh.verts[f.b - 1], c = mesh.verts[f.c - 1];
        if (!a || !b || !c) continue;
        tris.push({ a, b, c, kind });
      }
    }
    pushMesh(roadTop, 'top');
    if (roadSides) pushMesh(roadSides, 'side');
    if (terrain) pushMesh(terrain, 'terrain');
    for (const t of theme) pushMesh(t.mesh, t.kind);
    for (const t of placed) pushMesh(t.mesh, t.kind);

    const allVerts = [
      ...roadTop.verts,
      ...(roadSides ? roadSides.verts : []),
      ...(terrain ? terrain.verts : []),
      ...theme.flatMap(t => t.mesh.verts),
      ...placed.flatMap(t => t.mesh.verts),
    ];
    const mn = v3(+1e9, +1e9, +1e9), mx = v3(-1e9, -1e9, -1e9);
    for (const p of allVerts) {
      mn.x = Math.min(mn.x, p.x); mn.y = Math.min(mn.y, p.y); mn.z = Math.min(mn.z, p.z);
      mx.x = Math.max(mx.x, p.x); mx.y = Math.max(mx.y, p.y); mx.z = Math.max(mx.z, p.z);
    }

    cached = { samples: net.main, branchSamples: net.branches, roadTop, roadSides, terrain, theme, placed, tris, bbox: { min: mn, max: mx } };
    return cached;
  }

  function camForward() {
    const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    return norm(v3(cy * cp, sp, -sy * cp));
  }

  function camPos() { return camEye; }

  function setCameraLookAt(eye, target) {
    camEye = v3(eye.x, eye.y, eye.z);
    const d = norm(sub(target, eye));
    camPitch = clamp(Math.asin(clamp(d.y, -1, 1)), -1.48, 1.48);
    camYaw = Math.atan2(-d.z, d.x);
  }

  function updateCameraMove(dt, basis) {
    if (isTypingTarget(document.activeElement)) return;
    let mv = v3(0, 0, 0);
    if (keysDown.has('KeyW')) mv = add(mv, basis.f);
    if (keysDown.has('KeyS')) mv = add(mv, mul(basis.f, -1));
    if (keysDown.has('KeyD')) mv = add(mv, basis.r);
    if (keysDown.has('KeyA')) mv = add(mv, mul(basis.r, -1));
    if (keysDown.has('KeyQ')) mv = add(mv, v3(0, 1, 0));
    if (keysDown.has('KeyZ')) mv = add(mv, v3(0, -1, 0));
    const L = len(mv);
    if (L < 1e-6) return;
    const boost = keysDown.has('ShiftLeft') || keysDown.has('ShiftRight') ? 2.8 : 1.0;
    const step = camMoveSpeed * boost * dt;
    camEye = add(camEye, mul(norm(mv), step));
  }

  function lookAtBasis(eye, target) {
    const f = norm(sub(target, eye));
    const up0 = v3(0, 1, 0);
    let r = cross(f, up0);
    if (len(r) < 1e-6) r = v3(1, 0, 0);
    r = norm(r);
    const u = norm(cross(r, f));
    return { r, u, f };
  }

  function project3(p, eye, basis, w, h) {
    const q = sub(p, eye);
    const x = dot(q, basis.r);
    const y = dot(q, basis.u);
    const z = dot(q, basis.f);
    const fov = 60 * Math.PI / 180;
    const s = 1 / Math.tan(fov / 2);
    const aspect = w / h;
    const nz = z <= 0.02 ? 0.02 : z;
    const px = (x * s / aspect) / nz;
    const py = (y * s) / nz;
    return { sx: (px * 0.5 + 0.5) * w, sy: (-py * 0.5 + 0.5) * h, z: nz };
  }

  function shadeTri(a, b, c) {
    const n = norm(cross(sub(b, a), sub(c, a)));
    const light = norm(v3(-0.35, 0.85, 0.4));
    return clamp(dot(n, light) * 0.7 + 0.3, 0, 1);
  }

  function frame3D() {
    const m = getMesh();
    if (!m || !m.bbox) return;
    const b = m.bbox;
    let tgt = null;
    let r = 0;

    if (selected >= 0 && points[selected]) {
      tgt = points[selected].pos;
      const closed = chk('closed');
      const n = points.length;
      const pi = closed ? (selected - 1 + n) % n : Math.max(0, selected - 1);
      const ni = closed ? (selected + 1) % n : Math.min(n - 1, selected + 1);
      const prev = points[pi]?.pos || tgt;
      const next = points[ni]?.pos || tgt;
      const avgSeg = (Math.hypot(tgt.x - prev.x, tgt.z - prev.z) + Math.hypot(next.x - tgt.x, next.z - tgt.z)) * 0.5;
      r = clamp(Math.max(num('roadWidth') * 1.35, avgSeg * 1.9), 2.8, 16);
    } else if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (ref?.mid) {
        tgt = v3(ref.mid.x, ref.mid.y, ref.mid.z);
        r = clamp(num('roadWidth') * 1.6, 2.8, 16);
      }
    }

    if (!tgt) {
      tgt = mul(add(b.min, b.max), 0.5);
      const ext = sub(b.max, b.min);
      r = Math.max(ext.x, ext.y, ext.z) * 0.9 + 1e-6;
    }

    const eye = add(tgt, v3(r * 1.22, r * 0.72, -r * 1.22));
    setCameraLookAt(eye, tgt);
    camSpeedBase = camBaseSpeedFromRadius(r);
    camMoveSpeed = camSpeedBase;
  }

  function gizmoScreen(eye, basis, w, h) {
    if (selected < 0) return null;
    const P = points[selected].pos;
    const center = project3(P, eye, basis, w, h);
    const size = Math.max(1.5, len(sub(P, eye)) * 0.085);
    const px = project3(add(P, v3(size, 0, 0)), eye, basis, w, h);
    const py = project3(add(P, v3(0, size, 0)), eye, basis, w, h);
    const pz = project3(add(P, v3(0, 0, size)), eye, basis, w, h);
    return { P, center, px, py, pz, depth: center.z, size };
  }

  function hitGizmoAxis(gs, sx, sy) {
    if (!gs) return null;
    const hitRad = 10;
    const centerHit = Math.hypot(sx - gs.center.sx, sy - gs.center.sy);
    if (centerHit <= 8) return 'free';
    const c = gs.center;
    const axes = [
      { axis: 'x', p: gs.px },
      { axis: 'y', p: gs.py },
      { axis: 'z', p: gs.pz },
    ];
    let best = null;
    let bd = hitRad;
    for (const a of axes) {
      const x1 = c.sx, y1 = c.sy, x2 = a.p.sx, y2 = a.p.sy;
      const vx = x2 - x1, vy = y2 - y1;
      const wx = sx - x1, wy = sy - y1;
      const vv = vx * vx + vy * vy || 1;
      const t = clamp((wx * vx + wy * vy) / vv, 0, 1);
      const px = x1 + vx * t, py = y1 + vy * t;
      const d = Math.hypot(sx - px, sy - py);
      if (d < bd) { bd = d; best = a.axis; }
    }
    return best;
  }

  function worldPerPixel(depth, h) {
    const fov = 60 * Math.PI / 180;
    const viewH = 2 * depth * Math.tan(fov / 2);
    return viewH / h;
  }

  function renderAxisHelper(basis, w, h) {
    const cx = w - 68;
    const cy = h - 68;
    const L = 28;
    const axes = [
      { name: 'X', dir: v3(1, 0, 0), col: '255,110,110' },
      { name: 'Y', dir: v3(0, 1, 0), col: '120,255,160' },
      { name: 'Z', dir: v3(0, 0, 1), col: '120,170,255' },
    ].map(a => ({
      ...a,
      dx: dot(a.dir, basis.r),
      dy: dot(a.dir, basis.u),
      dz: dot(a.dir, basis.f),
    }));

    vctx.save();
    vctx.globalAlpha = 0.45;
    vctx.fillStyle = 'rgba(11,15,25,0.85)';
    vctx.strokeStyle = 'rgba(183,197,255,0.45)';
    vctx.lineWidth = 1;
    vctx.beginPath();
    vctx.arc(cx, cy, 34, 0, Math.PI * 2);
    vctx.fill();
    vctx.stroke();

    axes.sort((a, b) => a.dz - b.dz);
    vctx.lineCap = 'round';
    vctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

    for (const a of axes) {
      const ex = cx + a.dx * L;
      const ey = cy - a.dy * L;
      const alpha = 0.45 + 0.5 * ((a.dz + 1) * 0.5);

      vctx.globalAlpha = alpha;
      vctx.strokeStyle = `rgb(${a.col})`;
      vctx.lineWidth = 2.2;
      vctx.beginPath();
      vctx.moveTo(cx, cy);
      vctx.lineTo(ex, ey);
      vctx.stroke();

      vctx.fillStyle = `rgb(${a.col})`;
      vctx.beginPath();
      vctx.arc(ex, ey, 3.4, 0, Math.PI * 2);
      vctx.fill();

      vctx.globalAlpha = 0.95;
      vctx.fillStyle = '#e9ecf6';
      vctx.fillText(a.name, ex + 6, ey + 4);
    }
    vctx.restore();
  }

  let lastCamTick = performance.now();
  function render3D() {
    try {
      const r = viewWrap.getBoundingClientRect();
      const w = r.width, h = r.height;
      vctx.clearRect(0, 0, w, h);
      vctx.fillStyle = '#0b0f19';
      vctx.fillRect(0, 0, w, h);

      const m = getMesh();
      if (!m) { requestAnimationFrame(render3D); return; }

    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0, (now - lastCamTick) / 1000));
    lastCamTick = now;

    let eye = camPos();
    let target = add(eye, camForward());
    let basis = lookAtBasis(eye, target);
    updateCameraMove(dt, basis);
    eye = camPos();
    target = add(eye, camForward());
    basis = lookAtBasis(eye, target);

    // grid hint
    vctx.save();
    vctx.globalAlpha = 0.15;
    vctx.strokeStyle = '#24345f';
    vctx.lineWidth = 1;
    const step = 5, span = 50;
    for (let i = -span; i <= span; i += step) {
      const p0 = v3(i, 0, -span), p1 = v3(i, 0, span);
      const q0 = project3(p0, eye, basis, w, h), q1 = project3(p1, eye, basis, w, h);
      vctx.beginPath(); vctx.moveTo(q0.sx, q0.sy); vctx.lineTo(q1.sx, q1.sy); vctx.stroke();
      const r0 = v3(-span, 0, i), r1 = v3(span, 0, i);
      const s0 = project3(r0, eye, basis, w, h), s1 = project3(r1, eye, basis, w, h);
      vctx.beginPath(); vctx.moveTo(s0.sx, s0.sy); vctx.lineTo(s1.sx, s1.sy); vctx.stroke();
    }
    vctx.restore();

    const projected = [];
    for (const t of m.tris) {
      const pa = project3(t.a, eye, basis, w, h);
      const pb = project3(t.b, eye, basis, w, h);
      const pc = project3(t.c, eye, basis, w, h);
      const z = (pa.z + pb.z + pc.z) / 3;
      const n = norm(cross(sub(t.b, t.a), sub(t.c, t.a)));
      projected.push({ pa, pb, pc, z, kind: t.kind, a: t.a, b: t.b, c: t.c, n });
    }
    projected.sort((A, B) => B.z - A.z);

    if (viewMode !== 'wireframe') {
      for (const t of projected) {
        if (viewMode === 'normal') {
          const nr = Math.round((t.n.x * 0.5 + 0.5) * 255);
          const ng = Math.round((t.n.y * 0.5 + 0.5) * 255);
          const nb = Math.round((t.n.z * 0.5 + 0.5) * 255);
          vctx.fillStyle = `rgb(${nr},${ng},${nb})`;
        } else {
          const d = shadeTri(t.a, t.b, t.c);
          let base = [20, 24, 35];
          if (t.kind === 'top') base = [42, 47, 58];
          else if (t.kind === 'terrain') base = [117, 102, 78];
          else if (t.kind === 'grass') base = [74, 136, 82];
          else if (t.kind === 'curb') base = [206, 186, 134];
          else if (t.kind === 'fence') base = [126, 92, 58];
          else if (t.kind === 'treeTrunk') base = [108, 77, 45];
          else if (t.kind === 'treeLeaf') base = [79, 166, 90];
          vctx.fillStyle = `rgb(${Math.round(base[0] * d)},${Math.round(base[1] * d)},${Math.round(base[2] * d)})`;
        }
        vctx.beginPath();
        vctx.moveTo(t.pa.sx, t.pa.sy);
        vctx.lineTo(t.pb.sx, t.pb.sy);
        vctx.lineTo(t.pc.sx, t.pc.sy);
        vctx.closePath();
        vctx.fill();
      }
    }

    if (viewMode !== 'normal') {
      vctx.save();
      vctx.globalAlpha = viewMode === 'wireframe' ? 0.96 : 0.35;
      vctx.strokeStyle = viewMode === 'wireframe' ? '#e5eeff' : '#b7c5ff';
      vctx.lineWidth = viewMode === 'wireframe' ? 1.35 : 1;
      for (const t of projected) {
        vctx.beginPath();
        vctx.moveTo(t.pa.sx, t.pa.sy);
        vctx.lineTo(t.pb.sx, t.pb.sy);
        vctx.lineTo(t.pc.sx, t.pc.sy);
        vctx.closePath();
        vctx.stroke();
      }
      vctx.restore();
    }

    // centerline
    vctx.save();
    vctx.globalAlpha = 0.9;
    vctx.strokeStyle = '#ffd36e';
    vctx.setLineDash([6, 6]);
    vctx.beginPath();
    for (let i = 0; i < m.samples.length; i++) {
      const p = project3(m.samples[i].pos, eye, basis, w, h);
      if (i === 0) vctx.moveTo(p.sx, p.sy); else vctx.lineTo(p.sx, p.sy);
    }
    vctx.stroke();
    vctx.setLineDash([]);
    vctx.restore();

    // control polygon + clickable control points in 3D
    if (points.length > 1) {
      vctx.save();
      vctx.globalAlpha = 0.45;
      vctx.strokeStyle = '#9fb3ff';
      vctx.lineWidth = 1;
      vctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        const p = project3(points[i].pos, eye, basis, w, h);
        if (i === 0) vctx.moveTo(p.sx, p.sy); else vctx.lineTo(p.sx, p.sy);
      }
      if (chk('closed')) {
        const p0 = project3(points[0].pos, eye, basis, w, h);
        vctx.lineTo(p0.sx, p0.sy);
      }
      vctx.stroke();
      vctx.restore();
    }
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const q = sub(p.pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const sp = project3(p.pos, eye, basis, w, h);
      vctx.save();
      vctx.fillStyle = i === selected ? '#ffd36e' : '#f5f7ff';
      vctx.globalAlpha = i === selected ? 1 : 0.92;
      vctx.beginPath(); vctx.arc(sp.sx, sp.sy, i === selected ? 5.4 : 4.2, 0, Math.PI * 2); vctx.fill();
      vctx.restore();
    }

    const drawBezierHandles3D = (target) => {
      if (!target) return;
      const anchor = bezierHandleAnchor(target);
      if (!anchor) return;
      const q0 = sub(anchor, eye);
      if (dot(q0, basis.f) <= 0.04) return;
      const aSp = project3(anchor, eye, basis, w, h);
      const hIn = bezierHandleWorldPoint(target, 'in');
      const hOut = bezierHandleWorldPoint(target, 'out');
      if (!hIn || !hOut) return;
      const qIn = sub(hIn, eye);
      const qOut = sub(hOut, eye);
      if (dot(qIn, basis.f) <= 0.04 || dot(qOut, basis.f) <= 0.04) return;
      const inSp = project3(hIn, eye, basis, w, h);
      const outSp = project3(hOut, eye, basis, w, h);
      const inHover = sameBezierHandle(bezier3DHover, { ...target, which: 'in' }) || sameBezierHandle(bezier3DDrag, { ...target, which: 'in' });
      const outHover = sameBezierHandle(bezier3DHover, { ...target, which: 'out' }) || sameBezierHandle(bezier3DDrag, { ...target, which: 'out' });

      vctx.save();
      vctx.globalAlpha = 0.95;
      vctx.lineWidth = 1.4;
      vctx.strokeStyle = '#9bb4ff';
      vctx.beginPath();
      vctx.moveTo(aSp.sx, aSp.sy);
      vctx.lineTo(inSp.sx, inSp.sy);
      vctx.moveTo(aSp.sx, aSp.sy);
      vctx.lineTo(outSp.sx, outSp.sy);
      vctx.stroke();

      const drawDot = (sp, fill, hover) => {
        vctx.fillStyle = fill;
        vctx.beginPath();
        vctx.arc(sp.sx, sp.sy, hover ? 5.0 : 4.0, 0, Math.PI * 2);
        vctx.fill();
        vctx.lineWidth = hover ? 2.0 : 1.2;
        vctx.strokeStyle = hover ? '#f7fbff' : '#d7e6ff';
        vctx.stroke();
      };
      drawDot(inSp, '#7ea8ff', inHover);
      drawDot(outSp, '#8cf6a7', outHover);
      vctx.restore();
    };
    if (selectedBranch) drawBezierHandles3D({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid });
    else if (selected >= 0 && points[selected]) drawBezierHandles3D({ kind: 'main', i: selected });

    // placed props overlays
    if (placedFences.length) {
      vctx.save();
      vctx.globalAlpha = 0.8;
      vctx.strokeStyle = '#9bc2ff';
      vctx.lineWidth = 2;
      for (const f of placedFences) {
        const a = project3(f.a, eye, basis, w, h);
        const b = project3(f.b, eye, basis, w, h);
        vctx.beginPath();
        vctx.moveTo(a.sx, a.sy);
        vctx.lineTo(b.sx, b.sy);
        vctx.stroke();
      }
      vctx.restore();
    }
    if (placedTrees.length) {
      vctx.save();
      for (const t of placedTrees) {
        const q = sub(t.pos, eye);
        if (dot(q, basis.f) <= 0.04) continue;
        const p = project3(t.pos, eye, basis, w, h);
        vctx.fillStyle = '#78ffa0';
        vctx.globalAlpha = 0.95;
        vctx.beginPath();
        vctx.arc(p.sx, p.sy, 4.2, 0, Math.PI * 2);
        vctx.fill();
      }
      vctx.restore();
    }
    if (mode === 'fenceplace' && fencePlaceStart) {
      const p = project3(fencePlaceStart, eye, basis, w, h);
      vctx.save();
      vctx.strokeStyle = '#ffd36e';
      vctx.lineWidth = 2;
      vctx.globalAlpha = 0.95;
      vctx.beginPath(); vctx.arc(p.sx, p.sy, 6.5, 0, Math.PI * 2); vctx.stroke();
      vctx.restore();
    }

    // gizmo + hover highlight + ghost
    const gs = gizmoScreen(eye, basis, w, h);
    if (gs) {
      // ghost (snapped target) for X/Z
      if (gizmoGhost && (gizmoGhost.axis === 'x' || gizmoGhost.axis === 'z')) {
        const gsp = project3(gizmoGhost.pos, eye, basis, w, h);
        vctx.save();
        vctx.globalAlpha = 0.65;
        vctx.fillStyle = 'rgba(255,211,110,0.6)';
        vctx.beginPath(); vctx.arc(gsp.sx, gsp.sy, 6, 0, Math.PI * 2); vctx.fill();
        vctx.restore();
      }

      const hover = gizmoHoverAxis;
      const pick = (ax) => (ax === hover) ? 4.5 : 3;
      const alp = (ax) => (ax === hover) ? 1.0 : 0.92;

      vctx.save();
      vctx.lineCap = 'round';
      // X
      vctx.globalAlpha = alp('x');
      vctx.lineWidth = pick('x');
      vctx.strokeStyle = 'rgb(255,110,110)';
      vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.px.sx, gs.px.sy); vctx.stroke();
      // Y
      vctx.globalAlpha = alp('y');
      vctx.lineWidth = pick('y');
      vctx.strokeStyle = 'rgb(120,255,160)';
      vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.py.sx, gs.py.sy); vctx.stroke();
      // Z
      vctx.globalAlpha = alp('z');
      vctx.lineWidth = pick('z');
      vctx.strokeStyle = 'rgb(120,170,255)';
      vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.pz.sx, gs.pz.sy); vctx.stroke();
      // center dot
      vctx.globalAlpha = 1;
      vctx.fillStyle = '#ffd36e';
      vctx.beginPath(); vctx.arc(gs.center.sx, gs.center.sy, 4, 0, Math.PI * 2); vctx.fill();
      vctx.restore();
    }

      renderAxisHelper(basis, w, h);
    } catch (err) {
      showErr('3D render error:\n' + String(err && err.message ? err.message : err));
      cached = null;
    }

    requestAnimationFrame(render3D);
  }

  // 3D interactions
  view.addEventListener('contextmenu', (e) => e.preventDefault());
  view.addEventListener('dblclick', () => frame3D());

  function pickControlPoint3D(sx, sy, eye, basis, w, h, maxPix = 11) {
    let best = -1;
    let bd = maxPix;
    for (let i = 0; i < points.length; i++) {
      const q = sub(points[i].pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const p = project3(points[i].pos, eye, basis, w, h);
      const d = Math.hypot(p.sx - sx, p.sy - sy);
      if (d < bd) { bd = d; best = i; }
    }
    return best;
  }

  function bezierHandleAnchor(target) {
    if (!target) return null;
    if (target.kind === 'branch') {
      const ref = branchMidRef({ sec: target.sec, mid: target.mid });
      if (!ref?.mid) return null;
      return v3(ref.mid.x, ref.mid.y, ref.mid.z);
    }
    const p = points[target.i];
    if (!p) return null;
    return p.pos;
  }

  function bezierHandleVector(target, which) {
    if (!target) return null;
    if (target.kind === 'branch') {
      const ref = branchMidRef({ sec: target.sec, mid: target.mid });
      const m = ref?.mid;
      if (!m) return null;
      const h = which === 'in' ? m.hin : m.hout;
      return h ? { x: Number(h.x || 0), z: Number(h.z || 0) } : { x: 0, z: 0 };
    }
    const p = points[target.i];
    if (!p) return null;
    ensurePointShape(p);
    const h = which === 'in' ? p.hin : p.hout;
    return { x: Number(h.x || 0), z: Number(h.z || 0) };
  }

  function bezierHandleWorldPoint(target, which) {
    if (!target) return null;
    if (target.kind === 'branch') return branchHandleWorld({ sec: target.sec, mid: target.mid }, which);
    if (!Number.isInteger(target.i)) return null;
    return handleWorld(target.i, which);
  }

  function sameBezierHandle(a, b) {
    if (a?.target) a = { ...a.target, which: a.which };
    if (b?.target) b = { ...b.target, which: b.which };
    if (!a || !b) return false;
    if ((a.kind || 'main') !== (b.kind || 'main')) return false;
    if (a.which !== b.which) return false;
    if ((a.kind || 'main') === 'branch') return a.sec === b.sec && a.mid === b.mid;
    return a.i === b.i;
  }

  function pickBezierHandle3D(sx, sy, eye, basis, w, h, maxPix = 12) {
    let best = null;
    let bd = maxPix;
    const candidates = [];
    if (selectedBranch) {
      candidates.push({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'in' });
      candidates.push({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'out' });
    } else if (selected >= 0 && points[selected]) {
      candidates.push({ kind: 'main', i: selected, which: 'in' });
      candidates.push({ kind: 'main', i: selected, which: 'out' });
    }
    for (const c of candidates) {
      const wp = bezierHandleWorldPoint(c, c.which);
      if (!wp) continue;
      const q = sub(wp, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const sp = project3(wp, eye, basis, w, h);
      const d = Math.hypot(sp.sx - sx, sp.sy - sy);
      if (d < bd) {
        bd = d;
        best = c;
      }
    }
    return best;
  }

  function screenRay3D(sx, sy, w, h, eye, basis) {
    const fov = 60 * Math.PI / 180;
    const tan = Math.tan(fov * 0.5);
    const aspect = w / h;
    const nx = (sx / w) * 2 - 1;
    const ny = 1 - (sy / h) * 2;
    const dir = norm(add(add(basis.f, mul(basis.r, nx * aspect * tan)), mul(basis.u, ny * tan)));
    return { o: eye, d: dir };
  }

  function rayTriHit(o, d, a, b, c) {
    const eps = 1e-6;
    const ab = sub(b, a);
    const ac = sub(c, a);
    const p = cross(d, ac);
    const det = dot(ab, p);
    if (Math.abs(det) < eps) return null;
    const invDet = 1 / det;
    const tvec = sub(o, a);
    const u = dot(tvec, p) * invDet;
    if (u < 0 || u > 1) return null;
    const q = cross(tvec, ab);
    const v = dot(d, q) * invDet;
    if (v < 0 || (u + v) > 1) return null;
    const t = dot(ac, q) * invDet;
    if (t <= eps) return null;
    return { t, p: add(o, mul(d, t)) };
  }

  function pickPlacementPoint3D(sx, sy, w, h) {
    const m = getMesh();
    if (!m) return null;
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const ray = screenRay3D(sx, sy, w, h, eye, basis);

    const castKinds = (kinds) => {
      let best = null;
      for (const t of m.tris) {
        if (!kinds.has(t.kind)) continue;
        const hit = rayTriHit(ray.o, ray.d, t.a, t.b, t.c);
        if (!hit) continue;
        if (!best || hit.t < best.t) best = hit;
      }
      return best ? best.p : null;
    };

    const pTerrain = castKinds(new Set(['terrain']));
    if (pTerrain) return pTerrain;
    const pGrass = castKinds(new Set(['grass']));
    if (pGrass) return pGrass;

    if (Math.abs(ray.d.y) > 1e-6) {
      const t = (0 - ray.o.y) / ray.d.y;
      if (t > 0) return add(ray.o, mul(ray.d, t));
    }
    return null;
  }

  view.addEventListener('mousemove', (e) => {
    // hover axis + cursor
    const rect = view.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const r2 = viewWrap.getBoundingClientRect();
    const w = r2.width, h = r2.height;
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const gs = gizmoScreen(eye, basis, w, h);

    if (bezier3DDrag) {
      const anchor = bezierHandleAnchor(bezier3DDrag.target);
      const vec0 = { x: bezier3DDrag.startHX, z: bezier3DDrag.startHZ };
      if (!anchor) {
        bezier3DDrag = null;
      } else {
        let hx = vec0.x;
        let hz = vec0.z;
        const ray = screenRay3D(sx, sy, w, h, eye, basis);
        if (Math.abs(ray.d.y) > 1e-6) {
          const tPlane = (anchor.y - ray.o.y) / ray.d.y;
          if (tPlane > 1e-6) {
            const hit = add(ray.o, mul(ray.d, tPlane));
            hx = hit.x - anchor.x;
            hz = hit.z - anchor.z;
          } else {
            const mdx = sx - bezier3DDrag.startMouse.x;
            const mdy = sy - bezier3DDrag.startMouse.y;
            const pp = worldPerPixel(Math.max(0.2, bezier3DDrag.depth || 1), h);
            const drag = add(mul(basis.r, mdx * pp), mul(basis.u, -mdy * pp));
            hx += drag.x;
            hz += drag.z;
          }
        }
        setHandle(bezier3DDrag.target, bezier3DDrag.which, hx, hz, {
          rotateOnly: e.altKey,
          breakMirror: e.shiftKey,
        });
        bezier3DHover = { ...bezier3DDrag.target, which: bezier3DDrag.which };
        syncSelectedUI();
        cached = null;
        view.style.cursor = 'grabbing';
        return;
      }
    }

    if (gizmo.active && selected >= 0) {
      const axisPt = gizmo.startAxisPt;
      const c = gizmo.startCenter;
      const vx = axisPt.sx - c.sx, vy = axisPt.sy - c.sy;
      const vv = vx * vx + vy * vy || 1;
      const mdx = sx - gizmo.startMouse.x, mdy = sy - gizmo.startMouse.y;
      const t = (mdx * vx + mdy * vy) / vv;
      const delta = t * gizmo.startSize;

      const p = points[selected].pos;
      if (gizmo.axis === 'x') {
        const x = gizmo.startPos.x + delta;
        p.x = snapRoadXZ(x, p.z).x;
        gizmoGhost = { axis: 'x', pos: v3(p.x, p.y, p.z) };
      } else if (gizmo.axis === 'y') {
        p.y = snapRoadY(gizmo.startPos.y + delta);
        gizmoGhost = null;
      } else if (gizmo.axis === 'z') {
        const z = gizmo.startPos.z + delta;
        p.z = snapRoadXZ(p.x, z).z;
        gizmoGhost = { axis: 'z', pos: v3(p.x, p.y, p.z) };
      } else if (gizmo.axis === 'free') {
        const mdx = sx - gizmo.startMouse.x;
        const mdy = sy - gizmo.startMouse.y;
        const pp = worldPerPixel(Math.max(0.2, gizmo.depth), h);
        const drag = add(mul(basis.r, mdx * pp), mul(basis.u, -mdy * pp));
        const sp = snapRoadXYZ(gizmo.startPos.x + drag.x, gizmo.startPos.y + drag.y, gizmo.startPos.z + drag.z);
        p.x = sp.x;
        p.y = sp.y;
        p.z = sp.z;
        gizmoGhost = { axis: 'free', pos: v3(p.x, p.y, p.z) };
      }
      syncSelectedUI();
      cached = null;
      view.style.cursor = 'grabbing';
      return;
    }

    bezier3DHover = pickBezierHandle3D(sx, sy, eye, basis, w, h, 12);
    if (bezier3DHover) {
      gizmoHoverAxis = null;
      view.style.cursor = 'grab';
    } else {
      gizmoHoverAxis = hitGizmoAxis(gs, sx, sy);
      if (gizmoHoverAxis) view.style.cursor = 'grab';
    }
    if (bezier3DHover || gizmoHoverAxis) {
      if (!(isLookL || isLookR || isPan3 || isOrbitSel)) return;
    }
    else if (isLookL || isLookR || isPan3 || isOrbitSel) view.style.cursor = 'grabbing';
    else if (mode === 'treeplace' || mode === 'fenceplace') view.style.cursor = 'crosshair';
    else view.style.cursor = 'default';

    if (isOrbitSel && last3 && selected >= 0 && points[selected]) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      const pivot = points[selected].pos;
      const off = sub(camEye, pivot);
      const rxy = Math.max(1e-3, Math.hypot(off.x, off.z));
      let ay = Math.atan2(off.z, off.x);
      let ap = Math.atan2(off.y, rxy);
      ay -= dx * 0.008;
      ap = clamp(ap - dy * 0.008, -1.43, 1.43);
      const dist = Math.max(0.3, len(off));
      const cx = Math.cos(ay) * Math.cos(ap), sz = Math.sin(ay) * Math.cos(ap), sy = Math.sin(ap);
      camEye = add(pivot, v3(cx * dist, sy * dist, sz * dist));
      setCameraLookAt(camEye, pivot);
      last3 = { x: e.clientX, y: e.clientY };
      return;
    }

    if ((isLookR || isLookL) && last3) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      if (Math.hypot(dx, dy) > 1.3) lmbMoved = lmbMoved || isLookL;
      camYaw -= dx * 0.008;
      camPitch = clamp(camPitch - dy * 0.008, -1.48, 1.48);
      last3 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (isPan3 && last3) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      if (Math.hypot(dx, dy) > 1.3) mmbMoved = true;
      const depthRef = Math.max(6, len(sub(camEye, selected >= 0 && points[selected] ? points[selected].pos : add(camEye, basis.f))));
      const s = worldPerPixel(depthRef, h) * 1.25;
      camEye = add(camEye, add(mul(basis.r, -dx * s), mul(basis.u, dy * s)));
      last3 = { x: e.clientX, y: e.clientY };
    }
  });

  view.addEventListener('mousedown', (e) => {
    const rect = view.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const r2 = viewWrap.getBoundingClientRect();
    const w = r2.width, h = r2.height;
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const gs = gizmoScreen(eye, basis, w, h);

    if (e.button === 0) {
      if (mode === 'treeplace' || mode === 'fenceplace') {
        const hit = pickPlacementPoint3D(sx, sy, w, h);
        if (!hit) return;
        if (mode === 'treeplace') {
          pushUndo();
          placedTrees.push({ pos: v3(hit.x, hit.y, hit.z), scale: 1 });
          cached = null;
          return;
        }
        if (!fencePlaceStart) {
          fencePlaceStart = v3(hit.x, hit.y, hit.z);
          return;
        }
        const d = Math.hypot(hit.x - fencePlaceStart.x, hit.z - fencePlaceStart.z);
        if (d >= 0.8) {
          pushUndo();
          placedFences.push({ a: v3(fencePlaceStart.x, fencePlaceStart.y, fencePlaceStart.z), b: v3(hit.x, hit.y, hit.z) });
          fencePlaceStart = v3(hit.x, hit.y, hit.z); // chain placement
          cached = null;
        }
        return;
      }

      const bezHit = pickBezierHandle3D(sx, sy, eye, basis, w, h, 12);
      if (bezHit) {
        const hv = bezierHandleVector(bezHit, bezHit.which);
        const an = bezierHandleAnchor(bezHit);
        if (!hv) return;
        if (!an) return;
        pushUndo();
        bezier3DDrag = {
          target: bezHit.kind === 'branch'
            ? { kind: 'branch', sec: bezHit.sec, mid: bezHit.mid }
            : { kind: 'main', i: bezHit.i },
          which: bezHit.which,
          depth: project3(an, eye, basis, w, h).z,
          startMouse: { x: sx, y: sy },
          startHX: hv.x,
          startHZ: hv.z,
        };
        bezier3DHover = { ...bezHit };
        view.style.cursor = 'grabbing';
        return;
      }

      const hit = hitGizmoAxis(gs, sx, sy);
      if (hit && selected >= 0) {
        pushUndo();
        bezier3DDrag = null;
        gizmo.active = true;
        gizmo.axis = hit;
        gizmo.startMouse = { x: sx, y: sy };
        gizmo.startPos = v3(points[selected].pos.x, points[selected].pos.y, points[selected].pos.z);
        gizmo.depth = gs ? gs.depth : 1;
        gizmo.startCenter = gs.center;
        gizmo.startSize = gs.size;
        gizmo.startAxisPt = hit === 'x' ? gs.px : (hit === 'y' ? gs.py : (hit === 'z' ? gs.pz : gs.px));
        gizmoGhost = null;
        view.style.cursor = 'grabbing';
        return;
      }
      isLookL = true;
      lmbMoved = false;
      last3 = { x: e.clientX, y: e.clientY };
      pickOnRelease = pickControlPoint3D(sx, sy, eye, basis, w, h, 12);
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 2 && mode === 'fenceplace' && fencePlaceStart && !e.altKey) {
      fencePlaceStart = null;
      return;
    }

    if (e.button === 2 && e.altKey && selected >= 0 && points[selected]) {
      isOrbitSel = true;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 2) {
      isLookR = true;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 1 || isSpace()) {
      isPan3 = true;
      mmbMoved = false;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }
  });

  window.addEventListener('mouseup', () => {
    if (bezier3DDrag) {
      bezier3DDrag = null;
      cached = null;
    }
    if (gizmo.active) {
      gizmo.active = false;
      gizmo.axis = null;
      gizmoGhost = null;
      cached = null;
    }
    if (isLookL && !lmbMoved && pickOnRelease >= 0) {
      selectOnly(pickOnRelease);
      syncSelectedUI();
    }
    if (isPan3 && !mmbMoved) camMoveSpeed = camSpeedBase;
    isLookL = false;
    isLookR = false;
    isOrbitSel = false;
    isPan3 = false;
    last3 = null;
    lmbMoved = false;
    mmbMoved = false;
    pickOnRelease = -1;
  });

  view.addEventListener('mouseleave', () => {
    if (!gizmo.active && !bezier3DDrag && !isLookL && !isLookR && !isPan3 && !isOrbitSel) {
      bezier3DHover = null;
      gizmoHoverAxis = null;
      view.style.cursor = 'default';
    }
  });

  view.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (isLookR || (e.buttons & 2)) {
      if (e.deltaY < 0) camMoveSpeed = clamp(camMoveSpeed * 1.14, 1, 180);
      else camMoveSpeed = clamp(camMoveSpeed / 1.14, 1, 180);
      return;
    }
    // keep wheel dolly for convenience when not in RMB-speed mode
    const basis = lookAtBasis(camEye, add(camEye, camForward()));
    camEye = add(camEye, mul(basis.f, -e.deltaY * 0.018));
  }, { passive: false });

  // ---------- 2D render ----------
  function render2D() {
    const r = editWrap.getBoundingClientRect();
    const w = r.width, h = r.height;
    const s = num('isoScale');
    const org = origin2();

    ectx.clearRect(0, 0, w, h);
    ectx.fillStyle = '#0b0f19';
    ectx.fillRect(0, 0, w, h);

    if (chk('showGrid')) {
      ectx.save();
      ectx.globalAlpha = 0.2;
      ectx.strokeStyle = '#24345f';
      ectx.lineWidth = 1;
      const gridStep = Math.max(0.5, num('grid'));
      const span = 80;
      for (let i = -span; i <= span; i += gridStep) {
        const a0 = screenFromWorld2(v3(i, 0, -span), org, s);
        const a1 = screenFromWorld2(v3(i, 0, span), org, s);
        const b0 = screenFromWorld2(v3(-span, 0, i), org, s);
        const b1 = screenFromWorld2(v3(span, 0, i), org, s);
        ectx.beginPath(); ectx.moveTo(a0.x, a0.y); ectx.lineTo(a1.x, a1.y); ectx.stroke();
        ectx.beginPath(); ectx.moveTo(b0.x, b0.y); ectx.lineTo(b1.x, b1.y); ectx.stroke();
      }
      ectx.restore();
    }

    const net = sampleRoadNetwork();
    if (net.main.length > 1) {
      ectx.save();
      ectx.strokeStyle = '#ffd36e';
      ectx.lineWidth = 2;
      ectx.beginPath();
      for (let i = 0; i < net.main.length; i++) {
        const sp = screenFromWorld2(net.main[i].pos, org, s);
        if (i === 0) ectx.moveTo(sp.x, sp.y); else ectx.lineTo(sp.x, sp.y);
      }
      ectx.stroke();
      ectx.restore();
    }
    if (net.branches.length) {
      ectx.save();
      ectx.strokeStyle = '#78aaff';
      ectx.lineWidth = 2;
      for (const bs of net.branches) {
        if (bs.length < 2) continue;
        ectx.beginPath();
        for (let i = 0; i < bs.length; i++) {
          const sp = screenFromWorld2(bs[i].pos, org, s);
          if (i === 0) ectx.moveTo(sp.x, sp.y); else ectx.lineTo(sp.x, sp.y);
        }
        ectx.stroke();
      }
      ectx.restore();
    }
    sanitizeBranchSections();
    sanitizeBranchSelection();
    for (let si = 0; si < branchSections.length; si++) {
      const mids = branchSections[si]?.mids || [];
      for (let mi = 0; mi < mids.length; mi++) {
        const m = mids[mi];
        const sp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const key = branchSelKey(si, mi);
        const isSel = selectedBranchSet.has(key) || (selectedBranch && selectedBranch.sec === si && selectedBranch.mid === mi);
        ectx.beginPath();
        ectx.arc(sp.x, sp.y, isSel ? 6.2 : 5, 0, Math.PI * 2);
        ectx.fillStyle = isSel ? '#7ed0ff' : '#9ec2ff';
        ectx.fill();
        ectx.strokeStyle = '#0b0f19';
        ectx.lineWidth = isSel ? 1.35 : 1;
        ectx.stroke();
      }
    }

    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (ref) {
        const m = ref.mid;
        const psp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const hi = branchHandleWorld(selectedBranch, 'in');
        const ho = branchHandleWorld(selectedBranch, 'out');
        if (hi && ho) {
          const hInSp = screenFromWorld2(hi, org, s);
          const hOutSp = screenFromWorld2(ho, org, s);
          ectx.save();
          ectx.strokeStyle = 'rgba(163,208,255,0.9)';
          ectx.lineWidth = 1;
          ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hInSp.x, hInSp.y); ectx.stroke();
          ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hOutSp.x, hOutSp.y); ectx.stroke();
          ectx.fillStyle = '#78ffa0';
          ectx.fillRect(hInSp.x - 4, hInSp.y - 4, 8, 8);
          ectx.fillStyle = '#78aaff';
          ectx.fillRect(hOutSp.x - 4, hOutSp.y - 4, 8, 8);
          ectx.restore();
        }
      }
    }

    if (selected >= 0 && points[selected]) {
      const p = points[selected];
      const psp = screenFromWorld2(p.pos, org, s);
      const hin = handleWorld(selected, 'in');
      const hout = handleWorld(selected, 'out');
      const hInSp = screenFromWorld2(hin, org, s);
      const hOutSp = screenFromWorld2(hout, org, s);

      ectx.save();
      ectx.strokeStyle = 'rgba(183,197,255,0.85)';
      ectx.lineWidth = 1;
      ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hInSp.x, hInSp.y); ectx.stroke();
      ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hOutSp.x, hOutSp.y); ectx.stroke();

      ectx.fillStyle = '#78ffa0';
      ectx.fillRect(hInSp.x - 4, hInSp.y - 4, 8, 8);
      ectx.fillStyle = '#78aaff';
      ectx.fillRect(hOutSp.x - 4, hOutSp.y - 4, 8, 8);
      ectx.restore();
    }

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const sp = screenFromWorld2(p.pos, org, s);
      const isPrimary = i === selected;
      const isMulti = selectedSet.has(i);
      ectx.beginPath();
      ectx.arc(sp.x, sp.y, isPrimary ? 7 : (isMulti ? 6 : 5), 0, Math.PI * 2);
      ectx.fillStyle = isPrimary ? '#ffd36e' : (isMulti ? '#ffdba0' : '#e9ecf6');
      ectx.fill();
      if (isPrimary || isMulti) {
        ectx.strokeStyle = '#0b0f19';
        ectx.lineWidth = isPrimary ? 1.5 : 1.2;
        ectx.stroke();
      }
    }

    // tool previews
    if (mode === 'ysplit' && ySplitTool.phase === 1 && ySplitTool.startIdx >= 0 && points[ySplitTool.startIdx]) {
      const sp = screenFromWorld2(points[ySplitTool.startIdx].pos, org, s);
      ectx.save();
      ectx.strokeStyle = '#78ffa0';
      ectx.lineWidth = 2;
      ectx.setLineDash([5, 4]);
      ectx.beginPath(); ectx.arc(sp.x, sp.y, 12, 0, Math.PI * 2); ectx.stroke();
      ectx.setLineDash([]);
      ectx.restore();
    }
    if (mode === 'join' && joinTool.phase === 1 && joinTool.startIdx >= 0 && points[joinTool.startIdx]) {
      const sp = screenFromWorld2(points[joinTool.startIdx].pos, org, s);
      ectx.save();
      ectx.strokeStyle = '#78aaff';
      ectx.lineWidth = 2;
      ectx.setLineDash([5, 4]);
      ectx.beginPath(); ectx.arc(sp.x, sp.y, 12, 0, Math.PI * 2); ectx.stroke();
      ectx.setLineDash([]);
      ectx.restore();
    }
    sanitizeSplitEnds();
    if (splitEnds.length) {
      ectx.save();
      ectx.strokeStyle = '#ff6e6e';
      ectx.lineWidth = 2;
      for (const idx of splitEnds) {
        const p = points[idx];
        if (!p) continue;
        const sp = screenFromWorld2(p.pos, org, s);
        ectx.beginPath();
        ectx.arc(sp.x, sp.y, 9, 0, Math.PI * 2);
        ectx.stroke();
      }
      ectx.restore();
    }
    if (mode === 'roundabout' && roundTool.phase >= 1 && roundTool.center && roundTool.radius > 0.5) {
      const cp = screenFromWorld2(v3(roundTool.center.x, points[roundTool.startIdx]?.pos.y || 0, roundTool.center.z), org, s);
      const rp = Math.max(6, roundTool.radius * s * 0.95);
      ectx.save();
      ectx.strokeStyle = '#78aaff';
      ectx.lineWidth = 2;
      ectx.setLineDash([7, 4]);
      ectx.beginPath(); ectx.arc(cp.x, cp.y, rp, 0, Math.PI * 2); ectx.stroke();
      if (roundTool.previewExit) {
        const ep = screenFromWorld2(v3(roundTool.previewExit.x, points[roundTool.startIdx]?.pos.y || 0, roundTool.previewExit.z), org, s);
        ectx.setLineDash([]);
        ectx.strokeStyle = '#ffd36e';
        ectx.beginPath(); ectx.moveTo(cp.x, cp.y); ectx.lineTo(ep.x, ep.y); ectx.stroke();
      }
      ectx.setLineDash([]);
      ectx.restore();
    }

    requestAnimationFrame(render2D);
  }

  // ---------- 2D interactions ----------
  edit.addEventListener('contextmenu', (e) => e.preventDefault());

  edit.addEventListener('mousedown', (e) => {
    const rect = edit.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const s = num('isoScale');
    const org = origin2();

    if (isSpace() || e.shiftKey || e.button === 1) {
      isPanning2 = true;
      last2 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (e.button !== 0) return;
    const hitPoint = nearestPointScreen(sx, sy, org, s, 12);
    const hitBranchMid = nearestBranchMidpointScreen(sx, sy, org, s, 10);

    if (mode === 'ysplit') {
      if (ySplitTool.phase === 0) {
        if (hitPoint < 0) {
          const curveHit = nearestCurveHitScreen(sx, sy, org, s, 10);
          if (!curveHit) return;
          pushUndo();
          const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
          const prevIdx = (curveHit.insertIndex - 1 + points.length) % points.length;
          const nextIdx = curveHit.insertIndex % points.length;
          const prevPos = points[prevIdx]?.pos || curveHit.pos;
          const nextPos = points[nextIdx]?.pos || curveHit.pos;
          const hIn = Math.max(0.05, len(sub(curveHit.pos, prevPos)) * 0.30);
          const hOut = Math.max(0.05, len(sub(nextPos, curveHit.pos)) * 0.30);
          const np = {
            pos: v3(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z),
            bank: curveHit.bank,
            node: 'smooth',
            hin: { x: -tan.x * hIn, z: -tan.z * hIn },
            hout: { x: tan.x * hOut, z: tan.z * hOut },
          };
          points.splice(curveHit.insertIndex, 0, np);
          remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
          const idx = curveHit.insertIndex;
          smoothNeighborhood([idx - 1, idx, idx + 1]);
          selectOnly(idx);
          ySplitTool.phase = 1;
          ySplitTool.startIdx = idx;
          ySplitTool.action = 'split';
          syncSelectedUI();
          cached = null;
          return;
        }
        ySplitTool.phase = 1;
        ySplitTool.startIdx = hitPoint;
        ySplitTool.action = (e.ctrlKey || e.metaKey) ? 'trim' : (e.altKey ? 'join' : 'split');
        selectOnly(hitPoint);
        syncSelectedUI();
        return;
      }
      if (ySplitTool.startIdx >= 0) {
        pushUndo();
        if (ySplitTool.action === 'split' && ySplitTool.startIdx === hitPoint) splitPointForFork(hitPoint);
        else if (ySplitTool.startIdx !== hitPoint) {
          if (ySplitTool.action === 'trim') trimSection(ySplitTool.startIdx, hitPoint);
          else if (ySplitTool.action === 'join') joinSection(ySplitTool.startIdx, hitPoint);
          else addBranchSection(ySplitTool.startIdx, hitPoint, 'fork');
        }
        ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
        syncSelectedUI();
        cached = null;
      }
      return;
    }

    if (mode === 'join') {
      if (hitPoint < 0) return;
      if (joinTool.phase === 0) {
        joinTool.phase = 1;
        joinTool.startIdx = hitPoint;
        selectOnly(hitPoint);
        syncSelectedUI();
        return;
      }
      if (joinTool.startIdx >= 0 && joinTool.startIdx !== hitPoint) {
        pushUndo();
        joinSection(joinTool.startIdx, hitPoint);
        joinTool = { phase: 0, startIdx: -1 };
        syncSelectedUI();
        cached = null;
      }
      return;
    }

    if (mode === 'roundabout') {
      if (roundTool.phase === 0) {
        if (hitPoint < 0) return;
        roundTool.phase = 1;
        roundTool.startIdx = hitPoint;
        roundTool.isSizing = true;
        selectOnly(hitPoint);
        syncSelectedUI();
        const S = points[hitPoint].pos;
        const T = tangentAtIndex(hitPoint);
        const N = norm(v3(-T.z, 0, T.x));
        const r0 = Math.max(3.2, num('roadWidth') * 2.45);
        roundTool.radius = r0;
        roundTool.dir = 1;
        const c0 = add(S, mul(N, r0));
        const c0s = snapRoadXZ(c0.x, c0.z);
        roundTool.center = v3(c0s.x, S.y, c0s.z);
        roundTool.previewExit = null;
        return;
      }
      if (roundTool.phase === 2 && roundTool.center) {
        const sy0 = points[roundTool.startIdx]?.pos.y || 0;
        const wp = worldFromScreenXZWithY(sx, sy, org, s, sy0);
        const ex = snapRoadXZ(wp.x, wp.z);
        const exit = { x: ex.x, z: ex.z };
        const exitAng = Math.atan2(exit.z - roundTool.center.z, exit.x - roundTool.center.x);
        pushUndo();
        insertRoundaboutAt(roundTool.startIdx, roundTool.center, roundTool.radius, exitAng, roundTool.dir);
        roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
        setTool('draw');
        syncSelectedUI();
        cached = null;
      }
      return;
    }

    const hitHandle = nearestHandle2D(sx, sy, org, s, 10);
    if (hitHandle) {
      pushUndo();
      dragHandle = hitHandle;
      return;
    }

    if (hitBranchMid) {
      const toggleMulti = e.shiftKey || e.ctrlKey || e.metaKey;
      if (toggleMulti) toggleBranchSelection(hitBranchMid.sec, hitBranchMid.mid);
      else if (!selectedBranchSet.has(branchSelKey(hitBranchMid.sec, hitBranchMid.mid)) || selectedBranchSet.size <= 1) selectBranchMidpoint(hitBranchMid.sec, hitBranchMid.mid);
      syncSelectedUI();
      if (mode === 'move' || mode === 'draw') {
        pushUndo();
        dragBranch = { sec: hitBranchMid.sec, mid: hitBranchMid.mid };
        const ref = branchSections[hitBranchMid.sec]?.mids?.[hitBranchMid.mid];
        const active = collectActiveBranchSelection({ sec: hitBranchMid.sec, mid: hitBranchMid.mid });
        dragBranchGroupOffsets = ref ? active.map((a) => {
          const m = branchSections[a.sec]?.mids?.[a.mid];
          return m ? { sec: a.sec, mid: a.mid, dx: m.x - ref.x, dz: m.z - ref.z } : null;
        }).filter(Boolean) : null;
      }
      return;
    }

    if (mode === 'erase') {
      if (hitPoint >= 0) {
        pushUndo();
        points.splice(hitPoint, 1);
        remapSplitEndsForSplice(hitPoint, 1, 0);
        selectOnly(-1);
        syncSelectedUI();
        cached = null;
      } else {
        const hitBranchCurve = nearestBranchCurveHitScreen(sx, sy, org, s, 10);
        if (hitBranchCurve) {
          pushUndo();
          branchSections.splice(hitBranchCurve.sec, 1);
          sanitizeBranchSections();
          selectedBranch = null;
          selectedBranchSet.clear();
          syncSelectedUI();
          cached = null;
        }
      }
      return;
    }

    if (hitPoint >= 0) {
      const toggleMulti = e.shiftKey || e.ctrlKey || e.metaKey;
      if (toggleMulti) {
        toggleSelection(hitPoint);
        syncSelectedUI();
        return;
      }
      if (!selectedSet.has(hitPoint) || selectedSet.size <= 1) selectOnly(hitPoint);
      syncSelectedUI();
      if (mode === 'move' || mode === 'draw') {
        pushUndo();
        dragIndex = hitPoint;
        const active = collectActiveSelection(hitPoint);
        dragGroupOffsets = active.map((idx) => ({
          idx,
          dx: points[idx].pos.x - points[hitPoint].pos.x,
          dz: points[idx].pos.z - points[hitPoint].pos.z,
        }));
      }
      return;
    }

    if (mode === 'draw') {
      pushUndo();
      const curveHit = nearestCurveHitScreen(sx, sy, org, s, 10);
      if (curveHit) {
        const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
        const snapped = snapRoadXYZ(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z);
        const insPos = v3(snapped.x, snapped.y, snapped.z);
        const prevIdx = (curveHit.insertIndex - 1 + points.length) % points.length;
        const nextIdx = curveHit.insertIndex % points.length;
        const prevPos = points[prevIdx]?.pos || insPos;
        const nextPos = points[nextIdx]?.pos || insPos;
        const hIn = Math.max(0.05, len(sub(insPos, prevPos)) * 0.30);
        const hOut = Math.max(0.05, len(sub(nextPos, insPos)) * 0.30);
        const np = {
          pos: insPos,
          bank: curveHit.bank,
          node: 'smooth',
          hin: { x: -tan.x * hIn, z: -tan.z * hIn },
          hout: { x: tan.x * hOut, z: tan.z * hOut },
        };
        points.splice(curveHit.insertIndex, 0, np);
        remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
        const idx = curveHit.insertIndex;
        smoothNeighborhood([idx - 1, idx, idx + 1]);
        selectOnly(idx);
      } else {
        const branchHit = nearestBranchCurveHitScreen(sx, sy, org, s, 10);
        if (branchHit) {
          insertBranchMidpoint(branchHit.sec, branchHit.u, branchHit.pos, branchHit.tan);
        } else {
          const wp = worldFromScreenXZWithY(sx, sy, org, s, 0);
          const snap = snapRoadXYZ(wp.x, 0, wp.z);
          points.push({
            pos: v3(snap.x, snap.y, snap.z),
            bank: 0,
            node: 'smooth',
            hin: { x: 0, z: 0 },
            hout: { x: 0, z: 0 },
          });
          const idx = points.length - 1;
          smoothNeighborhood([idx - 1, idx]);
          selectOnly(idx);
        }
      }
      syncSelectedUI();
      cached = null;
    }
  });

  edit.addEventListener('mousemove', (e) => {
    const rect = edit.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const s = num('isoScale');
    const org = origin2();

    if (isPanning2 && last2) {
      pan2.x += e.clientX - last2.x;
      pan2.y += e.clientY - last2.y;
      last2 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (mode === 'roundabout' && roundTool.phase >= 1 && roundTool.startIdx >= 0 && points[roundTool.startIdx]) {
      const S = points[roundTool.startIdx].pos;
      const wp = worldFromScreenXZWithY(sx, sy, org, s, S.y);
      const v = v3(wp.x - S.x, 0, wp.z - S.z);
      if (roundTool.isSizing || roundTool.phase === 1) {
        const T = tangentAtIndex(roundTool.startIdx);
        const N = norm(v3(-T.z, 0, T.x));
        const sign = dot(v, N) >= 0 ? 1 : -1;
        const r = clamp(Math.hypot(v.x, v.z), Math.max(3.2, num('roadWidth') * 2.05), 45);
        roundTool.radius = r;
        roundTool.dir = sign;
        const c = add(S, mul(N, sign * r));
        const cs = snapRoadXZ(c.x, c.z);
        roundTool.center = v3(cs.x, S.y, cs.z);
        roundTool.previewExit = null;
      } else if (roundTool.phase === 2 && roundTool.center) {
        const ex = snapRoadXZ(wp.x, wp.z);
        roundTool.previewExit = { x: ex.x, z: ex.z };
      }
      return;
    }

    if (dragIndex !== null && points[dragIndex]) {
      const p = points[dragIndex];
      const wp = worldFromScreenXZWithY(sx, sy, org, s, p.pos.y);
      const sp = snapRoadXZ(wp.x, wp.z);
      if (dragGroupOffsets && dragGroupOffsets.length > 1) {
        for (const off of dragGroupOffsets) {
          const tp = points[off.idx];
          if (!tp) continue;
          const sn = snapRoadXZ(sp.x + off.dx, sp.z + off.dz);
          tp.pos.x = sn.x;
          tp.pos.z = sn.z;
        }
      } else {
        p.pos.x = sp.x;
        p.pos.z = sp.z;
      }
      cached = null;
      return;
    }

    if (dragBranch) {
      const sec = branchSections[dragBranch.sec];
      const mid = sec?.mids?.[dragBranch.mid];
      if (mid) {
        const wp = worldFromScreenXZWithY(sx, sy, org, s, mid.y);
        const sp = snapRoadXZ(wp.x, wp.z);
        if (dragBranchGroupOffsets && dragBranchGroupOffsets.length > 1) {
          for (const off of dragBranchGroupOffsets) {
            const m = branchSections[off.sec]?.mids?.[off.mid];
            if (!m) continue;
            const sn = snapRoadXZ(sp.x + off.dx, sp.z + off.dz);
            m.x = sn.x;
            m.z = sn.z;
          }
        } else {
          mid.x = sp.x;
          mid.z = sp.z;
        }
        cached = null;
      }
      return;
    }

    if (dragHandle) {
      let p = null;
      if (dragHandle.kind === 'branch') {
        const ref = branchMidRef({ sec: dragHandle.sec, mid: dragHandle.mid });
        p = ref ? { x: ref.mid.x, y: ref.mid.y, z: ref.mid.z } : null;
      } else {
        const mp = points[dragHandle.i];
        p = mp ? { x: mp.pos.x, y: mp.pos.y, z: mp.pos.z } : null;
      }
      if (!p) return;
      const wp = worldFromScreenXZWithY(sx, sy, org, s, p.y);
      const hx = wp.x - p.x;
      const hz = wp.z - p.z;
      setHandle(dragHandle, dragHandle.which, hx, hz, {
        rotateOnly: e.altKey,
        breakMirror: e.shiftKey,
      });
      cached = null;
    }
  });

  window.addEventListener('mouseup', () => {
    if (mode === 'roundabout' && roundTool.isSizing) {
      roundTool.isSizing = false;
      if (roundTool.phase === 1 && roundTool.radius > 0.5) roundTool.phase = 2;
    }
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    isPanning2 = false;
    last2 = null;
  });

  edit.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.altKey && (selectedBranchSet.size || selectedBranch)) {
      applyHeightDeltaToBranchSelection(-e.deltaY * 0.01);
      syncSelectedUI();
      cached = null;
      return;
    }
    if (e.altKey && (selectedSet.size || (selected >= 0 && points[selected]))) {
      applyHeightDeltaToMainSelection(-e.deltaY * 0.01);
      syncSelectedUI();
      cached = null;
      return;
    }
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const z = clamp(num('isoScale') * zoomFactor, 0.02, 240);
    $('isoScale').value = z.toFixed(2);
    updateLabels();
  }, { passive: false });

  // ---------- boot ----------
  smoothAllPointHandles();
  syncSelectedUI();
  frame3D();
  render2D();
  render3D();

  // tiny sanity checks
  console.assert(typeof meshesToOBJ === 'function', 'meshesToOBJ exists');
  console.assert(Array.isArray(points), 'points is array');
})();
</script>
</body>
</html>
