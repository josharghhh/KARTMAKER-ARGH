<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ARGH Track Generator • ARGHIO KART TOOLS V2</title>
  <style>
    :root{--bg:#0b0f19;--ink:#e9ecf6;--muted:#aab4d4;--btn:#1b2440;--btn2:#151c32;--accent:#7aa2ff;--gold:#ffd36e;--red:#ff6e6e;--grn:#78ffa0;--blu:#78aaff;--split-l:1.05fr;--split-r:1.05fr;--dock-w:clamp(320px,30vw,430px);--bottom-ui-h:74px}
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    body{margin:0;background:var(--bg);color:var(--ink);padding-bottom:calc(var(--bottom-ui-h) + 20px)}
    .wrap{max-width:1500px;margin:0 auto;padding:14px;display:grid;gap:12px;grid-template-columns:1fr;align-items:start}
    @media(min-width:1200px){.wrap{grid-template-columns:minmax(0,var(--split-l)) 8px minmax(0,var(--split-r)) minmax(320px,0.8fr)}}
    .card{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:18px;overflow:hidden;min-height:520px}
    .hidden{display:none!important}
    .splitter{display:none}
    @media(min-width:1200px){
      .splitter{display:block;cursor:col-resize;position:sticky;top:12px;height:calc(100vh - 24px);border-radius:999px;background:rgba(122,162,255,0.22);border:1px solid rgba(255,255,255,0.2)}
      .splitter::after{content:'';position:absolute;left:50%;top:12px;bottom:12px;width:2px;transform:translateX(-50%);background:rgba(255,255,255,0.6);border-radius:2px}
      #editCard,#viewCard{position:sticky;top:14px;height:calc(100vh - 24px - var(--bottom-ui-h));min-height:560px}
      #editCard .canvasWrap,#viewCard .canvasWrap{height:auto;min-height:340px}
    }
    .canvasWrap{position:relative;height:74vh;min-height:620px}
    #editCard,#viewCard{display:flex;flex-direction:column}
    #editCard .canvasWrap,#viewCard .canvasWrap{flex:1 1 auto}
    canvas{position:absolute;inset:0;width:100%;height:100%}
    .tools{position:absolute;left:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;z-index:5}
    .actions{position:absolute;right:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;z-index:5}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.35);backdrop-filter:blur(8px);padding:8px 10px;border-radius:14px;font-size:12px;color:rgba(255,255,255,0.9);z-index:5;max-width:90%}
    body.hints-hidden .hint{display:none}
    .viewerHelp{margin:8px 12px 12px;background:rgba(0,0,0,0.35);backdrop-filter:blur(8px);padding:8px 10px;border-radius:14px;font-size:12px;color:rgba(255,255,255,0.9)}
    body.hints-hidden .viewerHelp{display:none}
    button{border:1px solid rgba(255,255,255,0.12);background:var(--btn2);color:var(--ink);padding:10px 12px;border-radius:14px;cursor:pointer;user-select:none}
    button.primary{background:var(--btn);border-color:rgba(122,162,255,0.55)}
    button.active{outline:2px solid rgba(122,162,255,0.7)}
    .chip{display:inline-flex;align-items:center;gap:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);padding:8px 10px;border-radius:999px;font-size:12px;color:rgba(255,255,255,0.9)}
    .panel{padding:16px;background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02))}
    h2{margin:0 0 8px 0;font-size:18px}
    .small{font-size:12px;color:var(--muted);line-height:1.45}
    label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px}
    input[type="text"], input[type="number"], select{width:100%;padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.25);color:var(--ink)}
    input[type="range"]{width:100%}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .toggle{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-top:10px}
    .toggle input{transform:scale(1.1)}
    textarea{width:100%;height:190px;border-radius:14px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.25);color:var(--ink);padding:10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:11px;white-space:pre}
    .hr{height:1px;background:rgba(255,255,255,0.08);margin:12px 0}
    #err{position:fixed;left:12px;right:12px;bottom:12px;display:none;padding:10px 12px;border-radius:14px;background:rgba(255,80,80,0.14);border:1px solid rgba(255,80,80,0.35);color:rgba(255,255,255,0.92);font-size:12px;white-space:pre-wrap;z-index:9999}
    .row{display:flex;gap:10px;align-items:center}
    .row > *{flex:1}
    #ctrlCard .panel > h2{letter-spacing:.02em}
    #ctrlCard .panel{max-height:74vh;overflow:auto}
    #ctrlCard .panel{scrollbar-width:thin;scrollbar-color:rgba(122,162,255,0.62) rgba(255,255,255,0.06)}
    #ctrlCard .panel::-webkit-scrollbar{width:10px}
    #ctrlCard .panel::-webkit-scrollbar-track{background:rgba(255,255,255,0.06);border-radius:999px}
    #ctrlCard .panel::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#2a3f72,#1a294f);border:1px solid rgba(166,195,255,0.35);border-radius:999px}
    #ctrlCard .panel::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,#35508f,#203668)}
    #ctrlCard button{background:linear-gradient(180deg,#1a2340,#121a31)}
    #ctrlCard button:hover{border-color:rgba(122,162,255,0.7)}
    #ctrlCard .ctrlDockHeader{display:flex;flex-direction:column;align-items:stretch;gap:8px;margin-bottom:10px;position:sticky;top:0;padding:8px 0 10px;background:linear-gradient(180deg,rgba(11,15,25,0.96),rgba(11,15,25,0.7));backdrop-filter:blur(8px);z-index:3}
    #ctrlCard .ctrlDockTop{display:flex;align-items:center;justify-content:space-between;gap:10px}
    #ctrlCard .ctrlDockTitle{font-size:17px;font-weight:700;letter-spacing:.02em}
    #ctrlCard .ctrlDockActions{display:flex;gap:8px}
    #ctrlCard .ctrlDockActions button{padding:6px 9px;border-radius:10px;font-size:12px}
    #ctrlCard .ctrlModeToggle{display:grid;grid-template-columns:1fr 1fr;gap:6px}
    #ctrlCard .ctrlModeToggle button{padding:7px 8px;border-radius:10px;font-size:12px}
    #ctrlCard .ctrlModeToggle button.active{background:linear-gradient(180deg,#2b4a8a,#1b325f);border-color:rgba(166,197,255,0.7)}
    #ctrlCard .ctrlQuickTools{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
    #ctrlCard .ctrlQuickTools button{padding:8px 8px;border-radius:10px;font-size:12px}
    #ctrlCard .ctrlQuickTools button.primary{font-weight:700}
    #ctrlCard .ctrlToolHint{font-size:12px;color:rgba(225,234,255,0.92);line-height:1.4;padding:8px 9px;border-radius:10px;background:rgba(49,74,128,0.24);border:1px solid rgba(130,163,230,0.35)}
    #ctrlCard .ctrlMathStatus{font-size:11px;line-height:1.35;padding:7px 9px;border-radius:10px;border:1px solid rgba(137,168,226,0.42);background:rgba(17,28,51,0.55);color:rgba(223,234,255,0.95)}
    #ctrlCard .ctrlMathStatus.ok{border-color:rgba(112,206,150,0.52);background:rgba(22,62,40,0.38);color:rgba(197,255,224,0.96)}
    #ctrlCard .ctrlMathStatus.warn{border-color:rgba(255,170,112,0.58);background:rgba(66,34,16,0.40);color:rgba(255,226,203,0.96)}
    #ctrlCard .uiSection.uiHidden{display:none}
    #ctrlCard .ctrlIntro{font-size:12px;color:var(--muted);margin-bottom:10px}
    #ctrlCard .ctrlSections{display:flex;flex-direction:column;gap:10px;padding-bottom:16px}
    #ctrlCard details.uiSection{border:1px solid rgba(255,255,255,0.10);border-radius:14px;background:rgba(9,14,25,0.45);overflow:hidden}
    #ctrlCard details.uiSection > summary{list-style:none;cursor:pointer;user-select:none;padding:10px 12px;font-weight:600;font-size:13px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:space-between}
    #ctrlCard details.uiSection > summary::-webkit-details-marker{display:none}
    #ctrlCard details.uiSection > summary::after{content:'▾';font-size:12px;color:rgba(233,236,246,0.72)}
    #ctrlCard details.uiSection:not([open]) > summary::after{content:'▸'}
    #ctrlCard .uiSectionBody{padding:10px 12px 12px}
    #ctrlCard .uiSectionBody > .hr:first-child{display:none}
    #ctrlCard .uiSectionBody > h2{display:none}
    #ctrlCard .uiSectionBody label{margin-top:8px}
    #ctrlCard .uiSectionBody .toggle{margin-top:8px}
    #ctrlToggle{position:fixed;top:14px;right:14px;z-index:60;display:none;align-items:center;justify-content:center;width:34px;height:34px;border-radius:999px;padding:0;font-size:16px}
    #genQuickBtn{position:fixed;right:14px;bottom:90px;z-index:61;padding:11px 16px;border-radius:999px;background:linear-gradient(180deg,#2c4fa8,#1f3e87);border-color:rgba(164,194,255,0.68);box-shadow:0 10px 26px rgba(16,30,70,0.45);font-weight:700}
    #bottomActions{position:fixed;left:12px;right:12px;bottom:10px;z-index:60;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;padding:8px;border-radius:14px;background:rgba(7,12,22,0.88);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.12);min-height:var(--bottom-ui-h)}
    #bottomActions button{padding:9px 12px;border-radius:12px}
    #toggleHintsBtn{min-width:42px;font-weight:800;font-size:18px;line-height:1}
    .helpModal{position:fixed;inset:0;z-index:120;display:flex;align-items:center;justify-content:center;background:rgba(3,6,14,0.72);backdrop-filter:blur(4px);padding:18px}
    .helpModal.hidden{display:none}
    .helpCard{width:min(940px,96vw);max-height:min(82vh,840px);overflow:auto;background:linear-gradient(180deg,rgba(19,27,48,0.97),rgba(10,16,31,0.97));border:1px solid rgba(148,176,244,0.30);border-radius:16px;padding:16px 16px 14px;box-shadow:0 18px 45px rgba(0,0,0,0.45)}
    .helpTitle{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .helpTitle b{font-size:18px}
    .helpGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .helpBlock{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.09);border-radius:12px;padding:10px}
    .helpBlock b{display:block;margin-bottom:6px}
    .helpBlock p{margin:0;font-size:13px;color:rgba(234,238,249,0.92);line-height:1.45}
    .helpActions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px;flex-wrap:wrap}
    @media(max-width:880px){.helpGrid{grid-template-columns:1fr}}
    @media(max-width:640px){
      #ctrlCard .ctrlQuickTools{grid-template-columns:1fr}
    }
    #editWrap .editToolbar{left:12px;right:12px;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    #editWrap .editToolbar .toolGroup{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    #editWrap .editToolbar .primaryTools{flex:1 1 520px}
    #editWrap .editToolbar .statusTools{flex:0 1 auto}
    #editWrap .editToolbar .actionTools{margin-left:auto}
    #editWrap .editToolbar button{padding:9px 12px;border-radius:13px;white-space:nowrap}
    @media(max-width:1040px){
      #editWrap .editToolbar .actionTools{margin-left:0}
    }
    @media(min-width:1200px){
      .wrap{max-width:none;grid-template-columns:minmax(0,var(--split-l)) 8px minmax(0,var(--split-r));padding-right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed .wrap{padding-right:14px}
      #ctrlToggle{display:flex;right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #ctrlToggle{right:12px}
      #genQuickBtn{right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #genQuickBtn{right:12px}
      #ctrlCard{position:fixed;right:12px;top:12px;width:var(--dock-w);height:calc(100vh - 24px - var(--bottom-ui-h));min-height:unset;z-index:50;transition:transform .22s ease, opacity .22s ease}
      #ctrlCard .panel{height:100%;max-height:none;overflow:auto;padding:12px 14px 18px}
      body.ctrl-collapsed #ctrlCard{transform:translateX(calc(100% + 20px));opacity:0;pointer-events:none}
      #bottomActions{right:calc(var(--dock-w) + 18px)}
      body.ctrl-collapsed #bottomActions{right:12px}
    }
  </style>
</head>
<body>
<div id="err"></div>
<button id="ctrlToggle" title="Toggle controls">◀</button>
<button id="genQuickBtn" class="primary" title="Generate Track">Generate Track</button>

<div class="wrap">
  <!-- 2D ISO EDITOR -->
  <div class="card" id="editCard">
    <div class="canvasWrap" id="editWrap">
      <canvas id="edit"></canvas>
      <div class="tools editToolbar">
        <div class="toolGroup primaryTools">
          <button id="toolDraw" class="active" title="Add road points by clicking in 2D or 3D">Add Points</button>
          <button id="startNewLineBtn" title="Start drawing a disconnected line">New Line</button>
          <button id="toolMove" title="Move selected points and branch mids">Move</button>
          <button id="toolErase" title="Delete points or trim sections">Delete</button>
          <button id="toolJoin" title="Connect two points with a new link">Connect Roads</button>
          <button id="toolYSplit" title="Split one road into a fork">Split Road</button>
          <button id="toolRound" title="Create a roundabout from a selected point">Roundabout</button>
          <button id="toolFencePlace" title="Place fence props in 3D">Fence</button>
          <button id="toolTreePlace" title="Place tree props in 3D">Trees</button>
          <button id="toolBoulderPlace" title="Place boulder props in 3D">Rocks</button>
          <button id="toolPropEdit" title="Move, rotate, or scale placed props">Prop Edit</button>
        </div>
        <div class="toolGroup statusTools">
          <span class="chip">Selected: <b id="selLabel">none</b> <span id="selCount">(0)</span></span>
          <span class="chip" id="snapStatus">Snap: XZ 1.00 • Y 0.25</span>
        </div>
      </div>
    </div>
    <div class="viewerHelp" id="editHint">
      <b>2D</b>: Click add/select • Draw: click yellow/blue curve to insert point • New Line button (or <b>N</b>) starts a disconnected line • Shift/Ctrl click = multi-select • Drag move (XZ) • <b>Space+drag</b> pan • Shift+drag pan • Wheel zoom • Alt+wheel height<br/>
      <b>Tools</b>: Join = click point A then B to rewrite one side into a clean single-loop shortcut • Y Split = click point/section, then click point to add fork section • Y Split same-point second click = fork point into 2 • Ctrl/Cmd+click/click trim • Alt+click/click join • Roundabout = click point, drag size, click exit • Fence/Tree/Boulder place in 3D by clicking terrain • Prop Edit = select and transform props with gimbal (W/E/R), Delete removes<br/>
      <b>Math markers</b>: Red X = bad same-level overlap/too-close road clearance (auto overpass tries to lift one road) • Cyan ring = valid stacked crossing • Math status in Controls shows remaining issues<br/>
      <b>Bezier</b>: select yellow or blue point then drag handle squares • <b>Alt-drag handle</b> rotate-only (keep length) • <b>1/2/3</b> set Smooth/Aligned/Corner
    </div>
  </div>

  <div id="splitter" class="splitter" title="Drag to resize 2D/3D panels"></div>

  <!-- 3D PREVIEW (offline software renderer) -->
  <div class="card" id="viewCard">
    <div class="canvasWrap" id="viewWrap">
      <canvas id="view"></canvas>
      <div class="actions">
        <button id="viewModeBtn">Mode: Normal</button>
        <button id="propGizmoBtn" title="Prop gizmo mode (W/E/R)">Gizmo: Move</button>
      </div>
    </div>
    <div class="viewerHelp" id="viewHint">
      <b>3D</b>: WASD + Q/Z move • RMB look • LMB look • MMB pan • Alt+RMB orbit selected • RMB+wheel speed • MMB click reset speed (scene-based) • F focus • Drag yellow gizmo center = free move • Drag Bezier handle dots to shape in 3D • Prop Edit gizmo: <b>W</b>=Move <b>E</b>=Rotate <b>R</b>=Scale<br/>
      Road tools (Draw/Move/Erase/Join/Y Split/Roundabout) also work directly in 3D. Press <b>G</b> for Blender-style free move on selected road node. Hold <b>Shift</b> for fine move, <b>Ctrl</b> to force snap when snap is off, <b>Alt</b> to bypass snap.
    </div>
  </div>

  <!-- CONTROLS -->
  <div class="card" id="ctrlCard">
    <div class="panel">
      <h2>Controls</h2>
      <div class="small">Build roads like a city-builder game: lay points, split/connect routes, then open advanced controls only when you need precision tuning.</div>

      <label>Track name</label>
      <input id="trackName" type="text" value="mk_track_3d"/>

      <label>Workspace view</label>
      <select id="workspaceMode">
        <option value="both">Both (2D + 3D)</option>
        <option value="2d">2D only</option>
        <option value="3d">3D only</option>
      </select>

      <div class="two">
        <div>
          <label>Grid snap (XZ)</label>
          <input id="grid" type="number" step="0.5" min="0.5" max="8" value="1"/>
        </div>
        <div>
          <label>Iso zoom</label>
          <input id="isoScale" type="range" min="0.02" max="240" step="0.02" value="5.98"/>
          <div class="small"><span id="isoScaleVal">5.98</span></div>
        </div>
      </div>
      <div class="toggle"><label style="margin:0">Road iso snap</label><input id="roadIsoSnap" type="checkbox" checked/></div>
      <div class="small">Snaps main/branch/roundabout/generation edits to grid; Y uses Road level step.</div>
      <label>Road level step (Y)</label>
      <input id="roadSnapY" type="number" step="0.05" min="0.05" max="10" value="0.25"/>
      <div class="small"><span id="roadSnapYVal">0.25</span></div>

      <div class="toggle"><label style="margin:0">Show grid</label><input id="showGrid" type="checkbox" checked/></div>
      <div class="toggle"><label style="margin:0">Closed loop</label><input id="closed" type="checkbox" checked/></div>

      <label>Road width</label>
      <input id="roadWidth" type="range" min="1" max="14" step="0.25" value="4.0"/>
      <div class="small"><span id="roadWidthVal">4.00</span></div>

      <label>Thickness (Y)</label>
      <input id="roadThickness" type="range" min="0.05" max="3" step="0.05" value="0.05"/>
      <div class="small"><span id="roadThicknessVal">0.05</span></div>

      <div class="toggle"><label style="margin:0">Include side walls</label><input id="includeSides" type="checkbox" checked/></div>

      <label>Spline smoothness</label>
      <input id="subdiv" type="range" min="2" max="30" step="1" value="25"/>
      <div class="small"><span id="subdivVal">25</span></div>

      <label>Path detail (performance)</label>
      <input id="pathDetail" type="range" min="0.30" max="1.00" step="0.01" value="0.51"/>
      <div class="small"><span id="pathDetailVal">0.51x</span></div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Generator</h2>
      <div class="small">Mario Kart/F1 and highway interchange templates with rule-checked banking and bridge clearance.</div>

      <label>Generator style</label>
      <select id="genStyle">
        <option value="figure8">Figure-8 (Mario Kart style)</option>
        <option value="clover">Cloverleaf</option>
        <option value="serpentine">Serpentine</option>
        <option value="mountainSpiral">Mountain spiral</option>
        <option value="splitS">Split-S</option>
        <option value="f1long">F1 long circuit</option>
        <option value="diamond">Diamond interchange</option>
        <option value="partialClover">Partial cloverleaf</option>
        <option value="trumpet">Trumpet interchange</option>
        <option value="stackLite">Stack-lite interchange</option>
        <option value="random" selected>Random style mix</option>
      </select>

      <div class="toggle"><label style="margin:0">Y-split modifier</label><input id="genModY" type="checkbox" checked/></div>
      <div class="toggle"><label style="margin:0">Roundabout modifier</label><input id="genModRound" type="checkbox"/></div>
      <div class="toggle"><label style="margin:0">Crossroads modifier</label><input id="genModCross" type="checkbox" checked/></div>

      <label>Layout variation</label>
      <input id="genRandomness" type="range" min="0" max="1" step="0.01" value="0.87"/>
      <div class="small"><span id="genRandomnessVal">0.87</span></div>

      <label>Track size</label>
      <input id="genScale" type="range" min="0.6" max="3.8" step="0.01" value="3.73"/>
      <div class="small"><span id="genScaleVal">3.73x</span></div>

      <label>Lap length</label>
      <input id="genLength" type="range" min="0.7" max="3.5" step="0.01" value="2.40"/>
      <div class="small"><span id="genLengthVal">2.40x</span></div>

      <label>Curve count</label>
      <input id="genCurves" type="range" min="2" max="16" step="1" value="7"/>
      <div class="small"><span id="genCurvesVal">7</span></div>

      <label>Generator point cap</label>
      <input id="genPointCap" type="range" min="16" max="120" step="1" value="27"/>
      <div class="small"><span id="genPointCapVal">27</span></div>

      <label>Design combo count</label>
      <input id="genComboCount" type="range" min="1" max="3" step="1" value="2"/>
      <div class="small"><span id="genComboCountVal">2</span></div>

      <label>Straight bias</label>
      <input id="genStraights" type="range" min="0" max="1" step="0.01" value="0.78"/>
      <div class="small"><span id="genStraightsVal">0.78</span></div>

      <label>Flow smoothing</label>
      <input id="genFlow" type="range" min="0" max="1" step="0.01" value="0.86"/>
      <div class="small"><span id="genFlowVal">0.86</span></div>

      <label>Roundabout exits</label>
      <input id="genRoundExits" type="range" min="2" max="4" step="1" value="3"/>
      <div class="small"><span id="genRoundExitsVal">3</span></div>

      <label>Crossroads frequency</label>
      <input id="genCrossFreq" type="range" min="1" max="4" step="1" value="3"/>
      <div class="small"><span id="genCrossFreqVal">3</span></div>

      <button id="genBtn" style="margin-top:8px">Generate Track</button>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Road Network (Stage B)</h2>
      <div class="small">Per-edge class, lanes, and direction defaults. New Join/Y-Split links inherit branch defaults and can be overridden per branch edge.</div>

      <label>Main road class</label>
      <select id="mainRoadClass">
        <option value="local">Local</option>
        <option value="collector" selected>Collector</option>
        <option value="arterial">Arterial</option>
        <option value="freeway">Freeway</option>
        <option value="ramp">Ramp</option>
      </select>
      <div class="two">
        <div>
          <label>Main direction</label>
          <select id="mainRoadDir">
            <option value="a_to_b" selected>One-way loop</option>
            <option value="two_way">Two-way loop</option>
          </select>
        </div>
        <div>
          <label>Main lanes (F / R)</label>
          <div class="row">
            <input id="mainLanesF" type="number" min="1" max="8" step="1" value="2"/>
            <input id="mainLanesR" type="number" min="0" max="8" step="1" value="0"/>
          </div>
        </div>
      </div>
      <div class="small"><span id="mainRoadSpecVal">2 lanes • 45 mph • Rmin 45 • Grade 8.0%</span></div>

      <label>New branch class</label>
      <select id="newBranchClass">
        <option value="local">Local</option>
        <option value="collector">Collector</option>
        <option value="arterial">Arterial</option>
        <option value="freeway">Freeway</option>
        <option value="ramp" selected>Ramp</option>
      </select>
      <div class="two">
        <div>
          <label>New branch direction</label>
          <select id="newBranchDir">
            <option value="a_to_b" selected>A → B</option>
            <option value="b_to_a">B → A</option>
            <option value="two_way">Two-way</option>
          </select>
        </div>
        <div>
          <label>New branch lanes (F / R)</label>
          <div class="row">
            <input id="newBranchLanesF" type="number" min="1" max="8" step="1" value="1"/>
            <input id="newBranchLanesR" type="number" min="0" max="8" step="1" value="0"/>
          </div>
        </div>
      </div>
      <div class="small"><span id="newBranchSpecVal">1 lane • 40 mph • Rmin 45 • Grade 8.0%</span></div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Terrain</h2>
      <div class="small">Optional rough cliff terrain around the track footprint.</div>
      <div class="toggle"><label style="margin:0">Generate terrain</label><input id="terrainOn" type="checkbox" checked/></div>
      <label>Terrain roughness</label>
      <input id="terrainRough" type="range" min="0" max="4" step="0.1" value="4.0"/>
      <div class="small"><span id="terrainRoughVal">4.0</span></div>
      <label>Cliff height</label>
      <input id="terrainCliff" type="range" min="1" max="12" step="0.2" value="10.0"/>
      <div class="small"><span id="terrainCliffVal">10.0</span></div>
      <label>Road → terrain clearance</label>
      <input id="terrainClearance" type="range" min="0.05" max="1.20" step="0.01" value="0.44"/>
      <div class="small"><span id="terrainClearanceVal">0.44</span></div>
      <label>Terrain follow road</label>
      <input id="terrainFollow" type="range" min="0" max="1" step="0.01" value="0.88"/>
      <div class="small"><span id="terrainFollowVal">0.88</span></div>
      <label>Terrain detail (anti low-poly)</label>
      <input id="terrainDetail" type="range" min="0" max="1" step="0.01" value="0.62"/>
      <div class="small"><span id="terrainDetailVal">0.62</span></div>
      <div class="toggle"><label style="margin:0">Island edge shaping</label><input id="terrainIsland" type="checkbox" checked/></div>
      <label>Island offset from track (m)</label>
      <input id="terrainIslandOffset" type="range" min="4" max="140" step="1" value="34"/>
      <div class="small"><span id="terrainIslandOffsetVal">34</span></div>
      <label>Island coast falloff width (m)</label>
      <input id="terrainIslandFalloff" type="range" min="4" max="140" step="1" value="30"/>
      <div class="small"><span id="terrainIslandFalloffVal">30</span></div>
      <label>Island coast drop below track base (m)</label>
      <input id="terrainIslandDrop" type="range" min="0.2" max="40" step="0.2" value="9.4"/>
      <div class="small"><span id="terrainIslandDropVal">9.4</span></div>
      <label>Terrain presets</label>
      <div class="row">
        <button id="terrainPresetClean" type="button">Kart clean</button>
        <button id="terrainPresetCliffs" type="button">Steep cliffs</button>
        <button id="terrainPresetBridge" type="button">Wide clear</button>
      </div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Theme (Yoshi mock)</h2>
      <div class="small">Adds grass shoulders + curbs, with manual fence/tree/boulder placement in 3D.</div>
      <div class="toggle"><label style="margin:0">Enable theme dressing</label><input id="themeOn" type="checkbox" checked/></div>

      <label>Grass shoulder width</label>
      <input id="themeGrass" type="range" min="0.5" max="6.5" step="0.1" value="0.6"/>
      <div class="small"><span id="themeGrassVal">0.6</span></div>

      <label>Curb height</label>
      <input id="themeCurb" type="range" min="0.02" max="0.30" step="0.01" value="0.10"/>
      <div class="small"><span id="themeCurbVal">0.10</span></div>

      <label>Fence height scale</label>
      <input id="themeFence" type="range" min="0" max="1" step="0.01" value="0.55"/>
      <div class="small"><span id="themeFenceVal">0.55</span></div>

      <label>Tree size scale</label>
      <input id="themeTrees" type="range" min="0" max="1" step="0.01" value="0.60"/>
      <div class="small"><span id="themeTreesVal">0.60</span></div>

      <label>Boulder size scale</label>
      <input id="themeRocks" type="range" min="0" max="1" step="0.01" value="0.65"/>
      <div class="small"><span id="themeRocksVal">0.65</span></div>

      <label>Bridge support style</label>
      <select id="supportStyle">
        <option value="highway" selected>Highway columns</option>
        <option value="coaster">Wooden trestle (Mario Kart)</option>
        <option value="concrete">Concrete piers</option>
        <option value="cliff">Cliff braces</option>
        <option value="tree">3D slicer tree supports</option>
        <option value="trestle">Wood trestle (legacy)</option>
      </select>
      <label>Bridge deck material</label>
      <select id="bridgeMaterial">
        <option value="auto" selected>Auto (match support)</option>
        <option value="freeway">Freeway slab</option>
        <option value="wood_planks">Wood planks (Mario Kart)</option>
        <option value="steel">Steel deck</option>
        <option value="city_mix">City mix (multi-material)</option>
      </select>
      <div class="small"><span id="bridgeMaterialVal">Auto (match support)</span></div>
      <div class="row" style="margin-top:8px">
        <button id="bridgePresetHighway" type="button">Bridge: Highway</button>
        <button id="bridgePresetWood" type="button">Bridge: Wood</button>
        <button id="bridgePresetMixed" type="button">Bridge: Mixed</button>
      </div>
      <button id="clearPropsBtn" style="margin-top:8px">Clear placed props</button>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Selected branch edge (Stage B)</h2>
      <div class="small">Select a branch midpoint, then tune class/direction/lanes for that edge.</div>
      <label>Branch class</label>
      <select id="selBranchClass" disabled>
        <option value="local">Local</option>
        <option value="collector" selected>Collector</option>
        <option value="arterial">Arterial</option>
        <option value="freeway">Freeway</option>
        <option value="ramp">Ramp</option>
      </select>
      <div class="two">
        <div>
          <label>Branch direction</label>
          <select id="selBranchDir" disabled>
            <option value="a_to_b" selected>A → B</option>
            <option value="b_to_a">B → A</option>
            <option value="two_way">Two-way</option>
          </select>
        </div>
        <div>
          <label>Branch lanes (F / R)</label>
          <div class="row">
            <input id="selBranchLanesF" type="number" min="1" max="8" step="1" value="1" disabled/>
            <input id="selBranchLanesR" type="number" min="0" max="8" step="1" value="0" disabled/>
          </div>
        </div>
      </div>
      <div class="small"><span id="selBranchSpecVal">No branch selected</span></div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Selected point</h2>
      <div class="small">Height/bank + node type. Node type controls how opposite handle behaves.</div>

      <label>Node type</label>
      <select id="selNode">
        <option value="smooth">Smooth (mirrored)</option>
        <option value="aligned">Aligned (angle mirrored)</option>
        <option value="corner">Corner (independent)</option>
      </select>

      <div class="two">
        <div>
          <label>Height (Y)</label>
          <input id="selY" type="range" min="-10" max="20" step="0.1" value="0"/>
          <div class="small"><span id="selYVal">0.0</span></div>
        </div>
        <div>
          <label id="selBankLabel">Bank (deg)</label>
          <input id="selBank" type="range" min="-45" max="45" step="0.5" value="0"/>
          <div class="small"><span id="selBankVal">0.0</span></div>
        </div>
      </div>

      <div class="hr"></div>

      <h2 style="font-size:16px;margin:0 0 6px">Auto bank (optional)</h2>
      <div class="small">Derives banking from curvature (turning). Blends with manual bank per point.</div>
      <div class="toggle"><label style="margin:0">Enable auto bank</label><input id="autoBank" type="checkbox" checked/></div>

      <label>Auto bank strength</label>
      <input id="autoBankStrength" type="range" min="0" max="1" step="0.01" value="0.72"/>
      <div class="small"><span id="autoBankStrengthVal">0.72</span></div>

      <label>Max auto bank (deg)</label>
      <input id="autoBankMax" type="range" min="0" max="60" step="1" value="16"/>
      <div class="small"><span id="autoBankMaxVal">16</span></div>

      <label>Curvature → bank scale</label>
      <input id="autoBankScale" type="range" min="0" max="4" step="0.05" value="1.40"/>
      <div class="small"><span id="autoBankScaleVal">1.40</span></div>

      <div class="hr"></div>

      <div class="small">If download is blocked, copy OBJ text into <b>.obj</b>:</div>
      <button id="toggleObj" style="margin-top:8px">Show OBJ</button>
      <textarea id="objText" style="display:none" readonly></textarea>

      <div class="hr"></div>
      <div class="small">Dev: open console for self-tests on load.</div>
    </div>
  </div>
</div>

<div id="bottomActions">
  <button id="saveBtn" type="button">Save</button>
  <button id="loadBtn" type="button" title="Load file (Shift+Click restores local cache)">Load</button>
  <button id="toggleHintsBtn" type="button" title="Help and tool guide">?</button>
  <button id="resetBtn" type="button">Reset</button>
  <button id="clearBtn" type="button">Clear</button>
  <button id="exportBtn" type="button" class="primary">Export OBJ</button>
  <button id="exportFbxBtn" type="button">Export FBX (Enfusion)</button>
  <button id="exportTerrainBtn" type="button">Export Terrain (Enfusion)</button>
  <input id="loadProjectFile" type="file" accept=".json,.mktrack,.mktrack.json,application/json" style="display:none"/>
</div>

<div id="helpModal" class="helpModal hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="helpCard">
    <div class="helpTitle">
      <b id="helpTitle">Tool Guide</b>
      <button id="helpCloseBtn" type="button">Close</button>
    </div>
    <div class="helpGrid">
      <div class="helpBlock"><b>2D Edit</b><p>Draw: click to add point. Move: drag selected. Erase: click point or Ctrl/Cmd-click trim section. Shift/Ctrl click adds to multi-select. Space+drag or Shift+drag pans. Wheel zooms. Alt+wheel changes point height.</p></div>
      <div class="helpBlock"><b>Join / Y Split / Roundabout</b><p>Join: click point A then B to rewrite that area into one continuous circuit shortcut. Y Split: click point/section then click target to create fork; clicking same point twice forks node into two ends. Roundabout: click start point, drag radius, then click exit direction.</p></div>
      <div class="helpBlock"><b>Bezier / Node Types</b><p>Select a yellow or blue point to edit handles. Drag square handles to shape curvature. Alt-drag rotates handle without length change. Node types: Smooth mirrors angle+length, Aligned mirrors angle only, Corner is independent. Keys 1/2/3 switch node type.</p></div>
      <div class="helpBlock"><b>3D View + Gizmo</b><p>WASD + Q/Z moves camera. RMB or LMB look, MMB pan. Alt+RMB orbits selected point. Mouse wheel with RMB adjusts speed, MMB click resets speed. F focuses selected. All road tools can be used in 3D via point/curve picking. Drag yellow gizmo center/axes to move points. Press G for Blender-style free move on selected road node. Shift = fine move, Ctrl = force snap when snap is off, Alt = bypass snap. In Prop Edit mode use W/E/R to switch Move/Rotate/Scale gizmo.</p></div>
      <div class="helpBlock"><b>Generation + Terrain</b><p>Generate Track builds templates and modifiers. Closed loop now stitches final segment back to start in mesh. Terrain detail increases terrain mesh resolution and smoothing to reduce sharp faceting on cliff transitions and shoulders.</p></div>
      <div class="helpBlock"><b>Bridge Styles + Export</b><p>Scenery panel has one-click bridge presets: Highway, Wood (Mario Kart planks), and Mixed city materials. Support styles include highway columns, concrete piers, coaster trestles, cliff braces, and tree-style supports. Export OBJ writes road, sides, terrain, curbs, shoulders, bridges, supports, and placed props as manifold meshes where supported. Export FBX (Enfusion) writes visual + collision helper meshes named for Enfusion Blender workflow.</p></div>
    </div>
    <div class="helpActions">
      <button id="helpInlineToggle" type="button">Hide Inline Helpers</button>
      <button id="helpCloseBtn2" type="button">Done</button>
    </div>
  </div>
</div>

<script>
(() => {
  const errEl = document.getElementById('err');
  const showErr = (msg) => {
    errEl.style.display = 'block';
    errEl.textContent = String(msg);
  };
  window.addEventListener('error', (e) => {
    const message = (e && (e.message || (e.error && e.error.message) || e.error)) || e;
    showErr('JS error:\n' + String(message));
  });

  // ---------- math helpers ----------
  const v3 = (x = 0, y = 0, z = 0) => ({ x, y, z });
  const vv = (a) => (a && Number.isFinite(a.x) && Number.isFinite(a.y) && Number.isFinite(a.z)) ? a : v3(0, 0, 0);
  const add = (a, b) => { a = vv(a); b = vv(b); return v3(a.x + b.x, a.y + b.y, a.z + b.z); };
  const sub = (a, b) => { a = vv(a); b = vv(b); return v3(a.x - b.x, a.y - b.y, a.z - b.z); };
  const mul = (a, s) => { a = vv(a); return v3(a.x * s, a.y * s, a.z * s); };
  const dot = (a, b) => { a = vv(a); b = vv(b); return a.x * b.x + a.y * b.y + a.z * b.z; };
  const cross = (a, b) => { a = vv(a); b = vv(b); return v3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x); };
  const len = (a) => { a = vv(a); return Math.hypot(a.x, a.y, a.z); };
  const norm = (a) => {
    a = vv(a);
    const l = len(a) || 1;
    return v3(a.x / l, a.y / l, a.z / l);
  };
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

  function rotateAxis(v, axis, rad) {
    const k = norm(axis);
    const c = Math.cos(rad), s = Math.sin(rad);
    return add(add(mul(v, c), mul(cross(k, v), s)), mul(k, dot(k, v) * (1 - c)));
  }

  function rotateEuler(v, rot) {
    let out = v3(v.x, v.y, v.z);
    const rx = Number(rot?.x || 0);
    const ry = Number(rot?.y || 0);
    const rz = Number(rot?.z || 0);
    if (Math.abs(rx) > 1e-9) out = rotateAxis(out, v3(1, 0, 0), rx);
    if (Math.abs(ry) > 1e-9) out = rotateAxis(out, v3(0, 1, 0), ry);
    if (Math.abs(rz) > 1e-9) out = rotateAxis(out, v3(0, 0, 1), rz);
    return out;
  }

  // ---------- iso projection (2D editor) ----------
  function isoProject(p, s) {
    const ix = (p.x - p.z) * s;
    const iy = (p.x + p.z) * s * 0.5;
    return { x: ix, y: iy - p.y * s };
  }

  // Inverse for a given fixed height (y). This fixes picking/editing when points have height.
  function worldFromScreenXZWithY(sx, sy, org, s, y) {
    const syAdj = sy + y * s;
    const xIso = (sx - org.x) / s;
    const yIso = (syAdj - org.y) / (s * 0.5);
    const x = (xIso + yIso) / 2;
    const z = (yIso - xIso) / 2;
    return { x, z };
  }

  // ---------- cubic bezier sampling ----------
  function bezier(p0, c0, c1, p1, t) {
    const u = 1 - t;
    const uu = u * u, tt = t * t;
    const uuu = uu * u, ttt = tt * t;
    return add(add(add(mul(p0, uuu), mul(c0, 3 * uu * t)), mul(c1, 3 * u * tt)), mul(p1, ttt));
  }

  function bezierDeriv(p0, c0, c1, p1, t) {
    const u = 1 - t;
    const a = mul(sub(c0, p0), 3 * u * u);
    const b = mul(sub(c1, c0), 6 * u * t);
    const c = mul(sub(p1, c1), 3 * t * t);
    return add(add(a, b), c);
  }

  function ensurePointShape(p) {
    if (!p.hin) p.hin = { x: 0, z: 0 };
    if (!p.hout) p.hout = { x: 0, z: 0 };
    if (!p.node) p.node = 'smooth'; // smooth | aligned | corner
    if (typeof p.bank !== 'number') p.bank = 0;
    if (typeof p.pos?.y !== 'number') p.pos.y = 0;
  }

  function ensureHandles(ctrl) {
    const baseLen = 1.2;
    for (const p of ctrl) ensurePointShape(p);
    for (let i = 0; i < ctrl.length; i++) {
      const p = ctrl[i];
      const prev = ctrl[Math.max(0, i - 1)];
      const next = ctrl[Math.min(ctrl.length - 1, i + 1)];
      if (Math.hypot(p.hout.x, p.hout.z) < 1e-6) {
        const d = norm(sub(next.pos, p.pos));
        p.hout = { x: d.x * baseLen, z: d.z * baseLen };
      }
      if (Math.hypot(p.hin.x, p.hin.z) < 1e-6) {
        const d = norm(sub(prev.pos, p.pos));
        p.hin = { x: d.x * baseLen, z: d.z * baseLen };
      }
    }
  }

  function signedTurnXZ(a, b, c) {
    // signed angle between (b-a) and (c-b) in XZ
    const v1 = norm(v3(b.x - a.x, 0, b.z - a.z));
    const v2 = norm(v3(c.x - b.x, 0, c.z - b.z));
    const cr = cross(v1, v2);
    const d = clamp(dot(v1, v2), -1, 1);
    const ang = Math.acos(d);
    const sign = cr.y >= 0 ? 1 : -1;
    return ang * sign; // radians
  }

  function computeAutoBank(samples, maxDeg, scale) {
    if (samples.length < 3) return samples.map(() => 0);
    const out = new Array(samples.length).fill(0);
    for (let i = 1; i < samples.length - 1; i++) {
      const a = samples[i - 1].pos;
      const b = samples[i].pos;
      const c = samples[i + 1].pos;
      const ang = signedTurnXZ(a, b, c); // rad
      // curvature proxy: signed angle per segment
      const bank = clamp((ang * (180 / Math.PI)) * scale, -maxDeg, maxDeg);
      out[i] = bank;
    }
    out[0] = out[1];
    out[out.length - 1] = out[out.length - 2];
    return out;
  }

  function sampleSpline(ctrl, subdiv, closed, autoBankCfg) {
    const n = ctrl.length;
    if (n < 2) return [];
    ensureHandles(ctrl);

    const out = [];
    const segs = closed ? n : n - 1;
    const get = (i) => ctrl[(i % n + n) % n];

    for (let i = 0; i < segs; i++) {
      const a = get(i);
      const b = get(i + 1);
      const p0 = a.pos;
      const p1 = b.pos;
      const c0 = add(p0, v3(a.hout.x, 0, a.hout.z));
      const c1 = add(p1, v3(b.hin.x, 0, b.hin.z));
      for (let s = 0; s < subdiv; s++) {
        const t = s / subdiv;
        out.push({ pos: bezier(p0, c0, c1, p1, t), bank: (1 - t) * a.bank + t * b.bank });
      }
    }
    const last = closed ? ctrl[0] : ctrl[n - 1];
    out.push({ pos: last.pos, bank: last.bank });

    // Auto bank derived from curvature (blend)
    if (autoBankCfg?.enabled) {
      const maxDeg = autoBankCfg.maxDeg;
      const scale = autoBankCfg.scale;
      const strength = autoBankCfg.strength;
      const banks = computeAutoBank(out, maxDeg, scale);
      for (let i = 0; i < out.length; i++) {
        out[i].bank = (1 - strength) * out[i].bank + strength * banks[i];
      }
    }

    return out;
  }

  function effectiveSubdiv() {
    return clamp(Math.round(num('subdiv') * num('pathDetail')), 2, 30);
  }

  function branchAnchors(sec) {
    const a = points[sec.a];
    const b = points[sec.b];
    if (!a || !b) return [];
    const mids = Array.isArray(sec.mids) ? sec.mids.slice().sort((m1, m2) => m1.u - m2.u) : [];
    const AB = sub(b.pos, a.pos);
    const flat = v3(AB.x, 0, AB.z);
    const L = Math.max(0.01, len(flat));
    const abDir = norm(flat);
    const tA0 = tangentAtIndex(sec.a);
    const tB0 = tangentAtIndex(sec.b);
    const tA = dot(tA0, abDir) >= 0 ? norm(v3(tA0.x, 0, tA0.z)) : mul(norm(v3(tA0.x, 0, tA0.z)), -1);
    const tB = dot(tB0, mul(abDir, -1)) >= 0 ? norm(v3(tB0.x, 0, tB0.z)) : mul(norm(v3(tB0.x, 0, tB0.z)), -1);
    const t = (Math.hypot(abDir.x, abDir.z) > 1e-6) ? abDir : tA;
    const n = norm(v3(-t.z, 0, t.x));
    const bendSide = (Number(sec.bend) || 1) >= 0 ? 1 : -1;
    const alignA = clamp(dot(tA, abDir), -1, 1);
    const alignB = clamp(dot(tB, mul(abDir, -1)), -1, 1);
    const tangentAgree = clamp((alignA + alignB) * 0.5, 0, 1);
    const bendScale = clamp(1 - tangentAgree * 0.88, 0.12, 1);
    const bendAmt = Math.min(L * 0.30, Math.max(num('roadWidth') * 0.95, L * 0.13)) * bendScale;
    const bend = mul(n, bendAmt * bendSide * (sec.kind === 'fork' ? 1.15 : 0.8));
    const endScale = 0.30;
    return [
      {
        x: a.pos.x, y: a.pos.y, z: a.pos.z, u: 0, node: 'smooth', bevel: 0.65,
        hin: { x: -tA.x * L * endScale - bend.x * 0.35, z: -tA.z * L * endScale - bend.z * 0.35 },
        hout: { x: tA.x * L * endScale + bend.x, z: tA.z * L * endScale + bend.z },
      },
      ...mids.map((m) => ({
        x: m.x, y: m.y, z: m.z, u: clamp(Number(m.u || 0), 0.001, 0.999),
        bevel: clamp(Number(m.bevel ?? 0.55), 0, 1),
        node: (m.node === 'aligned' || m.node === 'corner') ? m.node : 'smooth',
        hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
        hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
      })),
      {
        x: b.pos.x, y: b.pos.y, z: b.pos.z, u: 1, node: 'smooth', bevel: 0.65,
        hin: { x: -tB.x * L * endScale + bend.x, z: -tB.z * L * endScale + bend.z },
        hout: { x: tB.x * L * endScale - bend.x * 0.35, z: tB.z * L * endScale - bend.z * 0.35 },
      },
    ];
  }

  function sampleBranchSection(sec, subdiv) {
    const a = points[sec.a];
    const b = points[sec.b];
    if (!a || !b) return [];
    const anchors = branchAnchors(sec);
    const lift = Math.max(0, Number(sec.lift) || 0);
    const steps = Math.max(8, Math.round(subdiv * (sec.kind === 'fork' ? 2.3 : 2.0)));
    const out = [];
    const spans = anchors.length - 1;
    for (let si = 0; si < spans; si++) {
      const p0 = anchors[si];
      const p1 = anchors[si + 1];
      const spanSteps = Math.max(4, Math.round(steps / spans));
      const s0 = 0.08 + clamp(Number(p0.bevel ?? 0.55), 0, 1) * 1.15;
      const s1 = 0.08 + clamp(Number(p1.bevel ?? 0.55), 0, 1) * 1.15;
      const c0 = v3(p0.x + p0.hout.x * s0, p0.y, p0.z + p0.hout.z * s0);
      const c1 = v3(p1.x + p1.hin.x * s1, p1.y, p1.z + p1.hin.z * s1);
      for (let k = 0; k <= spanSteps; k++) {
        if (si > 0 && k === 0) continue;
        const tLocal = k / spanSteps;
        const u = (si + tLocal) / spans;
        const p = bezier(v3(p0.x, p0.y, p0.z), c0, c1, v3(p1.x, p1.y, p1.z), tLocal);
        p.y += Math.sin(u * Math.PI) * lift;
        out.push({ pos: p, bank: (1 - u) * (a.bank || 0) + u * (b.bank || 0), u });
      }
    }
    return out;
  }

  function nearestBranchCurveHitScreen(sx, sy, org, s, maxPix = 12) {
    sanitizeBranchSections();
    const subdiv = effectiveSubdiv();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const sec = branchSections[si];
      const smp = sampleBranchSection(sec, subdiv);
      if (smp.length < 2) continue;
      let prev = smp[0];
      let prevSp = screenFromWorld2(prev.pos, org, s);
      for (let i = 1; i < smp.length; i++) {
        const cur = smp[i];
        const curSp = screenFromWorld2(cur.pos, org, s);
        const hit = closestPointOnScreenSegment(sx, sy, prevSp.x, prevSp.y, curSp.x, curSp.y);
        if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
          const u = prev.u + (cur.u - prev.u) * hit.t;
          const pos = add(mul(prev.pos, 1 - hit.t), mul(cur.pos, hit.t));
          const tan = norm(sub(cur.pos, prev.pos));
          best = { dist: hit.d, sec: si, u, pos, tan };
        }
        prev = cur;
        prevSp = curSp;
      }
    }
    return best;
  }

  function nearestBranchMidpointScreen(sx, sy, org, s, maxPix = 12) {
    sanitizeBranchSections();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const mids = branchSections[si]?.mids || [];
      for (let mi = 0; mi < mids.length; mi++) {
        const m = mids[mi];
        const sp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const d = Math.hypot(sp.x - sx, sp.y - sy);
        if (d <= maxPix && (!best || d < best.dist)) best = { sec: si, mid: mi, dist: d };
      }
    }
    return best;
  }

  function insertBranchMidpoint(secIdx, u, pos, tanHint = null) {
    const sec = branchSections[secIdx];
    if (!sec || !pos) return false;
    const sp = snapRoadXYZ(pos.x, pos.y, pos.z);
    const midPos = v3(sp.x, sp.y, sp.z);
    if (!Array.isArray(sec.mids)) sec.mids = [];
    const prev = points[sec.a]?.pos || midPos;
    const next = points[sec.b]?.pos || midPos;
    const inDist = Math.max(0.08, len(sub(midPos, prev)));
    const outDist = Math.max(0.08, len(sub(next, midPos)));
    let t = tanHint ? norm(v3(tanHint.x, 0, tanHint.z)) : norm(sub(next, prev));
    if (!Number.isFinite(t.x) || !Number.isFinite(t.z) || Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
    const hIn = inDist * 0.34;
    const hOut = outDist * 0.34;
    sec.mids.push({
      u: clamp(Number(u || 0.5), 0.001, 0.999),
      x: midPos.x,
      y: midPos.y,
      z: midPos.z,
      bevel: 0.55,
      node: 'smooth',
      hin: { x: -t.x * hIn, z: -t.z * hIn },
      hout: { x: t.x * hOut, z: t.z * hOut },
    });
    sanitizeBranchSections();
    const mids = sec.mids || [];
    let best = 0;
    let bestD = 1e9;
    for (let i = 0; i < mids.length; i++) {
      const d = Math.abs(mids[i].u - u);
      if (d < bestD) { bestD = d; best = i; }
    }
    selectBranchMidpoint(secIdx, best);
    return true;
  }

  function cloneSampleNode(s) {
    return {
      pos: v3(s?.pos?.x || 0, s?.pos?.y || 0, s?.pos?.z || 0),
      bank: Number(s?.bank || 0),
      u: Number(s?.u || 0),
    };
  }

  function lerpSampleNode(a, b, t) {
    const ta = clamp(Number(t), 0, 1);
    const tb = 1 - ta;
    return {
      pos: v3(
        a.pos.x * tb + b.pos.x * ta,
        a.pos.y * tb + b.pos.y * ta,
        a.pos.z * tb + b.pos.z * ta
      ),
      bank: Number(a.bank || 0) * tb + Number(b.bank || 0) * ta,
      u: Number(a.u || 0) * tb + Number(b.u || 0) * ta,
    };
  }

  function sampleDistXZ(a, b) {
    return Math.hypot((a?.pos?.x || 0) - (b?.pos?.x || 0), (a?.pos?.z || 0) - (b?.pos?.z || 0));
  }

  function pushSampleUnique(out, s, epsXZ = 1e-3) {
    if (!out.length) { out.push(cloneSampleNode(s)); return; }
    const last = out[out.length - 1];
    if (sampleDistXZ(last, s) <= epsXZ && Math.abs((last.pos.y || 0) - (s?.pos?.y || 0)) <= epsXZ) {
      out[out.length - 1] = cloneSampleNode(s);
      return;
    }
    out.push(cloneSampleNode(s));
  }

  // Unit bi-clothoid: curvature ramps linearly up, then linearly down.
  function buildUnitBiClothoid(theta, steps = 18) {
    const th = clamp(Math.abs(theta), 1e-4, Math.PI - 1e-4);
    const segs = clamp(Math.round(steps), 8, 96);
    const ds = 2 / segs;
    let phi = 0;
    let x = 0;
    let y = 0;
    const points = [{ x: 0, y: 0, t: 0 }];
    for (let i = 0; i < segs; i++) {
      const sm = (i + 0.5) * ds;
      const k = sm <= 1 ? (th * sm) : (th * (2 - sm));
      const phiMid = phi + 0.5 * k * ds;
      x += Math.cos(phiMid) * ds;
      y += Math.sin(phiMid) * ds;
      phi += k * ds;
      points.push({ x, y, t: (i + 1) / segs });
    }
    const sinTh = Math.sin(th);
    if (!Number.isFinite(sinTh) || Math.abs(sinTh) < 1e-6) return null;
    const cutY = y / sinTh;
    const denX = 1 + Math.cos(th);
    let cut = cutY;
    if (Math.abs(denX) > 1e-6) {
      const cutX = x / denX;
      if (Number.isFinite(cutX)) cut = (cutY + cutX) * 0.5;
    }
    if (!Number.isFinite(cut) || cut <= 1e-4) return null;
    return { points, cutScale: cut };
  }

  function tryInsertClothoidCorner(out, P, C, N, cfg) {
    const {
      dedupEps = 1e-3,
      minSeg = 0.05,
      width = 4,
      hard = 0,
      relevance = 1,
      ang = 0,
      lin = 0,
      lout = 0,
      din = v3(1, 0, 0),
      dout = v3(1, 0, 0),
    } = cfg || {};
    if (!Number.isFinite(ang) || ang <= 1e-3) return false;
    const rel = clamp(Number(relevance), 0, 1);
    if (rel <= 0.04) return false;
    const turnSign = (din.x * dout.z - din.z * dout.x) >= 0 ? 1 : -1;
    const steps = clamp(Math.round(5 + rel * 10 + hard * 6 + ang * 4), 5, 28);
    const unit = buildUnitBiClothoid(ang, steps);
    if (!unit) return false;

    const targetRadius = width * (0.58 + 0.34 * hard);
    const desiredL = Math.max(minSeg * 0.7, targetRadius * ang);
    const maxCutIn = lin * 0.48;
    const maxCutOut = lout * 0.48;
    const maxL = Math.min(maxCutIn, maxCutOut) / Math.max(unit.cutScale, 1e-6);
    const minL = minSeg * 0.7;
    if (!Number.isFinite(maxL) || maxL <= minL) return false;
    const L = clamp(desiredL, minL, maxL);
    const cut = unit.cutScale * L;
    if (!Number.isFinite(cut) || cut <= minSeg * 0.5 || cut >= lin || cut >= lout) return false;

    const tIn = clamp(cut / lin, 0.04, 0.48);
    const tOut = clamp(cut / lout, 0.04, 0.48);
    const A = lerpSampleNode(C, P, tIn);
    const B = lerpSampleNode(C, N, tOut);
    const left = v3(-din.z, 0, din.x);
    const inward = turnSign >= 0 ? left : mul(left, -1);

    pushSampleUnique(out, A, dedupEps);
    const den = Math.max(1, unit.points.length - 1);
    for (let i = 1; i < unit.points.length - 1; i++) {
      const lp = unit.points[i];
      const ux = lp.x * L;
      const uz = lp.y * L;
      const t = i / den;
      const pXZ = add(add(v3(A.pos.x, 0, A.pos.z), mul(din, ux)), mul(inward, uz));
      pushSampleUnique(out, {
        pos: v3(pXZ.x, (1 - t) * A.pos.y + t * B.pos.y, pXZ.z),
        bank: (1 - t) * Number(A.bank || 0) + t * Number(B.bank || 0),
        u: (1 - t) * Number(A.u || 0) + t * Number(B.u || 0),
      }, dedupEps);
    }
    pushSampleUnique(out, B, dedupEps);
    return true;
  }

  function sanitizeRoadSamples(samples, opts = {}) {
    if (!Array.isArray(samples) || samples.length < 2) return Array.isArray(samples) ? samples.slice() : [];
    const closed = !!opts.closed;
    const width = Math.max(1, Number(opts.width || 4));
    const maxTurn = clamp(Number(opts.maxTurnDeg || 33.33), 8, 160) * Math.PI / 180;
    const pass = Math.max(0, Math.min(4, Number(opts._pass || 0)));
    const useClothoid = opts.useClothoid !== false;
    const minSeg = Math.max(0.04, width * 0.035);
    const dedupEps = Math.max(0.001, minSeg * 0.35);
    const filletScale = 0.42;
    const filletMin = Math.max(minSeg * 1.45, width * 0.34);

    const base = [];
    for (const s of samples) {
      if (!base.length) { base.push(cloneSampleNode(s)); continue; }
      const last = base[base.length - 1];
      if (sampleDistXZ(last, s) < minSeg * 0.65 && Math.abs((last.pos.y || 0) - (s?.pos?.y || 0)) < minSeg * 0.5) {
        base[base.length - 1] = lerpSampleNode(last, cloneSampleNode(s), 0.5);
      } else {
        base.push(cloneSampleNode(s));
      }
    }
    if (closed && base.length > 2 && sampleDistXZ(base[0], base[base.length - 1]) < minSeg * 0.65) base.pop();
    if (base.length < 3) return base;

    const out = [];
    const n = base.length;
    for (let i = 0; i < n; i++) {
      const isEnd = !closed && (i === 0 || i === n - 1);
      if (isEnd) {
        pushSampleUnique(out, base[i], dedupEps);
        continue;
      }
      const pi = (i - 1 + n) % n;
      const ni = (i + 1) % n;
      const P = base[pi];
      const C = base[i];
      const N = base[ni];
      const vin = v3(C.pos.x - P.pos.x, 0, C.pos.z - P.pos.z);
      const vout = v3(N.pos.x - C.pos.x, 0, N.pos.z - C.pos.z);
      const lin = Math.hypot(vin.x, vin.z);
      const lout = Math.hypot(vout.x, vout.z);
      if (lin < minSeg || lout < minSeg) {
        pushSampleUnique(out, C, dedupEps);
        continue;
      }
      const din = v3(vin.x / lin, 0, vin.z / lin);
      const dout = v3(vout.x / lout, 0, vout.z / lout);
      const ang = Math.acos(clamp(din.x * dout.x + din.z * dout.z, -1, 1));
      if (!Number.isFinite(ang) || ang <= maxTurn) {
        pushSampleUnique(out, C, dedupEps);
        continue;
      }

      const hard = clamp((ang - maxTurn) / Math.max(1e-6, Math.PI - maxTurn), 0, 1);
      const segRelevance = clamp(Math.min(lin, lout) / Math.max(0.5, width * 1.6), 0, 1);
      const relevance = hard * segRelevance;
      if (relevance < 0.08) {
        pushSampleUnique(out, C, dedupEps);
        continue;
      }
      if (useClothoid && tryInsertClothoidCorner(out, P, C, N, {
        dedupEps,
        minSeg,
        width,
        hard,
        relevance,
        ang,
        lin,
        lout,
        din,
        dout,
      })) {
        continue;
      }

      const targetRadius = width * (0.58 + 0.34 * hard);
      const tanHalf = Math.max(0.10, Math.tan(ang * 0.5));
      const desiredCut = targetRadius / tanHalf;
      const baseCut = Math.min(lin, lout) * (0.18 + filletScale * hard);
      const cut = clamp(Math.max(baseCut, desiredCut), filletMin, Math.min(lin, lout) * 0.48);
      const tIn = clamp(cut / lin, 0.05, 0.45);
      const tOut = clamp(cut / lout, 0.05, 0.45);
      const A = lerpSampleNode(C, P, tIn);
      const B = lerpSampleNode(C, N, tOut);
      const segs = clamp(Math.round(2 + relevance * 4 + hard * 2), 2, 6);

      pushSampleUnique(out, A, dedupEps);
      for (let k = 1; k < segs; k++) {
        const t = k / segs;
        const qa = lerpSampleNode(A, C, t);
        const qb = lerpSampleNode(C, B, t);
        const q = lerpSampleNode(qa, qb, t);
        pushSampleUnique(out, q, dedupEps);
      }
      pushSampleUnique(out, B, dedupEps);
    }

    if (closed && out.length > 2 && sampleDistXZ(out[0], out[out.length - 1]) < dedupEps * 2) out.pop();
    const sanitized = out.length >= 2 ? out : base;
    if (pass >= 2 || sanitized.length < 3) return sanitized;

    let hasHard = false;
    const n2 = sanitized.length;
    for (let i = 0; i < n2; i++) {
      if (!closed && (i === 0 || i === n2 - 1)) continue;
      const pi = (i - 1 + n2) % n2;
      const ni = (i + 1) % n2;
      const P = sanitized[pi];
      const C = sanitized[i];
      const N = sanitized[ni];
      const vin = v3(C.pos.x - P.pos.x, 0, C.pos.z - P.pos.z);
      const vout = v3(N.pos.x - C.pos.x, 0, N.pos.z - C.pos.z);
      const lin = Math.hypot(vin.x, vin.z);
      const lout = Math.hypot(vout.x, vout.z);
      if (lin < minSeg || lout < minSeg) continue;
      const d = clamp((vin.x * vout.x + vin.z * vout.z) / (lin * lout), -1, 1);
      const ang = Math.acos(d);
      if (Number.isFinite(ang) && ang > maxTurn * 1.03) { hasHard = true; break; }
    }
    if (!hasHard) return sanitized;
    return sanitizeRoadSamples(sanitized, { ...opts, _pass: pass + 1 });
  }

  function sampleRoadNetwork() {
    sanitizeBranchSections();
    sanitizeMainBreaks();
    const subdiv = effectiveSubdiv();
    const roadW = Math.max(1, num('roadWidth'));
    const cornerDeg = 33.33;
    const closedMain = effectiveMainClosed();
    const mainMeta = getMainRoadSpec();
    const mainWidth = roadW * roadWidthMultiplierForSpec(mainMeta);
    const components = mainConnectedComponents();
    const mainComp = components.find((c) => c.length >= 2) || [];
    const mainEdges = [];
    if (mainComp.length >= 2) {
      for (let i = 0; i < mainComp.length - 1; i++) mainEdges.push({ a: mainComp[i], b: mainComp[i + 1] });
      if (closedMain) mainEdges.push({ a: mainComp[mainComp.length - 1], b: mainComp[0] });
    }
    const mainCtrl = mainComp.map((idx) => points[idx]);
    const mainRaw = sampleSpline(mainCtrl, subdiv, closedMain, autoBankCfg());
    const main = sanitizeRoadSamples(mainRaw, { closed: closedMain, width: mainWidth, maxTurnDeg: cornerDeg });
    const branches = [];
    const branchMeta = [];
    for (const comp of components) {
      if (comp.length < 2) continue;
      if (mainComp.length && comp[0] === mainComp[0] && comp[comp.length - 1] === mainComp[mainComp.length - 1]) continue;
      const ctrl = comp.map((idx) => points[idx]);
      const raw = sampleSpline(ctrl, subdiv, false, autoBankCfg());
      const samples = sanitizeRoadSamples(raw, { closed: false, width: mainWidth, maxTurnDeg: cornerDeg });
      if (samples.length > 1) {
        branches.push(samples);
        branchMeta.push({
          ...mainMeta,
          a: comp[0],
          b: comp[comp.length - 1],
          kind: 'join',
          width: mainWidth,
          detached: true,
        });
      }
    }
    for (const sec of branchSections) {
      const secDefaults = getNewBranchSpecDefaults(sec.kind);
      const meta = normalizeRoadEdgeSpec(sec, secDefaults.roadClass, secDefaults.direction);
      const branchWidth = roadW * roadWidthMultiplierForSpec(meta);
      const raw = sampleBranchSection(sec, subdiv);
      const samples = sanitizeRoadSamples(raw, { closed: false, width: branchWidth, maxTurnDeg: cornerDeg });
      if (samples.length > 1) {
        branches.push(samples);
        branchMeta.push({
          ...meta,
          a: sec.a,
          b: sec.b,
          kind: sec.kind === 'fork' ? 'fork' : 'join',
          width: branchWidth,
        });
      }
    }
    const overpass = enforceNetworkGradeSeparation({
      main,
      branches,
      mainClosed: closedMain,
    }, {
      clearance: Math.max(0.75, num('roadThickness') * 1.9),
      blendStrength: 0.34,
    });
    const all = main.slice();
    for (const s of branches) all.push(...s);
    return {
      main,
      branches,
      branchMeta,
      mainMeta: { ...mainMeta, width: mainWidth },
      all,
      subdiv,
      mainClosed: closedMain,
      mainEdges,
      overpass,
    };
  }

  function polylineLen3(samples) {
    if (!Array.isArray(samples) || samples.length < 2) return 0;
    let L = 0;
    for (let i = 1; i < samples.length; i++) L += len(sub(samples[i].pos, samples[i - 1].pos));
    return L;
  }

  function headingXZ(v, fallback = v3(1, 0, 0)) {
    const x = Number(v?.x || 0);
    const z = Number(v?.z || 0);
    const m = Math.hypot(x, z);
    if (m > 1e-6) return v3(x / m, 0, z / m);
    const fx = Number(fallback?.x || 1);
    const fz = Number(fallback?.z || 0);
    const fm = Math.hypot(fx, fz) || 1;
    return v3(fx / fm, 0, fz / fm);
  }

  function alignHeadingTo(h, forwardHint) {
    let out = headingXZ(h, forwardHint);
    const fwd = headingXZ(forwardHint, out);
    if ((out.x * fwd.x + out.z * fwd.z) < 0) out = mul(out, -1);
    return out;
  }

  function signedTurnDegXZ(approach, depart) {
    const a = headingXZ(approach);
    const b = headingXZ(depart, a);
    const d = clamp(a.x * b.x + a.z * b.z, -1, 1);
    const crossY = a.z * b.x - a.x * b.z;
    return Math.atan2(crossY, d) * (180 / Math.PI);
  }

  function classifyTurnDeg(turnDeg) {
    const absDeg = Math.abs(turnDeg);
    if (absDeg >= 155) return 'u_turn';
    if (absDeg <= 24) return 'straight';
    return turnDeg > 0 ? 'right' : 'left';
  }

  function laneIndicesForTurn(laneCount, turnClass) {
    const n = Math.max(1, Math.round(Number(laneCount || 1)));
    if (n === 1) return [0];
    const out = [];
    for (let i = 0; i < n; i++) {
      const p = (i + 0.5) / n; // lane index convention: 0=right-most, n-1=left-most
      let ok = false;
      if (turnClass === 'right') ok = p <= 0.58;
      else if (turnClass === 'left') ok = p >= 0.42;
      else if (turnClass === 'u_turn') ok = p >= 0.72;
      else ok = p >= 0.22 && p <= 0.78;
      if (ok) out.push(i);
    }
    if (out.length) return out;
    let center = 0.5;
    if (turnClass === 'right') center = 0.18;
    else if (turnClass === 'left') center = 0.82;
    else if (turnClass === 'u_turn') center = 0.92;
    return [clamp(Math.round(center * (n - 1)), 0, n - 1)];
  }

  const ROAD_CLASS_PRIORITY = Object.freeze({
    local: 0,
    collector: 1,
    arterial: 2,
    ramp: 2.4,
    freeway: 3.2,
  });

  const CONTROL_TYPE_SHORT = Object.freeze({
    none: '-',
    stop: 'STOP',
    signal: 'SIG',
    roundabout: 'RAB',
    rcut: 'RCUT',
    mut: 'MUT',
    dlt: 'DLT',
    ddi: 'DDI',
    ramp_terminal: 'RAMP',
    yield: 'YLD',
    grade_separated: 'GS',
  });

  function roadClassPriority(cls) {
    const key = roadClassKey(cls);
    return Number(ROAD_CLASS_PRIORITY[key] ?? 1);
  }

  function laneUseForTurn(turn) {
    if (turn === 'left') return 'left_only';
    if (turn === 'right') return 'right_only';
    if (turn === 'u_turn') return 'u_turn_only';
    return 'through_only';
  }

  function pickIceControlType(ctx) {
    const avgSpeed = Number(ctx?.avgSpeed || 0);
    const demandLanes = Number(ctx?.demandLanes || 0);
    const oneWayShare = clamp(Number(ctx?.oneWayShare || 0), 0, 1);
    const hasRamp = !!ctx?.hasRamp;
    const deg = Number(ctx?.deg || 0);
    const nodeType = String(ctx?.nodeType || 'normal');
    const major = Number(ctx?.majorClassRank || 0);
    const highSpeed = avgSpeed >= 50 || major >= roadClassPriority('freeway');

    if (nodeType === 'merge' || nodeType === 'diverge') {
      return { controlType: 'yield', rationale: 'merge_diverge_priority' };
    }
    if (hasRamp || nodeType === 'interchange') {
      if (deg >= 4 && highSpeed && oneWayShare >= 0.42) {
        return { controlType: 'ddi', rationale: 'interchange_highspeed_oneway_bias' };
      }
      return { controlType: 'ramp_terminal', rationale: 'interchange_terminal_default' };
    }
    if (deg <= 2) return { controlType: 'none', rationale: 'non_junction' };
    if (avgSpeed <= 28 && demandLanes <= 4) return { controlType: 'stop', rationale: 'low_speed_low_demand' };
    if (avgSpeed <= 40 && demandLanes <= 8 && oneWayShare < 0.55 && deg <= 4) {
      return { controlType: 'roundabout', rationale: 'moderate_speed_compact_node' };
    }
    if (highSpeed && demandLanes >= 10) {
      if (oneWayShare > 0.62) return { controlType: 'mut', rationale: 'high_speed_median_uturn_strategy' };
      if (demandLanes >= 16) return { controlType: 'dlt', rationale: 'high_demand_displaced_left' };
      return { controlType: 'rcut', rationale: 'high_speed_restricted_crossing_u_turn' };
    }
    if (demandLanes >= 7 || avgSpeed >= 35) return { controlType: 'signal', rationale: 'balanced_signal_candidate' };
    return { controlType: 'stop', rationale: 'default_stop_control' };
  }

  function analyzeNetworkTopology(nodes, directedEdges, laneConnections, junctions) {
    const adj = new Map(nodes.map((n) => [n.id, new Set()]));
    for (const e of directedEdges) {
      if (!adj.has(e.from)) adj.set(e.from, new Set());
      if (!adj.has(e.to)) adj.set(e.to, new Set());
      adj.get(e.from).add(e.to);
      adj.get(e.to).add(e.from);
    }

    const seen = new Set();
    const components = [];
    for (const n of nodes) {
      if (seen.has(n.id)) continue;
      const q = [n.id];
      seen.add(n.id);
      const comp = [];
      while (q.length) {
        const cur = q.pop();
        comp.push(cur);
        const nei = adj.get(cur) || new Set();
        for (const k of nei) {
          if (seen.has(k)) continue;
          seen.add(k);
          q.push(k);
        }
      }
      components.push(comp);
    }

    const orphanNodes = nodes.filter((n) => (n.incoming.length + n.outgoing.length) === 0).map((n) => n.id);
    const deadEndNodes = nodes
      .filter((n) => (n.incoming.length === 0 || n.outgoing.length === 0) && (n.incoming.length + n.outgoing.length) > 0)
      .map((n) => n.id);

    const directedById = new Map(directedEdges.map((e) => [e.id, e]));
    const allowedByIncoming = new Map();
    for (const mv of laneConnections) {
      if (mv.allowed === false) continue;
      const prev = Number(allowedByIncoming.get(mv.fromEdge) || 0);
      allowedByIncoming.set(mv.fromEdge, prev + 1);
    }

    const laneBalanceIssues = [];
    for (const j of junctions) {
      const node = nodes[j.nodeId];
      if (!node) continue;
      const inLanes = node.incoming.reduce((acc, id) => acc + Number(directedById.get(id)?.lanes || 0), 0);
      const outLanes = node.outgoing.reduce((acc, id) => acc + Number(directedById.get(id)?.lanes || 0), 0);
      const ratio = Math.abs(inLanes - outLanes) / Math.max(1, Math.max(inLanes, outLanes));
      if (ratio > 0.65 && (j.type === 'intersection' || j.type === 'interchange')) {
        laneBalanceIssues.push({
          nodeId: j.nodeId,
          incomingLanes: inLanes,
          outgoingLanes: outLanes,
          imbalance: Number(ratio.toFixed(3)),
        });
      }
    }

    const unresolvedIncomingEdges = [];
    for (const e of directedEdges) {
      const exitsAtNode = nodes[e.to]?.outgoing?.length || 0;
      if (exitsAtNode <= 0) continue;
      if (Number(allowedByIncoming.get(e.id) || 0) <= 0) unresolvedIncomingEdges.push(e.id);
    }

    return {
      componentCount: components.length,
      components,
      orphanNodes,
      deadEndNodes,
      laneBalanceIssues,
      unresolvedIncomingEdges,
      hasIssues: !!(orphanNodes.length || deadEndNodes.length || laneBalanceIssues.length || unresolvedIncomingEdges.length),
    };
  }

  function buildRoutingHooks(directedEdges, laneConnections) {
    const directed = directedEdges.map((e) => {
      const speed = Math.max(10, Number(e.speedTarget || 30));
      const len3 = Math.max(0.01, Number(e.length || 0.01));
      const travelCost = len3 / speed;
      return {
        id: e.id,
        from: e.from,
        to: e.to,
        lanes: e.lanes,
        roadClass: e.roadClass,
        speedTarget: speed,
        length: len3,
        travelCost: Number(travelCost.toFixed(6)),
      };
    });

    const penaltyByTurn = {
      straight: 0.03,
      right: 0.06,
      left: 0.11,
      u_turn: 0.22,
    };
    const transitions = [];
    const adjacency = {};
    for (const mv of laneConnections) {
      if (mv.allowed === false) continue;
      const turnPenalty = Number(penaltyByTurn[mv.turn] ?? 0.08);
      const connPenalty = turnPenalty + (mv.turn === 'left' ? 0.015 * Math.max(0, mv.fromLaneIds.length - 1) : 0);
      transitions.push({
        id: mv.id,
        fromEdge: mv.fromEdge,
        toEdge: mv.toEdge,
        turn: mv.turn,
        turnPenalty: Number(turnPenalty.toFixed(6)),
        connectionPenalty: Number(connPenalty.toFixed(6)),
      });
      if (!adjacency[mv.fromEdge]) adjacency[mv.fromEdge] = [];
      if (!adjacency[mv.fromEdge].includes(mv.toEdge)) adjacency[mv.fromEdge].push(mv.toEdge);
    }
    return {
      directedEdges: directed,
      transitions,
      adjacency,
      notes: 'Stage D hook: directed edge travel costs + movement penalties for external routing/traffic modules.',
    };
  }

  function buildRoadNetworkDescriptor(net) {
    const nodes = points.map((p, i) => ({
      id: i,
      x: p.pos.x,
      y: p.pos.y,
      z: p.pos.z,
      incoming: [],
      outgoing: [],
      incident: [],
      type: 'normal',
    }));
    const edges = [];
    const nodePos = (idx) => points[idx]?.pos || v3(0, 0, 0);
    const mainSpec = normalizeRoadEdgeSpec(net.mainMeta || getMainRoadSpec(), 'collector', 'a_to_b');
    const pointCount = points.length;
    const closedMain = !!net?.mainClosed;

    const mainEdges = Array.isArray(net?.mainEdges) && net.mainEdges.length
      ? net.mainEdges.filter((e) => Number.isInteger(e?.a) && Number.isInteger(e?.b))
      : (() => {
        const out = [];
        if (pointCount < 2) return out;
        const segs = closedMain ? pointCount : (pointCount - 1);
        for (let si = 0; si < segs; si++) {
          const a = si;
          const b = closedMain ? (si + 1) % pointCount : (si + 1);
          out.push({ a, b });
        }
        return out;
      })();

    if (mainEdges.length) {
      for (let si = 0; si < mainEdges.length; si++) {
        const a = mainEdges[si].a;
        const b = mainEdges[si].b;
        const pA = nodePos(a);
        const pB = nodePos(b);
        const fallbackAB = headingXZ(sub(pB, pA));
        const hFrom = alignHeadingTo(tangentAtIndex(a), fallbackAB);
        const hTo = alignHeadingTo(tangentAtIndex(b), fallbackAB);
        edges.push({
          id: `main_${a}_${b}`,
          from: a,
          to: b,
          kind: 'main',
          closed: closedMain,
          segmentIndex: si,
          roadClass: mainSpec.roadClass,
          direction: mainSpec.direction,
          lanesForward: mainSpec.lanesForward,
          lanesReverse: mainSpec.lanesReverse,
          speedTarget: mainSpec.speedTarget,
          minRadius: mainSpec.minRadius,
          maxGrade: mainSpec.maxGrade,
          width: Number(net.mainMeta?.width || 0),
          length: len(sub(pB, pA)),
          headingFrom: hFrom,
          headingTo: hTo,
          source: { kind: 'main', segment: si },
        });
      }
    }

    for (let i = 0; i < net.branches.length; i++) {
      const meta = net.branchMeta?.[i] || null;
      if (!meta) continue;
      const from = Number(meta.a);
      const to = Number(meta.b);
      if (!Number.isInteger(from) || !Number.isInteger(to)) continue;
      if (from < 0 || to < 0 || from >= pointCount || to >= pointCount || from === to) continue;
      const smp = Array.isArray(net.branches[i]) ? net.branches[i] : [];
      const pA = nodePos(from);
      const pB = nodePos(to);
      const fallbackAB = headingXZ(sub(pB, pA));
      let hFrom = fallbackAB;
      let hTo = fallbackAB;
      if (smp.length >= 2) {
        hFrom = headingXZ(sub(smp[1].pos, smp[0].pos), fallbackAB);
        hTo = headingXZ(sub(smp[smp.length - 1].pos, smp[smp.length - 2].pos), hFrom);
      }
      edges.push({
        id: `branch_${i}`,
        from,
        to,
        kind: meta.kind === 'fork' ? 'fork' : 'join',
        roadClass: meta.roadClass,
        direction: meta.direction,
        lanesForward: meta.lanesForward,
        lanesReverse: meta.lanesReverse,
        speedTarget: meta.speedTarget,
        minRadius: meta.minRadius,
        maxGrade: meta.maxGrade,
        width: meta.width,
        length: polylineLen3(smp),
        headingFrom: hFrom,
        headingTo: hTo,
        source: { kind: 'branch', section: i },
      });
    }

    for (const e of edges) {
      if (nodes[e.from]) nodes[e.from].incident.push(e.id);
      if (nodes[e.to]) nodes[e.to].incident.push(e.id);
    }

    const directedEdges = [];
    const directedById = new Map();
    const addDirected = (id, edge, from, to, lanes, flowTag, headingFrom, headingTo) => {
      const nLanes = Math.max(0, Math.round(Number(lanes || 0)));
      if (nLanes < 1) return null;
      const d = {
        id,
        edgeId: edge.id,
        edgeKind: edge.kind,
        roadClass: edge.roadClass,
        from,
        to,
        lanes: nLanes,
        flow: flowTag, // a_to_b | b_to_a
        speedTarget: edge.speedTarget,
        width: edge.width,
        length: Number(edge.length || 0),
        headingFrom: headingXZ(headingFrom),
        headingTo: headingXZ(headingTo),
      };
      directedEdges.push(d);
      directedById.set(id, d);
      if (nodes[from]) nodes[from].outgoing.push(id);
      if (nodes[to]) nodes[to].incoming.push(id);
      return d;
    };

    for (const e of edges) {
      const hFrom = headingXZ(e.headingFrom, sub(nodePos(e.to), nodePos(e.from)));
      const hTo = headingXZ(e.headingTo, hFrom);
      const revFrom = mul(hTo, -1);
      const revTo = mul(hFrom, -1);
      const dir = roadDirKey(e.direction);
      if (dir === 'two_way') {
        const f = addDirected(`${e.id}:ab`, e, e.from, e.to, e.lanesForward, 'a_to_b', hFrom, hTo);
        const r = addDirected(`${e.id}:ba`, e, e.to, e.from, e.lanesReverse, 'b_to_a', revFrom, revTo);
        if (f && r) { f.opposite = r.id; r.opposite = f.id; }
      } else if (dir === 'b_to_a') {
        addDirected(`${e.id}:ba`, e, e.to, e.from, e.lanesForward, 'b_to_a', revFrom, revTo);
      } else {
        addDirected(`${e.id}:ab`, e, e.from, e.to, e.lanesForward, 'a_to_b', hFrom, hTo);
      }
    }

    const edgeById = new Map(edges.map((e) => [e.id, e]));
    const junctions = [];
    const laneConnections = [];
    for (const node of nodes) {
      node.incident = Array.from(new Set(node.incident));
      node.incoming = Array.from(new Set(node.incoming));
      node.outgoing = Array.from(new Set(node.outgoing));

      const incoming = node.incoming.map((id) => directedById.get(id)).filter(Boolean);
      const outgoing = node.outgoing.map((id) => directedById.get(id)).filter(Boolean);
      const edgeClasses = node.incident.map((eid) => edgeById.get(eid)?.roadClass).filter(Boolean);
      const hasRamp = edgeClasses.includes('ramp');
      const deg = node.incident.length;
      const majorClassRank = edgeClasses.length ? Math.max(...edgeClasses.map((c) => roadClassPriority(c))) : roadClassPriority('local');
      const oneWayCount = node.incident.reduce((acc, eid) => {
        const dir = roadDirKey(edgeById.get(eid)?.direction);
        return acc + (dir === 'two_way' ? 0 : 1);
      }, 0);
      const oneWayShare = deg > 0 ? (oneWayCount / deg) : 0;
      const demandLanes = incoming.reduce((acc, e) => acc + Number(e.lanes || 0), 0);

      let nodeType = 'normal';
      if (hasRamp && deg >= 3) nodeType = 'interchange';
      else if (incoming.length <= 1 && outgoing.length >= 2) nodeType = 'diverge';
      else if (incoming.length >= 2 && outgoing.length <= 1) nodeType = 'merge';
      else if (deg >= 3 || (incoming.length >= 2 && outgoing.length >= 2)) nodeType = 'intersection';
      node.type = nodeType;

      const movements = [];
      for (const inEdge of incoming) {
        let candidates = outgoing.filter((outEdge) => outEdge.id !== inEdge.opposite);
        if (!candidates.length && inEdge.opposite) {
          const uTurnOnly = outgoing.find((outEdge) => outEdge.id === inEdge.opposite);
          if (uTurnOnly) candidates = [uTurnOnly];
        }
        for (const outEdge of candidates) {
          const turnDeg = signedTurnDegXZ(inEdge.headingTo, outEdge.headingFrom);
          const turn = classifyTurnDeg(turnDeg);
          const inLaneIds = laneIndicesForTurn(inEdge.lanes, turn);
          const laneUseControl = laneUseForTurn(turn);
          const lanePairs = [];
          const nInSel = Math.max(1, inLaneIds.length);
          const nOut = Math.max(1, outEdge.lanes);
          for (let i = 0; i < inLaneIds.length; i++) {
            const outLane = clamp(Math.round((((i + 0.5) / nInSel) * nOut) - 0.5), 0, nOut - 1);
            lanePairs.push({ fromLane: inLaneIds[i], toLane: outLane, use: laneUseControl });
          }
          const isHighSpeedEdge = (e) => e.roadClass === 'freeway' || e.roadClass === 'ramp' || Number(e.speedTarget || 0) >= 55;
          const restrictedUTurn = (turn === 'u_turn') && (isHighSpeedEdge(inEdge) || isHighSpeedEdge(outEdge));
          const allowed = !restrictedUTurn;
          const movement = {
            id: `n${node.id}:${inEdge.id}->${outEdge.id}`,
            viaNode: node.id,
            fromEdge: inEdge.id,
            toEdge: outEdge.id,
            fromNode: inEdge.from,
            toNode: outEdge.to,
            turn,
            turnDeg: Number(turnDeg.toFixed(2)),
            fromLaneIds: inLaneIds,
            lanePairs,
            laneUseControl,
            allowed,
            restriction: allowed ? null : 'u_turn_blocked_high_speed',
          };
          movements.push(movement);
          laneConnections.push(movement);
        }
      }

      const avgSpeed = node.incident.length
        ? node.incident.reduce((acc, eid) => acc + Number(edgeById.get(eid)?.speedTarget || 0), 0) / node.incident.length
        : 0;
      const ice = pickIceControlType({
        nodeType,
        avgSpeed,
        demandLanes,
        oneWayShare,
        hasRamp,
        deg,
        majorClassRank,
      });
      const controlType = ice.controlType;
      const controlHint = controlType === 'none'
        ? 'none'
        : (controlType === 'ramp_terminal' || controlType === 'ddi' ? 'grade_separated' : controlType);
      const turnRestrictions = movements
        .filter((m) => m.allowed === false)
        .map((m) => ({ movementId: m.id, reason: m.restriction }));
      node.controlType = controlType;

      if (movements.length || nodeType !== 'normal') {
        junctions.push({
          id: `j_${node.id}`,
          nodeId: node.id,
          type: nodeType,
          controlType,
          controlHint,
          controlShort: CONTROL_TYPE_SHORT[controlType] || controlType.toUpperCase(),
          iceRationale: ice.rationale,
          iceMetrics: {
            avgSpeed: Number(avgSpeed.toFixed(2)),
            demandLanes,
            oneWayShare: Number(oneWayShare.toFixed(3)),
            majorClassRank: Number(majorClassRank.toFixed(2)),
          },
          incoming: incoming.map((e) => e.id),
          outgoing: outgoing.map((e) => e.id),
          laneConnections: movements,
          turnRestrictions,
        });
      }
    }

    const topology = analyzeNetworkTopology(nodes, directedEdges, laneConnections, junctions);
    const routing = buildRoutingHooks(directedEdges, laneConnections);
    const restrictedMovementCount = laneConnections.filter((m) => m.allowed === false).length;

    return {
      nodes,
      edges,
      directedEdges,
      junctions,
      laneConnections,
      topology,
      routing,
      summary: {
        nodeCount: nodes.length,
        edgeCount: edges.length,
        directedEdgeCount: directedEdges.length,
        junctionCount: junctions.length,
        laneConnectionCount: laneConnections.length,
        restrictedMovementCount,
        topologyIssueCount:
          topology.orphanNodes.length +
          topology.deadEndNodes.length +
          topology.laneBalanceIssues.length +
          topology.unresolvedIncomingEdges.length,
      },
      controlLegend: CONTROL_TYPE_SHORT,
    };
  }

  function cloneMesh(mesh, nameOverride = null) {
    return {
      name: nameOverride || mesh.name,
      verts: mesh.verts.map((p) => v3(p.x, p.y, p.z)),
      uvs: mesh.uvs.map((uv) => ({ u: uv.u, v: uv.v })),
      faces: mesh.faces.map((f) => ({ ...f })),
    };
  }

  function mergeMeshInto(dst, src) {
    const vOff = dst.verts.length;
    const uvOff = dst.uvs.length;
    for (const p of src.verts) dst.verts.push(v3(p.x, p.y, p.z));
    for (const uv of src.uvs) dst.uvs.push({ u: uv.u, v: uv.v });
    for (const f of src.faces) {
      dst.faces.push({
        a: f.a + vOff,
        b: f.b + vOff,
        c: f.c + vOff,
        au: f.au + uvOff,
        bu: f.bu + uvOff,
        cu: f.cu + uvOff,
      });
    }
  }

  function addJunctionPads(roadTop, width, opts = {}) {
    sanitizeBranchSections();
    if (!roadTop || !Array.isArray(roadTop.verts)) return;
    const used = new Set();
    const junctionIdx = [];
    for (const sec of branchSections) {
      if (Number.isInteger(sec.a) && !used.has(sec.a)) { used.add(sec.a); junctionIdx.push(sec.a); }
      if (Number.isInteger(sec.b) && !used.has(sec.b)) { used.add(sec.b); junctionIdx.push(sec.b); }
    }
    const net = opts?.net || null;
    const mergeable = net ? gatherMergeableCrossings(net, {
      clearance: Math.max(0.75, num('roadThickness') * 1.9),
    }) : [];
    if (!junctionIdx.length && !mergeable.length) return;

    const worldUp = v3(0, 1, 0);
    const roadSides = opts?.roadSides || null;
    const roadBottom = opts?.roadBottom || null;
    const thickness = Math.max(0.02, Number(opts?.thickness || num('roadThickness') || 0.2));
    const padCenters = [];
    const plannedPads = [];
    const addRingStrip = (mesh, inner, outer) => {
      const n = Math.min(inner.length, outer.length);
      if (n < 3) return;
      const pushTriUp = (a, b, c) => {
        const A = mesh.verts[a - 1];
        const B = mesh.verts[b - 1];
        const C = mesh.verts[c - 1];
        if (!A || !B || !C) return;
        const nrm = cross(sub(B, A), sub(C, A));
        if (dot(nrm, worldUp) < 0) meshAddTri(mesh, a, c, b);
        else meshAddTri(mesh, a, b, c);
      };
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const a0 = inner[i], a1 = inner[j];
        const b0 = outer[i], b1 = outer[j];
        pushTriUp(a0, b0, b1);
        pushTriUp(a0, b1, a1);
      }
    };

    const ringSteps = 22;
    const yLift = 0.022;
    const r0 = Math.max(0.14, width * 0.16);
    const r1 = Math.max(r0 + 0.08, width * 0.40);
    const r2 = Math.max(r1 + 0.08, width * 0.70);
    const drawPadAt = (p, t, radiusMul = 1) => {
      t = norm(v3(t.x, 0, t.z));
      if (Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
      const r = norm(v3(-t.z, 0, t.x));
      const rings = [[], [], []];
      const radii = [r0 * radiusMul, r1 * radiusMul, r2 * radiusMul];
      const center = meshAddVertex(roadTop, v3(p.x, p.y + yLift + 0.0035, p.z), 0.5, 0);
      for (let ri = 0; ri < radii.length; ri++) {
        const rr = radii[ri];
        const vv = ri / Math.max(1, radii.length - 1);
        for (let k = 0; k < ringSteps; k++) {
          const a = (k / ringSteps) * Math.PI * 2;
          const offs = add(mul(r, Math.cos(a) * rr), mul(t, Math.sin(a) * rr));
          const vx = p.x + offs.x;
          const vz = p.z + offs.z;
          const vy = p.y + yLift - vv * 0.006;
          rings[ri].push(meshAddVertex(roadTop, v3(vx, vy, vz), (k / ringSteps), vv));
        }
      }
      // Fill center to hide underlying overlap seams.
      for (let i = 0; i < ringSteps; i++) {
        const j = (i + 1) % ringSteps;
        meshAddTri(roadTop, center, rings[0][i], rings[0][j]);
      }
      addRingStrip(roadTop, rings[0], rings[1]);
      addRingStrip(roadTop, rings[1], rings[2]);
    };

    const faceCenter = (mesh, f) => {
      const A = mesh?.verts?.[(f.a || 1) - 1];
      const B = mesh?.verts?.[(f.b || 1) - 1];
      const C = mesh?.verts?.[(f.c || 1) - 1];
      if (!A || !B || !C) return null;
      return v3((A.x + B.x + C.x) / 3, (A.y + B.y + C.y) / 3, (A.z + B.z + C.z) / 3);
    };
    const carveMeshAtPads = (mesh, radiusKey, yBand = Infinity) => {
      if (!mesh || !Array.isArray(mesh.faces) || !mesh.faces.length || !padCenters.length) return;
      const maxSafeFaces = 120000;
      if (mesh.faces.length > maxSafeFaces) return;
      const maxPadR = padCenters.reduce((m, p) => Math.max(m, Number(p?.[radiusKey] || 0)), 0);
      const cell = Math.max(0.5, maxPadR * 1.35);
      const grid = new Map();
      const key = (ix, iz) => `${ix}|${iz}`;
      for (let i = 0; i < padCenters.length; i++) {
        const p = padCenters[i];
        const r = Math.max(0.1, Number(p?.[radiusKey] || 0));
        const minX = Math.floor((p.p.x - r) / cell);
        const maxX = Math.floor((p.p.x + r) / cell);
        const minZ = Math.floor((p.p.z - r) / cell);
        const maxZ = Math.floor((p.p.z + r) / cell);
        for (let ix = minX; ix <= maxX; ix++) {
          for (let iz = minZ; iz <= maxZ; iz++) {
            const k = key(ix, iz);
            let arr = grid.get(k);
            if (!arr) { arr = []; grid.set(k, arr); }
            arr.push(i);
          }
        }
      }
      mesh.faces = mesh.faces.filter((f) => {
        const c = faceCenter(mesh, f);
        if (!c) return true;
        const arr = grid.get(key(Math.floor(c.x / cell), Math.floor(c.z / cell)));
        if (!arr || !arr.length) return true;
        for (const pi of arr) {
          const pad = padCenters[pi];
          if (Math.abs(c.y - pad.p.y) > yBand) continue;
          const dx = c.x - pad.p.x;
          const dz = c.z - pad.p.z;
          const r = pad[radiusKey];
          if ((dx * dx + dz * dz) <= (r * r)) return false;
        }
        return true;
      });
    };
    const addVerticalShell = (mesh) => {
      if (!mesh || !padCenters.length) return;
      const steps = 16;
      for (const pad of padCenters) {
        const r = pad.rShell;
        const yTop = pad.p.y + 0.004;
        const yBot = pad.p.y - thickness - 0.01;
        const ringTop = [];
        const ringBot = [];
        for (let i = 0; i < steps; i++) {
          const a = (i / steps) * Math.PI * 2;
          const ca = Math.cos(a), sa = Math.sin(a);
          const px = pad.p.x + ca * r;
          const pz = pad.p.z + sa * r;
          ringTop.push(meshAddVertex(mesh, v3(px, yTop, pz), i / steps, 0));
          ringBot.push(meshAddVertex(mesh, v3(px, yBot, pz), i / steps, 1));
        }
        for (let i = 0; i < steps; i++) {
          const j = (i + 1) % steps;
          meshAddTri(mesh, ringTop[i], ringBot[j], ringBot[i]);
          meshAddTri(mesh, ringTop[i], ringTop[j], ringBot[j]);
        }
      }
    };

    for (const idx of junctionIdx) {
      const p = points[idx]?.pos;
      if (!p) continue;
      const t = tangentAtIndex(idx);
      plannedPads.push({ p: v3(p.x, p.y, p.z), t, mul: 1 });
      const rr = Math.max(r2 * 1.06, width * 0.64);
      padCenters.push({ p: v3(p.x, p.y, p.z), rTop: rr, rShell: Math.max(rr * 0.95, width * 0.54) });
    }
    const maxMergePads = 96;
    for (let i = 0; i < mergeable.length && i < maxMergePads; i++) {
      const m = mergeable[i];
      const p = v3(m.x, m.y, m.z);
      const a0 = m.a?.p0 || null;
      const a1 = m.a?.p1 || null;
      const t = (a0 && a1) ? norm(v3(a1.x - a0.x, 0, a1.z - a0.z)) : v3(1, 0, 0);
      plannedPads.push({ p, t, mul: 1.12 });
      const rr = Math.max(r2 * 1.20, width * 0.70);
      padCenters.push({ p, rTop: rr, rShell: Math.max(rr * 0.95, width * 0.58) });
    }
    carveMeshAtPads(roadTop, 'rTop', Math.max(0.26, thickness * 2.2));
    carveMeshAtPads(roadSides, 'rShell', thickness * 3.8);
    carveMeshAtPads(roadBottom, 'rShell', thickness * 3.8);
    for (const pad of plannedPads) drawPadAt(pad.p, pad.t, pad.mul);
    addVerticalShell(roadSides);
    addVerticalShell(roadBottom);
  }

  // ---------- mesh generation ----------
  function buildRoadMesh(samples, opts) {
    const { width, thickness, includeSides, uvScale, capEnds = false, closed = false } = opts;
    const half = width / 2;
    const pointCount = samples.length;
    if (pointCount < 2) return { roadTop: { name: 'road_top', verts: [], uvs: [], faces: [] }, roadSides: null, roadBottom: null, frames: [] };
    const dists = [0];
    for (let i = 1; i < pointCount; i++) dists.push(dists[i - 1] + len(sub(samples[i].pos, samples[i - 1].pos)));
    const segCount = closed ? pointCount : pointCount - 1;

    const roadTop = { name: 'road_top', verts: [], uvs: [], faces: [] };
    const frames = [];
    const worldUp = v3(0, 1, 0);
    let prevR = v3(1, 0, 0);
    const triEps = Math.max(1e-6, width * 0.0008);
    const triArea = (a, b, c) => len(cross(sub(b, a), sub(c, a)));
    const pushFaceOriented = (mesh, a, b, c, au, bu, cu, ref = null) => {
      const A = mesh.verts[a - 1];
      const B = mesh.verts[b - 1];
      const C = mesh.verts[c - 1];
      if (!A || !B || !C) return;
      if (triArea(A, B, C) <= triEps) return;
      let aa = a, bb = b, cc = c;
      let aau = au, bbu = bu, ccu = cu;
      if (ref && Number.isFinite(ref.x) && Number.isFinite(ref.y) && Number.isFinite(ref.z)) {
        const nrm = cross(sub(B, A), sub(C, A));
        if (dot(nrm, ref) < 0) {
          bb = c; cc = b;
          bbu = cu; ccu = bu;
        }
      }
      mesh.faces.push({ a: aa, b: bb, c: cc, au: aau, bu: bbu, cu: ccu });
    };

    for (let i = 0; i < pointCount; i++) {
      const prev = samples[closed ? ((i - 1 + pointCount) % pointCount) : Math.max(0, i - 1)].pos;
      const next = samples[closed ? ((i + 1) % pointCount) : Math.min(pointCount - 1, i + 1)].pos;
      const T = norm(sub(next, prev));
      let R = cross(worldUp, T);
      if (len(R) < 1e-6) R = prevR; else R = norm(R);
      let U = norm(cross(T, R));
      const bankRad = (samples[i].bank || 0) * Math.PI / 180;
      R = rotateAxis(R, T, bankRad);
      U = rotateAxis(U, T, bankRad);
      if (i > 0 && dot(R, prevR) < 0) {
        R = mul(R, -1);
        U = mul(U, -1);
      }
      prevR = R;
      frames.push({ T, R, U });
    }

    for (let i = 0; i < pointCount; i++) {
      const P = samples[i].pos;
      const R = frames[i].R;
      const left = add(P, mul(R, half));
      const right = add(P, mul(R, -half));
      const u = ((dists[i] / uvScale) % 1 + 1) % 1;
      roadTop.verts.push(left); roadTop.uvs.push({ u, v: 0 });
      roadTop.verts.push(right); roadTop.uvs.push({ u, v: 1 });
    }
    for (let i = 0; i < segCount; i++) {
      const j = closed ? ((i + 1) % pointCount) : (i + 1);
      const aL = i * 2 + 1, aR = i * 2 + 2, bL = j * 2 + 1, bR = j * 2 + 2;
      // Corner-aware quad split: choose the diagonal that better conforms to local curve geometry.
      const pAL = roadTop.verts[aL - 1];
      const pAR = roadTop.verts[aR - 1];
      const pBL = roadTop.verts[bL - 1];
      const pBR = roadTop.verts[bR - 1];
      const dMain = Math.hypot(pAL.x - pBR.x, pAL.y - pBR.y, pAL.z - pBR.z);
      const dAlt = Math.hypot(pAR.x - pBL.x, pAR.y - pBL.y, pAR.z - pBL.z);
      let topRef = add(frames[i].U, frames[j].U);
      if (len(topRef) < 1e-6) topRef = worldUp;
      else topRef = norm(topRef);
      if (dMain <= dAlt) {
        pushFaceOriented(roadTop, aL, bL, bR, aL, bL, bR, topRef);
        pushFaceOriented(roadTop, aL, bR, aR, aL, bR, aR, topRef);
      } else {
        pushFaceOriented(roadTop, aL, bL, aR, aL, bL, aR, topRef);
        pushFaceOriented(roadTop, aR, bL, bR, aR, bL, bR, topRef);
      }
    }

    let roadSides = null;
    let roadBottom = null;
    if (includeSides) {
      roadSides = { name: 'road_sides', verts: [], uvs: [], faces: [] };
      roadBottom = { name: 'road_bottom', verts: [], uvs: [], faces: [] };
      for (let i = 0; i < pointCount; i++) {
        const P = samples[i].pos;
        const R = frames[i].R;
        const lt = add(P, mul(R, half));
        const lb = add(lt, v3(0, -thickness, 0));
        const rt = add(P, mul(R, -half));
        const rb = add(rt, v3(0, -thickness, 0));
        const u = ((dists[i] / uvScale) % 1 + 1) % 1;
        roadSides.verts.push(lt); roadSides.uvs.push({ u, v: 0 });
        roadSides.verts.push(lb); roadSides.uvs.push({ u, v: 1 });
        roadSides.verts.push(rt); roadSides.uvs.push({ u, v: 0 });
        roadSides.verts.push(rb); roadSides.uvs.push({ u, v: 1 });
        roadBottom.verts.push(lb); roadBottom.uvs.push({ u, v: 0 });
        roadBottom.verts.push(rb); roadBottom.uvs.push({ u, v: 1 });
      }
      for (let i = 0; i < segCount; i++) {
        const j = closed ? ((i + 1) % pointCount) : (i + 1);
        const base0 = i * 4, base1 = j * 4;
        const lt0 = base0 + 1, lb0 = base0 + 2, rt0 = base0 + 3, rb0 = base0 + 4;
        const lt1 = base1 + 1, lb1 = base1 + 2, rt1 = base1 + 3, rb1 = base1 + 4;
        let rAvg = add(frames[i].R, frames[j].R);
        if (len(rAvg) < 1e-6) rAvg = frames[i].R;
        rAvg = norm(rAvg);
        let uAvg = add(frames[i].U, frames[j].U);
        if (len(uAvg) < 1e-6) uAvg = frames[i].U;
        uAvg = norm(uAvg);
        pushFaceOriented(roadSides, lt0, lb1, lb0, lt0, lb1, lb0, rAvg);
        pushFaceOriented(roadSides, lt0, lt1, lb1, lt0, lt1, lb1, rAvg);
        pushFaceOriented(roadSides, rt0, rb0, rb1, rt0, rb0, rb1, mul(rAvg, -1));
        pushFaceOriented(roadSides, rt0, rb1, rt1, rt0, rb1, rt1, mul(rAvg, -1));

        const b0 = i * 2;
        const b1 = j * 2;
        const bl0 = b0 + 1, br0 = b0 + 2;
        const bl1 = b1 + 1, br1 = b1 + 2;
        const pBL0 = roadBottom.verts[bl0 - 1];
        const pBR0 = roadBottom.verts[br0 - 1];
        const pBL1 = roadBottom.verts[bl1 - 1];
        const pBR1 = roadBottom.verts[br1 - 1];
        const dMain = Math.hypot(pBL0.x - pBR1.x, pBL0.y - pBR1.y, pBL0.z - pBR1.z);
        const dAlt = Math.hypot(pBR0.x - pBL1.x, pBR0.y - pBL1.y, pBR0.z - pBL1.z);
        const botRef = mul(uAvg, -1);
        if (dMain <= dAlt) {
          pushFaceOriented(roadBottom, bl0, bl1, br1, bl0, bl1, br1, botRef);
          pushFaceOriented(roadBottom, bl0, br1, br0, bl0, br1, br0, botRef);
        } else {
          pushFaceOriented(roadBottom, bl0, bl1, br0, bl0, bl1, br0, botRef);
          pushFaceOriented(roadBottom, br0, bl1, br1, br0, bl1, br1, botRef);
        }
      }
      if (capEnds && !closed && pointCount >= 2) {
        const ltS = 1, lbS = 2, rtS = 3, rbS = 4;
        const bE = (pointCount - 1) * 4;
        const ltE = bE + 1, lbE = bE + 2, rtE = bE + 3, rbE = bE + 4;
        const startRef = mul(frames[0].T, -1);
        const endRef = frames[pointCount - 1].T;
        pushFaceOriented(roadSides, ltS, rbS, lbS, ltS, rbS, lbS, startRef);
        pushFaceOriented(roadSides, ltS, rtS, rbS, ltS, rtS, rbS, startRef);
        pushFaceOriented(roadSides, ltE, lbE, rbE, ltE, lbE, rbE, endRef);
        pushFaceOriented(roadSides, ltE, rbE, rtE, ltE, rbE, rtE, endRef);
      }
    }

    return { roadTop, roadSides, roadBottom, frames };
  }

  function buildTerrainMesh(samples, opts) {
    if (!samples || samples.length < 2) return null;
    const roadWidth = Math.max(1, opts.roadWidth || 4);
    const roadThickness = Math.max(0.02, opts.roadThickness || 0.7);
    const shoulderWidth = Math.max(0.2, opts.shoulderWidth || 2.4);
    const roughness = Math.max(0, opts.roughness || 1);
    const cliffHeight = Math.max(0.5, opts.cliffHeight || 4);
    const kartStyle = clamp(Number.isFinite(opts.kartStyle) ? opts.kartStyle : 0.78, 0, 1);
    const detail = clamp(Number.isFinite(opts.detail) ? opts.detail : 0.62, 0, 1);
    const islandEnabled = !!opts.islandEnabled;
    const islandOffset = Math.max(0, Number.isFinite(opts.islandOffset) ? opts.islandOffset : 28);
    const islandFalloff = Math.max(2, Number.isFinite(opts.islandFalloff) ? opts.islandFalloff : 24);
    const islandDrop = Math.max(0, Number.isFinite(opts.islandDrop) ? opts.islandDrop : 8);
    const margin = Math.max(22, roadWidth * 7.5, islandEnabled ? (islandOffset + islandFalloff + roadWidth * 2.5 + 12) : 0);
    const cellBase = 2.35 - 0.55 * kartStyle;
    const cell = clamp(cellBase * (1.18 - detail * 0.58), 0.85, 2.6);

    let minX = +1e9, minY = +1e9, minZ = +1e9, maxX = -1e9, maxZ = -1e9;
    for (const s of samples) {
      minX = Math.min(minX, s.pos.x); minY = Math.min(minY, s.pos.y); minZ = Math.min(minZ, s.pos.z);
      maxX = Math.max(maxX, s.pos.x); maxZ = Math.max(maxZ, s.pos.z);
    }
    minX -= margin; maxX += margin; minZ -= margin; maxZ += margin;

    const maxGrid = Math.round((samples.length > 1100 ? 108 : 148) + detail * 70);
    const minGrid = Math.round(24 + detail * 18);
    const nx = clamp(Math.floor((maxX - minX) / cell) + 1, minGrid, maxGrid);
    const nz = clamp(Math.floor((maxZ - minZ) / cell) + 1, minGrid, maxGrid);
    const sx = (maxX - minX) / (nx - 1);
    const sz = (maxZ - minZ) / (nz - 1);
    const probeStep = samples.length > 1200 ? 3 : (samples.length > 700 ? 2 : 1);
    const curbWidth = clamp(0.22 + shoulderWidth * 0.2, 0.18, 0.95);
    const supportPad = Math.max(0.8, roadWidth * 0.46);
    const supportEdge = roadWidth * 0.5 + curbWidth + shoulderWidth + supportPad;
    const strictProbeRadiusBase = roadWidth * 1.45 + shoulderWidth * 1.05 + curbWidth * 0.9;
    const halfRoad = roadWidth * 0.5;
    const slopeLen = 4.8 + cliffHeight * 0.8;
    const baseY = minY - (1.4 + cliffHeight * 0.55);
    const bridgeGap = Math.max(1.05, roadThickness + 0.55);
    const terrainUnderRoadBias = 0.14 + roadThickness * 0.05;
    const postSmoothGap = 0.02 + roadThickness * 0.02;
    const roadClearance = clamp(
      Number.isFinite(opts.roadClearance) ? opts.roadClearance : (0.12 + roadThickness * 0.18),
      0.05,
      1.6
    );
    // Keep terrain close to road shoulders while preserving under-road clearance near center.
    const stitchClearance = clamp(0.03 + roadThickness * 0.16, 0.03, 0.22);
    const clearanceAt = (t) => {
      const tt = clamp(t, 0, 1);
      return stitchClearance + (roadClearance - stitchClearance) * Math.pow(1 - tt, 1.9);
    };
    const followRoad = clamp(Number.isFinite(opts.followRoad) ? opts.followRoad : 0.88, 0, 1);
    const shoulderBevelDepth = 0.16 + shoulderWidth * 0.08;
    const islandInner = supportEdge + islandOffset;
    const islandOuter = islandInner + islandFalloff;

    const terrain = { name: 'terrain_cliffs', verts: [], uvs: [], faces: [] };
    const smoothstep = (a, b, x) => {
      const t = clamp((x - a) / Math.max(1e-6, b - a), 0, 1);
      return t * t * (3 - 2 * t);
    };
    const noise2 = (x, z) => {
      const a = Math.sin(x * 0.31 + z * 0.19);
      const b = Math.cos(x * 0.17 - z * 0.27);
      return (a + b) * 0.5;
    };
    const crossingZones = (() => {
      const zones = [];
      const nS = samples.length;
      const minSep = Math.max(14, Math.floor(nS * 0.08));
      const pairStep = nS > 520 ? 3 : 2;
      const hitDist = Math.max(1.8, roadWidth * 0.95 + shoulderWidth * 0.45);
      const maxParallelDot = Math.cos(18 * Math.PI / 180);
      const tangentAt = (idx) => {
        const a = samples[Math.max(0, idx - 1)].pos;
        const b = samples[Math.min(nS - 1, idx + 1)].pos;
        let t = v3(b.x - a.x, 0, b.z - a.z);
        if (len(t) < 1e-6) t = v3(1, 0, 0);
        return norm(t);
      };
      for (let i = 0; i < nS; i += pairStep) {
        const pi = samples[i].pos;
        const ti = tangentAt(i);
        for (let j = i + minSep; j < nS; j += pairStep) {
          if (Math.abs(j - i) < minSep) continue;
          const pj = samples[j].pos;
          const d = Math.hypot(pi.x - pj.x, pi.z - pj.z);
          if (d > hitDist) continue;
          const tj = tangentAt(j);
          if (Math.abs(dot(ti, tj)) > maxParallelDot) continue;
          const dy = pj.y - pi.y;
          if (Math.abs(dy) < bridgeGap) continue;
          const lowerIdx = dy > 0 ? i : j;
          const lowerP = samples[lowerIdx].pos;
          const lowerT = tangentAt(lowerIdx);
          const zone = {
            cx: lowerP.x,
            cz: lowerP.z,
            lowerY: lowerP.y,
            t: lowerT,
            major: roadWidth * 5.6 + shoulderWidth * 3.1 + Math.abs(dy) * 1.35,
            minor: roadWidth * 2.6 + shoulderWidth * 1.55,
            weight: clamp(Math.abs(dy) / Math.max(1e-6, bridgeGap * 2.1), 0.55, 1.15),
          };
          let merged = false;
          for (const z of zones) {
            if (Math.hypot(z.cx - zone.cx, z.cz - zone.cz) < roadWidth * 1.8) {
              if (zone.weight > z.weight) {
                z.cx = zone.cx; z.cz = zone.cz; z.lowerY = zone.lowerY; z.t = zone.t;
              }
              z.major = Math.max(z.major, zone.major);
              z.minor = Math.max(z.minor, zone.minor);
              z.weight = Math.max(z.weight, zone.weight);
              merged = true;
              break;
            }
          }
          if (!merged) zones.push(zone);
        }
      }
      return zones;
    })();
    const junctionZones = (() => {
      const out = [];
      if (!Array.isArray(branchSections) || !branchSections.length) return out;
      const used = new Set();
      for (const sec of branchSections) {
        for (const i of [sec.a, sec.b]) {
          if (!Number.isInteger(i) || i < 0 || i >= points.length || used.has(i)) continue;
          used.add(i);
          const p = points[i]?.pos;
          if (!p) continue;
          out.push({
            x: p.x,
            z: p.z,
            y: p.y,
            r: roadWidth * 0.95 + shoulderWidth * 1.05 + curbWidth * 0.95,
          });
        }
      }
      return out;
    })();

    const hField = new Float64Array(nx * nz);
    const capField = new Float64Array(nx * nz);
    const dField = new Float64Array(nx * nz);
    const boostField = new Float64Array(nx * nz);
    const roadMaskField = new Float32Array(nx * nz);
    const islandMaskField = new Float32Array(nx * nz);

    for (let iz = 0; iz < nz; iz++) {
      for (let ix = 0; ix < nx; ix++) {
        const x = minX + ix * sx;
        const z = minZ + iz * sz;
        let d1 = 1e9, d2 = 1e9, d3 = 1e9, d4 = 1e9;
        let y1 = minY, y2 = minY, y3 = minY, y4 = minY;
        let b1 = 0, b2 = 0, b3 = 0, b4 = 0;
        // Primary distance from road polyline segments (not only sample points),
        // so terrain shoulders conform smoothly to the road curve shape.
        let dSeg = 1e9;
        let ySeg = minY;
        let bSeg = 0;
        let deckSegY = minY;
        let edgeDistSeg = 1e9;
        for (let k = 0; k < samples.length - 1; k += probeStep) {
          const a = samples[k];
          const b = samples[Math.min(samples.length - 1, k + probeStep)];
          const ax = a.pos.x, az = a.pos.z;
          const bx = b.pos.x, bz = b.pos.z;
          const vx = bx - ax, vz = bz - az;
          const vLen2 = vx * vx + vz * vz;
          if (vLen2 < 1e-8) continue;
          let t = ((x - ax) * vx + (z - az) * vz) / vLen2;
          t = clamp(t, 0, 1);
          const qx = ax + vx * t;
          const qz = az + vz * t;
          const d = Math.hypot(x - qx, z - qz);
          if (d < dSeg) {
            dSeg = d;
            const yL = a.pos.y * (1 - t) + b.pos.y * t;
            const bankL = (a.bank || 0) * (1 - t) + (b.bank || 0) * t;
            const tx = vx / Math.sqrt(vLen2);
            const tz = vz / Math.sqrt(vLen2);
            const rx = -tz, rz = tx;
            const dx = x - qx, dz = z - qz;
            const lateral = dx * rx + dz * rz;
            const lateralDeck = clamp(lateral, -halfRoad, halfRoad);
            const deckY = yL + Math.tan(bankL * Math.PI / 180) * lateralDeck;
            ySeg = yL;
            bSeg = bankL;
            deckSegY = deckY;
            edgeDistSeg = Math.max(0, Math.abs(lateral) - halfRoad);
          }
        }
        for (let k = 0; k < samples.length; k += probeStep) {
          const p = samples[k].pos;
          const d = Math.hypot(x - p.x, z - p.z);
          if (d < d1) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d2; y3 = y2; b3 = b2;
            d2 = d1; y2 = y1; b2 = b1;
            d1 = d; y1 = p.y; b1 = samples[k].bank || 0;
          } else if (d < d2) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d2; y3 = y2; b3 = b2;
            d2 = d; y2 = p.y; b2 = samples[k].bank || 0;
          } else if (d < d3) {
            d4 = d3; y4 = y3; b4 = b3;
            d3 = d; y3 = p.y; b3 = samples[k].bank || 0;
          } else if (d < d4) {
            d4 = d; y4 = p.y; b4 = samples[k].bank || 0;
          }
        }
        if (dSeg < d1) {
          d4 = d3; y4 = y3; b4 = b3;
          d3 = d2; y3 = y2; b3 = b2;
          d2 = d1; y2 = y1; b2 = b1;
          d1 = dSeg; y1 = ySeg; b1 = bSeg;
        }
        let crossingBoost = 0;
        let zoneLowerY = +1e9;
        for (const cz of crossingZones) {
          const vx = x - cz.cx;
          const vz = z - cz.cz;
          const u = vx * cz.t.x + vz * cz.t.z;
          const v = -vx * cz.t.z + vz * cz.t.x;
          const e = (u * u) / (cz.major * cz.major) + (v * v) / (cz.minor * cz.minor);
          if (e >= 1) continue;
          const b = Math.pow(1 - e, 0.55) * cz.weight;
          if (b > crossingBoost) crossingBoost = b;
          zoneLowerY = Math.min(zoneLowerY, cz.lowerY);
        }
        let junctionBoost = 0;
        let junctionY = +1e9;
        for (const jz of junctionZones) {
          const dd = Math.hypot(x - jz.x, z - jz.z);
          if (dd >= jz.r) continue;
          const t = clamp(1 - dd / Math.max(1e-6, jz.r), 0, 1);
          const b = t * t;
          if (b > junctionBoost) junctionBoost = b;
          junctionY = Math.min(junctionY, jz.y);
        }
        const crossing = ((d2 < supportEdge * 0.92) && (Math.abs(y1 - y2) > bridgeGap)) || crossingBoost > 0.015;
        const useFirst = !crossing || y1 <= y2;
        let laneY = useFirst ? y1 : y2;
        if (crossingBoost > 0.06 && zoneLowerY < 1e8) laneY = Math.min(laneY, zoneLowerY);
        if (junctionBoost > 0.02 && junctionY < 1e8) laneY = Math.min(laneY, junctionY);
        const laneBank = useFirst ? b1 : b2;
        const bankDrop = Math.abs(Math.sin((laneBank || 0) * Math.PI / 180)) * (roadWidth * 0.56) * (1 - crossingBoost * 0.7);
        const laneLowY = Math.min(laneY - bankDrop, deckSegY - roadClearance * 0.18);

        let edgeLocal =
          supportEdge +
          (crossing ? roadWidth * 1.2 + shoulderWidth * 0.8 : 0) +
          crossingBoost * (roadWidth * 4.2 + shoulderWidth * 2.2) +
          junctionBoost * (roadWidth * 1.35 + shoulderWidth * 1.05);
        let slopeLenLocal =
          slopeLen +
          (crossing ? roadWidth * 2.1 : 0) +
          crossingBoost * (roadWidth * 4.8 + shoulderWidth * 2.4) +
          junctionBoost * (roadWidth * 2.2 + shoulderWidth * 1.35);
        if (crossingBoost > 0.12 || (crossing && Math.abs(y1 - y2) > bridgeGap * 1.15)) {
          edgeLocal = Math.max(edgeLocal, supportEdge + roadWidth * 2.35 + shoulderWidth * 1.45);
          slopeLenLocal = Math.max(slopeLenLocal, slopeLen + roadWidth * 4.4 + shoulderWidth * 2.7);
        }
        const dEdgeBased = Math.min(d1, edgeDistSeg + halfRoad);
        const dForShape = d1 * (1 - followRoad) + dEdgeBased * followRoad;
        const insideT = clamp(dForShape / Math.max(0.01, edgeLocal), 0, 1);
        const bevel = (1 - Math.cos(insideT * Math.PI)) * 0.5;
        const shoulderEdgeDrop = 0.24 + shoulderWidth * 0.09;
        const localClear = clearanceAt(insideT);
        const nearRoadDeck = deckSegY - localClear - (shoulderEdgeDrop * Math.pow(bevel, 0.95));
        const nearRoadLane = laneLowY - localClear * (1 - 0.55 * insideT);
        const nearRoadY = nearRoadLane * (1 - followRoad) + Math.min(nearRoadDeck, nearRoadLane) * followRoad;

        const tfar = clamp((dForShape - edgeLocal) / (margin * 0.62), 0, 1);
        const ridge = cliffHeight * Math.pow(tfar, 1.16);
        const macroNoise = noise2(x * 0.16 - 13.7, z * 0.14 + 8.9);
        const mountainNoise = Math.abs(noise2(x * 0.055 + 17.1, z * 0.051 - 11.8));
        const ridgeNoise = Math.abs(noise2(x * 0.094 - 6.4, z * 0.088 + 9.2));
        const roughScale = 1 - 0.52 * kartStyle;
        const terrainNoise = (noise2(x, z) * 0.62 + noise2(x * 0.73 + 4.1, z * 0.81 - 3.7) * 0.38) * 0.72 + macroNoise * 0.28;
        const mountainLift = (cliffHeight * (0.56 + 0.55 * roughness)) * Math.pow(tfar, 1.35) * (0.28 + mountainNoise * 0.72);
        const ridgeLift = cliffHeight * 0.44 * Math.pow(tfar, 1.72) * Math.pow(ridgeNoise, 1.8);
        const hillNoise = terrainNoise * roughness * roughScale * (0.10 + 0.90 * Math.pow(tfar, 0.8 + 0.4 * kartStyle));
        const hillY = baseY + ridge + hillNoise + mountainLift + ridgeLift;

        const slopeT = clamp((dForShape - edgeLocal) / slopeLenLocal, 0, 1);
        const elev = Math.max(0, nearRoadY - baseY);
        const dropDepth = 1.2 + cliffHeight * 0.95 + elev * 0.42 + (crossing ? roadWidth * 0.45 : 0) + crossingBoost * roadWidth * 0.95;
        const crossExp = clamp(1.02 - crossingBoost * 0.38, 0.68, 1.02);
        const supportY = nearRoadY - Math.pow(slopeT, crossing ? crossExp : 1.22) * dropDepth;

        let y = Math.max(hillY, supportY);

        // Force terrain to meet road-side shoulders cleanly.
        const joinBlend = smoothstep(edgeLocal - (1.25 + crossingBoost * 0.9), edgeLocal + (0.95 + crossingBoost * 1.2), dForShape);
        y = nearRoadY * (1 - joinBlend) + y * joinBlend;

        // For stacked crossings, widen/lower the local base so the lower pass is smoother.
        if (crossing) {
          const carve = smoothstep(roadWidth * 0.03, edgeLocal * (0.98 + 0.25 * crossingBoost), dForShape);
          y -= (1 - carve) * (0.2 + roadWidth * 0.05 + crossingBoost * roadWidth * 0.16);
        }

        // Keep a wider, smoother playable apron around the road before cliffs start.
        const apronRange = slopeLenLocal * (0.45 + 0.25 * kartStyle) + shoulderWidth * (0.8 + 0.7 * kartStyle);
        const apronT = 1 - smoothstep(edgeLocal + shoulderWidth * 0.15, edgeLocal + apronRange, dForShape);
        const apronStrength = 0.22 + 0.42 * kartStyle;
        if (apronT > 1e-4) {
          const mix = clamp(apronT * apronStrength, 0, 0.88);
          y = y * (1 - mix) + nearRoadY * mix;
        }

        // Enforce a rounded, always-down outer shoulder bevel into terrain.
        const shoulderOuter = roadWidth * 0.5 + curbWidth + shoulderWidth;
        const shoulderBevelWidth = clamp(0.85 + shoulderWidth * 0.52 + crossingBoost * 0.8, 0.85, 6.8);
        if (dForShape > shoulderOuter - 0.22 && dForShape < shoulderOuter + shoulderBevelWidth + 0.34) {
          const st = smoothstep(shoulderOuter - 0.10, shoulderOuter + shoulderBevelWidth, dForShape);
          const sround = (1 - Math.cos(st * Math.PI)) * 0.5;
          const shoulderBase = laneLowY - roadClearance * 0.62 - shoulderEdgeDrop * 0.58;
          const shoulderTarget = shoulderBase - (shoulderBevelDepth + 0.24 + crossingBoost * 0.3) * sround;
          y = Math.min(y, shoulderTarget);
        }

        // Hard safety cap: terrain must stay below nearby road deck to prevent clipping.
        const capClear = clearanceAt(insideT) + terrainUnderRoadBias + crossingBoost * 0.14 + junctionBoost * 0.20;
        let hardCap = laneLowY - capClear;
        const probeRadius = strictProbeRadiusBase + crossingBoost * (roadWidth * 1.3 + shoulderWidth * 0.9);
        const probeDs = [d1, d2, d3, d4];
        const probeYs = [y1, y2, y3, y4];
        const probeBanks = [b1, b2, b3, b4];
        for (let qi = 0; qi < 4; qi++) {
          const pd = probeDs[qi];
          if (!Number.isFinite(pd) || pd > probeRadius) continue;
          const pInside = clamp(pd / Math.max(0.01, roadWidth * 0.5 + curbWidth + shoulderWidth * 0.9), 0, 1);
          const pBankDrop = Math.abs(Math.sin((probeBanks[qi] || 0) * Math.PI / 180)) * (roadWidth * 0.58);
          const pClear = clearanceAt(pInside) + terrainUnderRoadBias + (1 - pInside) * 0.05 + junctionBoost * 0.08;
          const pCap = probeYs[qi] - pBankDrop - pClear;
          if (pCap < hardCap) hardCap = pCap;
        }
        if (y > hardCap) y = hardCap;
        let islandMask = 0;
        if (islandEnabled) {
          islandMask = smoothstep(islandInner, islandOuter, dForShape);
          if (islandMask > 1e-5) {
            const coastNoise = noise2(x * 0.18 - 11.3, z * 0.21 + 7.7) * 0.5 + noise2(x * 0.08 + 3.7, z * 0.11 - 4.2) * 0.5;
            const coastTarget = baseY - islandDrop - cliffHeight * (0.08 + islandMask * 0.28) - roughness * 0.22 * coastNoise;
            y = y * (1 - islandMask) + coastTarget * islandMask;
          }
        }
        const idx = iz * nx + ix;
        hField[idx] = y;
        capField[idx] = hardCap;
        dField[idx] = d1;
        boostField[idx] = Math.max(crossingBoost, junctionBoost * 0.8);
        roadMaskField[idx] = clamp(1 - smoothstep(halfRoad * 0.72, supportEdge + shoulderWidth * 0.68, d1), 0, 1);
        islandMaskField[idx] = islandMask;
      }
    }

    // Post-smooth terrain for kart-like readability while preserving shoulders/clearance.
    const smoothPasses = 2 + Math.round(kartStyle * 2 + detail * 2);
    for (let pass = 0; pass < smoothPasses; pass++) {
      const prev = hField.slice();
      for (let iz = 1; iz < nz - 1; iz++) {
        for (let ix = 1; ix < nx - 1; ix++) {
          const idx = iz * nx + ix;
          const d = dField[idx];
          const crossingBoost = boostField[idx];
          const protectRoad = 1 - smoothstep(roadWidth * 0.45, supportEdge + shoulderWidth * 0.55, d);
          const protectShoulder = 1 - smoothstep(
            roadWidth * 0.5 + curbWidth + shoulderWidth * 0.35,
            roadWidth * 0.5 + curbWidth + shoulderWidth * 1.15,
            d
          );
          let w = (0.08 + 0.20 * kartStyle) * (1 - protectRoad * 0.88) * (1 - protectShoulder * 0.45);
          if (crossingBoost > 0.05) w *= 0.52;
          if (w < 1e-4) continue;
          const nsum = prev[idx - 1] + prev[idx + 1] + prev[idx - nx] + prev[idx + nx];
          const dsum = prev[idx - nx - 1] + prev[idx - nx + 1] + prev[idx + nx - 1] + prev[idx + nx + 1];
          const nAvg = nsum * 0.25;
          const dAvg = dsum * 0.25;
          const avg = nAvg * 0.66 + dAvg * 0.34;
          let ny = prev[idx] * (1 - w) + avg * w;
          const cap = capField[idx];
          if (ny > cap) ny = cap;
          hField[idx] = ny;
        }
      }
    }
    for (let i = 0; i < hField.length; i++) {
      const cap = capField[i] - postSmoothGap;
      if (hField[i] > cap) hField[i] = cap;
    }

    for (let iz = 0; iz < nz; iz++) {
      for (let ix = 0; ix < nx; ix++) {
        const idx = iz * nx + ix;
        const x = minX + ix * sx;
        const z = minZ + iz * sz;
        terrain.verts.push(v3(x, hField[idx], z));
        terrain.uvs.push({ u: ix / Math.max(1, nx - 1), v: iz / Math.max(1, nz - 1) });
      }
    }

    for (let iz = 0; iz < nz - 1; iz++) {
      for (let ix = 0; ix < nx - 1; ix++) {
        const a = iz * nx + ix + 1;
        const b = a + 1;
        const c = a + nx;
        const d = c + 1;
        const pA = terrain.verts[a - 1];
        const pB = terrain.verts[b - 1];
        const pC = terrain.verts[c - 1];
        const pD = terrain.verts[d - 1];
        const dMain = Math.hypot(pA.x - pD.x, pA.y - pD.y, pA.z - pD.z);
        const dAlt = Math.hypot(pB.x - pC.x, pB.y - pC.y, pB.z - pC.z);
        if (dMain <= dAlt) {
          // Keep winding consistent (up-facing normals) for the alternate diagonal.
          terrain.faces.push({ a, b: d, c: b, au: a, bu: d, cu: b });
          terrain.faces.push({ a, b: c, c: d, au: a, bu: c, cu: d });
        } else {
          terrain.faces.push({ a, b: c, c: b, au: a, bu: c, cu: b });
          terrain.faces.push({ a: b, b: c, c: d, au: b, bu: c, cu: d });
        }
      }
    }
    let hMin = +1e9, hMax = -1e9;
    for (let i = 0; i < hField.length; i++) {
      const h = hField[i];
      if (h < hMin) hMin = h;
      if (h > hMax) hMax = h;
    }
    terrain._grid = { minX, minZ, sx, sz, nx, nz };
    terrain._meta = {
      heightMin: hMin,
      heightMax: hMax,
      roadMask: roadMaskField,
      islandMask: islandMaskField,
      islandEnabled,
      islandOffset,
      islandFalloff,
      islandDrop,
    };
    return terrain;
  }

  function makeMesh(name) {
    return { name, verts: [], uvs: [], faces: [] };
  }

  function meshAddVertex(mesh, p, u = 0, v = 0) {
    mesh.verts.push(v3(p.x, p.y, p.z));
    mesh.uvs.push({ u, v });
    return mesh.verts.length;
  }

  function meshAddTri(mesh, a, b, c) {
    mesh.faces.push({ a, b, c, au: a, bu: b, cu: c });
  }

  function meshAddQuad(mesh, p0, p1, p2, p3, u0 = 0, u1 = 1, v0 = 0, v1 = 1) {
    const a = meshAddVertex(mesh, p0, u0, v0);
    const b = meshAddVertex(mesh, p1, u1, v0);
    const c = meshAddVertex(mesh, p2, u1, v1);
    const d = meshAddVertex(mesh, p3, u0, v1);
    meshAddTri(mesh, a, b, c);
    meshAddTri(mesh, a, c, d);
  }

  function meshAddOrientedBox(mesh, center, ax, ay, az, hx, hy, hz) {
    const x = norm(ax), y = norm(ay), z = norm(az);
    const sx = mul(x, hx), sy = mul(y, hy), sz = mul(z, hz);
    const p000 = add(add(add(center, mul(sx, -1)), mul(sy, -1)), mul(sz, -1));
    const p001 = add(add(add(center, mul(sx, -1)), mul(sy, -1)), sz);
    const p010 = add(add(add(center, mul(sx, -1)), sy), mul(sz, -1));
    const p011 = add(add(add(center, mul(sx, -1)), sy), sz);
    const p100 = add(add(add(center, sx), mul(sy, -1)), mul(sz, -1));
    const p101 = add(add(add(center, sx), mul(sy, -1)), sz);
    const p110 = add(add(add(center, sx), sy), mul(sz, -1));
    const p111 = add(add(add(center, sx), sy), sz);
    meshAddQuad(mesh, p000, p100, p110, p010, 0, 1, 0, 1);
    meshAddQuad(mesh, p101, p001, p011, p111, 0, 1, 0, 1);
    meshAddQuad(mesh, p001, p000, p010, p011, 0, 1, 0, 1);
    meshAddQuad(mesh, p100, p101, p111, p110, 0, 1, 0, 1);
    meshAddQuad(mesh, p010, p110, p111, p011, 0, 1, 0, 1);
    meshAddQuad(mesh, p001, p101, p100, p000, 0, 1, 0, 1);
  }

  function meshAddPyramid(mesh, baseCenter, radius, height, rot = 0) {
    const y0 = baseCenter.y;
    const tip = v3(baseCenter.x, y0 + height, baseCenter.z);
    const a0 = rot;
    const a1 = rot + Math.PI * 0.5;
    const a2 = rot + Math.PI;
    const a3 = rot + Math.PI * 1.5;
    const p0 = v3(baseCenter.x + Math.cos(a0) * radius, y0, baseCenter.z + Math.sin(a0) * radius);
    const p1 = v3(baseCenter.x + Math.cos(a1) * radius, y0, baseCenter.z + Math.sin(a1) * radius);
    const p2 = v3(baseCenter.x + Math.cos(a2) * radius, y0, baseCenter.z + Math.sin(a2) * radius);
    const p3 = v3(baseCenter.x + Math.cos(a3) * radius, y0, baseCenter.z + Math.sin(a3) * radius);
    meshAddQuad(mesh, p0, p1, p2, p3, 0, 1, 0, 1);
    const i0 = meshAddVertex(mesh, p0, 0, 0);
    const i1 = meshAddVertex(mesh, p1, 1, 0);
    const i2 = meshAddVertex(mesh, p2, 1, 1);
    const i3 = meshAddVertex(mesh, p3, 0, 1);
    const it = meshAddVertex(mesh, tip, 0.5, 1);
    meshAddTri(mesh, i0, i1, it);
    meshAddTri(mesh, i1, i2, it);
    meshAddTri(mesh, i2, i3, it);
    meshAddTri(mesh, i3, i0, it);
  }

  function hash01(n) {
    const s = Math.sin(n * 127.1 + 311.7) * 43758.5453123;
    return s - Math.floor(s);
  }

  function buildThemeMeshes(samples, frames, opts) {
    if (!samples || samples.length < 2 || !frames || !opts?.enabled) return [];
    const out = [];
    const roadWidth = Math.max(1, opts.roadWidth || 4.5);
    const half = roadWidth * 0.5;
    const shoulderWidth = Math.max(0.2, opts.shoulderWidth || 2.6);
    const curbHeight = Math.max(0.01, opts.curbHeight || 0.1);
    const roadThickness = Math.max(0.02, opts.roadThickness || 0.7);
    const closedTheme = !!opts.closed;
    const capEnds = opts.capEnds !== false;
    const junctionPads = opts.junctionPads !== false;
    const supportStyle = supportStyleKey(opts.supportStyle || 'highway');
    const bridgeMaterialMode = bridgeMaterialKey(opts.bridgeMaterial || 'auto');
    const segCount = closedTheme ? samples.length : (samples.length - 1);
    const curbWidth = clamp(0.22 + shoulderWidth * 0.2, 0.18, 0.95);

    const dists = [0];
    for (let i = 1; i < samples.length; i++) dists.push(dists[i - 1] + len(sub(samples[i].pos, samples[i - 1].pos)));

    const shoulders = makeMesh('theme_grass_shoulders');
    const curbs = makeMesh('theme_curbs');
    const underdeck = makeMesh('theme_underdeck');
    const bridgeDeckFreeway = makeMesh('theme_bridge_deck_freeway');
    const bridgeDeckWood = makeMesh('theme_bridge_deck_wood');
    const bridgeDeckSteel = makeMesh('theme_bridge_deck_steel');
    const shoulderBandTs = [0.00, 0.22, 0.48, 0.74, 1.00];
    const shoulderBandCount = shoulderBandTs.length;
    const shoulderStride = shoulderBandCount * 2;
    const pickBridgeDeckStyle = (i0, i1, supp) => {
      let style = bridgeMaterialMode;
      if (style === 'auto') style = bridgeMaterialForSupportStyle(supportStyle);
      if (style !== 'city_mix') return style;
      const w = clamp(supp, 0, 1);
      const r = hash01((i0 + 1) * 11.37 + (i1 + 1) * 6.19 + roadWidth * 0.41 + w * 13.7);
      if (r < 0.46) return 'freeway';
      if (r < 0.79) return 'wood_planks';
      return 'steel';
    };
    const bridgeDeckMeshFor = (style) => {
      if (style === 'wood_planks') return bridgeDeckWood;
      if (style === 'steel') return bridgeDeckSteel;
      return bridgeDeckFreeway;
    };
    const bridgeDeckUvScale = (style) => {
      if (style === 'wood_planks') return 0.52;
      if (style === 'steel') return 1.05;
      return 3.20;
    };
    const nearestRoadFrame = (p) => {
      let best = 0;
      let bestD = 1e18;
      for (let i = 0; i < samples.length; i++) {
        const q = samples[i].pos;
        const d = (p.x - q.x) * (p.x - q.x) + (p.z - q.z) * (p.z - q.z);
        if (d < bestD) { bestD = d; best = i; }
      }
      return { i: best, s: samples[best], f: frames[best] };
    };
    const flipFace = (f) => {
      const nb = f.c, nbu = f.cu;
      f.c = f.b; f.cu = f.bu;
      f.b = nb;  f.bu = nbu;
    };
    const enforceCurbOutwardNormals = () => {
      const hTol = Math.max(0.006, curbHeight * 0.18);
      const baseYBias = 0.0015 + hTol;
      for (const face of curbs.faces) {
        const a = curbs.verts[face.a - 1], b = curbs.verts[face.b - 1], c = curbs.verts[face.c - 1];
        if (!a || !b || !c) continue;
        const ctr = v3((a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3, (a.z + b.z + c.z) / 3);
        const n = norm(cross(sub(b, a), sub(c, a)));
        const rf = nearestRoadFrame(ctr);
        const p = rf.s.pos;
        const R = rf.f.R;
        const topY = p.y + curbHeight * 0.35;
        const bottomY = p.y + baseYBias;
        const isTop = ctr.y >= topY;
        const isBottom = ctr.y <= bottomY;
        let shouldFlip = false;
        if (isTop) {
          shouldFlip = n.y < 0;
        } else if (isBottom) {
          shouldFlip = n.y > 0;
        } else {
          const lateral = dot(sub(ctr, p), R);
          const outSign = lateral >= 0 ? 1 : -1;
          const nSign = dot(n, R) >= 0 ? 1 : -1;
          shouldFlip = nSign !== outSign;
        }
        if (shouldFlip) flipFace(face);
      }
    };
    const nS = samples.length;
    const bridgeSupp = new Float32Array(nS);
    const minSep = Math.max(14, Math.floor(nS * 0.08));
    const hitDist = Math.max(1.8, roadWidth * 0.95 + shoulderWidth * 0.45);
    const bridgeGap = Math.max(1.05, roadThickness + 0.55);
    const suppWin = Math.max(2, Math.round(nS * 0.012));
    for (let i = 0; i < nS; i += 2) {
      const pi = samples[i].pos;
      for (let j = i + minSep; j < nS; j += 2) {
        const pj = samples[j].pos;
        const d = Math.hypot(pi.x - pj.x, pi.z - pj.z);
        if (d > hitDist) continue;
        const dy = pi.y - pj.y;
        if (Math.abs(dy) < bridgeGap) continue;
        const upper = dy > 0 ? i : j;
        const boost = clamp(1 - d / Math.max(1e-6, hitDist), 0, 1);
        for (let k = -suppWin; k <= suppWin; k++) {
          const idx = upper + k;
          if (idx < 0 || idx >= nS) continue;
          const w = boost * (1 - Math.abs(k) / (suppWin + 1));
          if (w > bridgeSupp[idx]) bridgeSupp[idx] = w;
        }
      }
    }
    const shoulderWBy = new Float32Array(nS);
    const curbWBy = new Float32Array(nS);
    const curbHBy = new Float32Array(nS);

    const underStride = 4; // leftTop, rightTop, leftBottom, rightBottom
    for (let i = 0; i < samples.length; i++) {
      const P = samples[i].pos;
      const R = frames[i].R;
      const u = ((dists[i] / 7) % 1 + 1) % 1;
      const wig = (Math.sin(i * 0.41) + Math.cos(i * 0.29)) * 0.025;
      const supp = clamp(bridgeSupp[i], 0, 1);
      const supportFade = 1 - supp;
      const shoulderW = Math.max(0.05, shoulderWidth * (0.08 + supportFade * 0.92));
      const curbW = Math.max(0.03, curbWidth * (0.06 + supportFade * 0.94));
      const curbH = Math.max(0.01, curbHeight * (0.08 + supportFade * 0.92));
      shoulderWBy[i] = shoulderW;
      curbWBy[i] = curbW;
      curbHBy[i] = curbH;
      const shoulderSeamY = 0.0015;
      const shoulderOuterY = -(0.36 + shoulderWidth * 0.04);
      for (let bi = 0; bi < shoulderBandCount; bi++) {
        const t = shoulderBandTs[bi];
        const round = (1 - Math.cos(t * Math.PI * 0.96)) * 0.5;
        const yBase = shoulderSeamY * (1 - round) + shoulderOuterY * round;
        const wigScale = t * 0.92;
        const yOff = yBase + wig * wigScale;
        const d = half + curbW + shoulderW * t;
        shoulders.verts.push(add(add(P, mul(R, d)), v3(0, yOff, 0)));
        shoulders.uvs.push({ u, v: t });
      }
      for (let bi = 0; bi < shoulderBandCount; bi++) {
        const t = shoulderBandTs[bi];
        const round = (1 - Math.cos(t * Math.PI * 0.96)) * 0.5;
        const yBase = shoulderSeamY * (1 - round) + shoulderOuterY * round;
        const wigScale = t * 0.92;
        const yOff = yBase + wig * wigScale;
        const d = half + curbW + shoulderW * t;
        shoulders.verts.push(add(add(P, mul(R, -d)), v3(0, yOff, 0)));
        shoulders.uvs.push({ u, v: t });
      }

      const clI = add(P, mul(R, half + 0.03));
      const clO = add(P, mul(R, half + curbW));
      const crI = add(P, mul(R, -half - 0.03));
      const crO = add(P, mul(R, -half - curbW));
      const topLift = v3(0, curbH, 0);
      const baseLift = v3(0, 0.0015, 0);
      // 8 verts/sample for solid curb ribbons:
      // L inner top, L outer top, R inner top, R outer top, L inner base, L outer base, R inner base, R outer base
      curbs.verts.push(add(clI, topLift));  curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(clO, topLift));  curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(crI, topLift));  curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(crO, topLift));  curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(clI, baseLift)); curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(clO, baseLift)); curbs.uvs.push({ u, v: 1 });
      curbs.verts.push(add(crI, baseLift)); curbs.uvs.push({ u, v: 0 });
      curbs.verts.push(add(crO, baseLift)); curbs.uvs.push({ u, v: 1 });

      // Continuous underside shell from outer shoulders.
      const outer = half + curbW + shoulderW;
      const topOuterY = shoulderOuterY + wig * 0.92;
      const underY = -Math.max(0.06, roadThickness + 0.03 + shoulderWidth * 0.02);
      const tl = add(add(P, mul(R, outer)), v3(0, topOuterY, 0));
      const tr = add(add(P, mul(R, -outer)), v3(0, topOuterY, 0));
      const ul = add(add(P, mul(R, outer)), v3(0, underY, 0));
      const ur = add(add(P, mul(R, -outer)), v3(0, underY, 0));
      underdeck.verts.push(tl); underdeck.uvs.push({ u, v: 0 });
      underdeck.verts.push(tr); underdeck.uvs.push({ u, v: 0 });
      underdeck.verts.push(ul); underdeck.uvs.push({ u, v: 0 });
      underdeck.verts.push(ur); underdeck.uvs.push({ u, v: 1 });
    }

    for (let i = 0; i < segCount; i++) {
      const ni = closedTheme ? ((i + 1) % samples.length) : (i + 1);
      const s0 = i * shoulderStride + 1;
      const s1 = ni * shoulderStride + 1;
      for (let band = 0; band < shoulderBandCount - 1; band++) {
        const a0 = s0 + band;
        const b0 = s0 + band + 1;
        const a1 = s1 + band;
        const b1 = s1 + band + 1;
        meshAddTri(shoulders, a0, b0, b1);
        meshAddTri(shoulders, a0, b1, a1);
      }
      for (let band = 0; band < shoulderBandCount - 1; band++) {
        const a0 = s0 + shoulderBandCount + band;
        const b0 = s0 + shoulderBandCount + band + 1;
        const a1 = s1 + shoulderBandCount + band;
        const b1 = s1 + shoulderBandCount + band + 1;
        meshAddTri(shoulders, a0, b1, b0);
        meshAddTri(shoulders, a0, a1, b1);
      }

      const c0 = i * 8 + 1;
      const c1 = ni * 8 + 1;
      // Left top strip
      meshAddTri(curbs, c0 + 0, c1 + 1, c0 + 1);
      meshAddTri(curbs, c0 + 0, c1 + 0, c1 + 1);
      // Left base strip
      meshAddTri(curbs, c0 + 4, c0 + 5, c1 + 5);
      meshAddTri(curbs, c0 + 4, c1 + 5, c1 + 4);
      // Left inner wall
      meshAddTri(curbs, c0 + 0, c0 + 4, c1 + 4);
      meshAddTri(curbs, c0 + 0, c1 + 4, c1 + 0);
      // Left outer wall
      meshAddTri(curbs, c0 + 1, c1 + 1, c1 + 5);
      meshAddTri(curbs, c0 + 1, c1 + 5, c0 + 5);

      // Right top strip
      meshAddTri(curbs, c0 + 2, c0 + 3, c1 + 3);
      meshAddTri(curbs, c0 + 2, c1 + 3, c1 + 2);
      // Right base strip
      meshAddTri(curbs, c0 + 6, c1 + 7, c0 + 7);
      meshAddTri(curbs, c0 + 6, c1 + 6, c1 + 7);
      // Right inner wall
      meshAddTri(curbs, c0 + 2, c1 + 2, c1 + 6);
      meshAddTri(curbs, c0 + 2, c1 + 6, c0 + 6);
      // Right outer wall
      meshAddTri(curbs, c0 + 3, c0 + 7, c1 + 7);
      meshAddTri(curbs, c0 + 3, c1 + 7, c1 + 3);

      // Underdeck bottom strip (downward-facing winding).
      const ud0 = i * underStride + 1;
      const ud1 = ni * underStride + 1;
      const tl0 = ud0, tr0 = ud0 + 1, ul0 = ud0 + 2, ur0 = ud0 + 3;
      const tl1 = ud1, tr1 = ud1 + 1, ul1 = ud1 + 2, ur1 = ud1 + 3;
      meshAddTri(underdeck, ul0, ur1, ur0);
      meshAddTri(underdeck, ul0, ul1, ur1);

      // Skirts connect outer shoulder edge to underside, closing lateral shell.
      meshAddTri(underdeck, tl0, ul1, ul0);
      meshAddTri(underdeck, tl0, tl1, ul1);
      meshAddTri(underdeck, tr0, ur0, ur1);
      meshAddTri(underdeck, tr0, ur1, tr1);
    }
    if (capEnds && !closedTheme && samples.length >= 2) {
      const s0 = 1;
      const sN = (samples.length - 1) * 8 + 1;
      // Start caps
      meshAddTri(curbs, s0 + 0, s0 + 5, s0 + 4);
      meshAddTri(curbs, s0 + 0, s0 + 1, s0 + 5);
      meshAddTri(curbs, s0 + 2, s0 + 6, s0 + 7);
      meshAddTri(curbs, s0 + 2, s0 + 7, s0 + 3);
      // End caps
      meshAddTri(curbs, sN + 0, sN + 4, sN + 5);
      meshAddTri(curbs, sN + 0, sN + 5, sN + 1);
      meshAddTri(curbs, sN + 2, sN + 7, sN + 6);
      meshAddTri(curbs, sN + 2, sN + 3, sN + 7);

      // End caps for underside shell.
      const uStart = 1;
      const uEnd = (samples.length - 1) * underStride + 1;
      const stTL = uStart, stTR = uStart + 1, stUL = uStart + 2, stUR = uStart + 3;
      const enTL = uEnd, enTR = uEnd + 1, enUL = uEnd + 2, enUR = uEnd + 3;
      meshAddTri(underdeck, stTL, stUR, stUL);
      meshAddTri(underdeck, stTL, stTR, stUR);
      meshAddTri(underdeck, enTL, enUL, enUR);
      meshAddTri(underdeck, enTL, enUR, enTR);
    }

    // Bridge deck overlay material for elevated spans.
    const bridgeDeckThreshold = 0.12;
    const deckRise = 0.008;
    for (let i = 0; i < segCount; i++) {
      const ni = closedTheme ? ((i + 1) % samples.length) : (i + 1);
      const supp = clamp((bridgeSupp[i] + bridgeSupp[ni]) * 0.5, 0, 1);
      if (supp < bridgeDeckThreshold) continue;
      const style = pickBridgeDeckStyle(i, ni, supp);
      const mesh = bridgeDeckMeshFor(style);
      const insetBase = style === 'wood_planks' ? 0.34 : (style === 'steel' ? 0.24 : 0.18);
      const inset = clamp(insetBase + (1 - supp) * 0.10, 0.10, Math.max(0.12, half - 0.20));
      const halfDeck = Math.max(0.30, half - inset);
      const uScale = bridgeDeckUvScale(style);
      const u0 = dists[i] / Math.max(0.15, uScale);
      const u1 = dists[ni] / Math.max(0.15, uScale);

      const P0 = samples[i].pos;
      const P1 = samples[ni].pos;
      const R0 = frames[i].R;
      const R1 = frames[ni].R;
      const L0 = add(add(P0, mul(R0, halfDeck)), v3(0, deckRise, 0));
      const Rgt0 = add(add(P0, mul(R0, -halfDeck)), v3(0, deckRise, 0));
      const L1 = add(add(P1, mul(R1, halfDeck)), v3(0, deckRise, 0));
      const Rgt1 = add(add(P1, mul(R1, -halfDeck)), v3(0, deckRise, 0));
      meshAddQuad(mesh, L0, L1, Rgt1, Rgt0, u0, u1, 0, 1);

      // Mario-Kart style plank slats.
      if (style === 'wood_planks') {
        const segVec = sub(P1, P0);
        const segLen = Math.max(0.01, len(segVec));
        const along = norm(segVec);
        const slatCount = clamp(Math.round(segLen / clamp(0.46 + roadWidth * 0.02, 0.38, 0.90)), 1, 9);
        const slatHalfLen = clamp(segLen / Math.max(2, slatCount * 2.1), 0.08, 0.36);
        const slatHalfH = clamp(0.010 + roadThickness * 0.028, 0.008, 0.024);
        const slatHalfW = Math.max(0.22, halfDeck * 0.94);
        for (let k = 1; k < slatCount; k++) {
          const t = k / slatCount;
          const C = add(mul(P0, 1 - t), mul(P1, t));
          let Rm = norm(add(mul(R0, 1 - t), mul(R1, t)));
          if (len(Rm) < 1e-6) Rm = R0;
          const center = add(C, v3(0, deckRise + slatHalfH, 0));
          meshAddOrientedBox(mesh, center, along, v3(0, 1, 0), Rm, slatHalfLen, slatHalfH, slatHalfW);
        }
      }
    }

    // Fill shoulder/curb around junctions and mergeable crossings so all surfaces meet cleanly.
    if (junctionPads) {
      const mergeableTheme = opts?.net ? gatherMergeableCrossings(opts.net, {
        clearance: Math.max(0.75, roadThickness * 1.9),
      }) : [];
      const used = new Set();
      const junctionIdx = [];
      for (const sec of branchSections) {
        for (const i of [sec.a, sec.b]) {
          if (!Number.isInteger(i) || i < 0 || i >= points.length || used.has(i)) continue;
          used.add(i);
          junctionIdx.push(i);
        }
      }
      const mergePads = [];
      for (const m of mergeableTheme) {
        const p = v3(m.x, m.y, m.z);
        const a0 = m.a?.p0 || null;
        const a1 = m.a?.p1 || null;
        const t = (a0 && a1) ? norm(v3(a1.x - a0.x, 0, a1.z - a0.z)) : v3(1, 0, 0);
        const ref = nearestRoadFrame(p);
        mergePads.push({ p, t, idx: ref?.i ?? 0 });
      }
      if (!junctionIdx.length && !mergePads.length) {
        enforceCurbOutwardNormals();
        if (shoulders.faces.length) out.push({ mesh: shoulders, kind: 'grass' });
        if (curbs.faces.length) out.push({ mesh: curbs, kind: 'curb' });
        if (underdeck.faces.length) out.push({ mesh: underdeck, kind: 'underdeck' });
        if (bridgeDeckFreeway.faces.length) out.push({ mesh: bridgeDeckFreeway, kind: 'bridgeDeckFreeway' });
        if (bridgeDeckWood.faces.length) out.push({ mesh: bridgeDeckWood, kind: 'bridgeDeckWood' });
        if (bridgeDeckSteel.faces.length) out.push({ mesh: bridgeDeckSteel, kind: 'bridgeDeckSteel' });
        return out;
      }
      const steps = 20;
      const themePadCenters = [];
      const addStrip = (mesh, inner, outer, flip = false) => {
        const n = Math.min(inner.length, outer.length);
        if (n < 3) return;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          const a0 = inner[i], a1 = inner[j];
          const b0 = outer[i], b1 = outer[j];
          if (!flip) {
            meshAddTri(mesh, a0, b0, b1);
            meshAddTri(mesh, a0, b1, a1);
          } else {
            meshAddTri(mesh, a0, b1, b0);
            meshAddTri(mesh, a0, a1, b1);
          }
        }
      };
      const carveThemeMeshAtPads = (mesh, radiusKey, yBand = Infinity) => {
        if (!mesh || !Array.isArray(mesh.faces) || !mesh.faces.length || !themePadCenters.length) return;
        const maxSafeFaces = 120000;
        if (mesh.faces.length > maxSafeFaces) return;
        const maxPadR = themePadCenters.reduce((m, p) => Math.max(m, Number(p?.[radiusKey] || 0)), 0);
        const cell = Math.max(0.5, maxPadR * 1.35);
        const grid = new Map();
        const key = (ix, iz) => `${ix}|${iz}`;
        for (let i = 0; i < themePadCenters.length; i++) {
          const p = themePadCenters[i];
          const r = Math.max(0.1, Number(p?.[radiusKey] || 0));
          const minX = Math.floor((p.p.x - r) / cell);
          const maxX = Math.floor((p.p.x + r) / cell);
          const minZ = Math.floor((p.p.z - r) / cell);
          const maxZ = Math.floor((p.p.z + r) / cell);
          for (let ix = minX; ix <= maxX; ix++) {
            for (let iz = minZ; iz <= maxZ; iz++) {
              const k = key(ix, iz);
              let arr = grid.get(k);
              if (!arr) { arr = []; grid.set(k, arr); }
              arr.push(i);
            }
          }
        }
        mesh.faces = mesh.faces.filter((f) => {
          const A = mesh.verts[f.a - 1], B = mesh.verts[f.b - 1], C = mesh.verts[f.c - 1];
          if (!A || !B || !C) return true;
          const cx = (A.x + B.x + C.x) / 3;
          const cy = (A.y + B.y + C.y) / 3;
          const cz = (A.z + B.z + C.z) / 3;
          const arr = grid.get(key(Math.floor(cx / cell), Math.floor(cz / cell)));
          if (!arr || !arr.length) return true;
          for (const pi of arr) {
            const pad = themePadCenters[pi];
            if (Math.abs(cy - pad.p.y) > yBand) continue;
            const dx = cx - pad.p.x;
            const dz = cz - pad.p.z;
            const rr = pad[radiusKey];
            if ((dx * dx + dz * dz) <= (rr * rr)) return false;
          }
          return true;
        });
      };
      const drawJunctionThemePad = (p, idx, tangentDir, radiusScale = 1) => {
        const safeIdx = clamp(Number(idx || 0), 0, samples.length - 1);
        if (bridgeSupp[safeIdx] > 0.90) return;
        let t = tangentDir;
        t = norm(v3(t.x, 0, t.z));
        if (Math.hypot(t.x, t.z) < 1e-6) t = v3(1, 0, 0);
        const r = norm(v3(-t.z, 0, t.x));

        const curbInnerR = (half + 0.03) * radiusScale;
        const curbOuterR = (half + curbWBy[safeIdx]) * radiusScale;
        const curbInnerTop = [];
        const curbOuterTop = [];
        const curbInnerBase = [];
        const curbOuterBase = [];
        const curbLift = curbHBy[safeIdx];
        for (let k = 0; k < steps; k++) {
          const a = (k / steps) * Math.PI * 2;
          const ca = Math.cos(a), sa = Math.sin(a);
          const inOff = add(mul(r, ca * curbInnerR), mul(t, sa * curbInnerR));
          const outOff = add(mul(r, ca * curbOuterR), mul(t, sa * curbOuterR));
          curbInnerTop.push(meshAddVertex(curbs, v3(p.x + inOff.x, p.y + curbLift, p.z + inOff.z), k / steps, 0));
          curbOuterTop.push(meshAddVertex(curbs, v3(p.x + outOff.x, p.y + curbLift, p.z + outOff.z), k / steps, 1));
          curbInnerBase.push(meshAddVertex(curbs, v3(p.x + inOff.x, p.y + 0.0015, p.z + inOff.z), k / steps, 0));
          curbOuterBase.push(meshAddVertex(curbs, v3(p.x + outOff.x, p.y + 0.0015, p.z + outOff.z), k / steps, 1));
        }
        addStrip(curbs, curbInnerTop, curbOuterTop, false);
        addStrip(curbs, curbInnerBase, curbOuterBase, true);
        addStrip(curbs, curbInnerTop, curbInnerBase, false);
        addStrip(curbs, curbOuterTop, curbOuterBase, true);

        const grassTs = [0.00, 0.50, 1.00];
        const grassRings = [];
        const shoulderSeamY = 0.0015;
        const shoulderOuterY = -(0.36 + shoulderWidth * 0.04);
        for (let gi = 0; gi < grassTs.length; gi++) {
          const tt = grassTs[gi];
          const rr = (half + curbWBy[safeIdx] + shoulderWBy[safeIdx] * tt) * radiusScale;
          const round = (1 - Math.cos(tt * Math.PI * 0.96)) * 0.5;
          const y = p.y + shoulderSeamY * (1 - round) + shoulderOuterY * round;
          const ring = [];
          for (let k = 0; k < steps; k++) {
            const a = (k / steps) * Math.PI * 2;
            const ca = Math.cos(a), sa = Math.sin(a);
            const off = add(mul(r, ca * rr), mul(t, sa * rr));
            ring.push(meshAddVertex(shoulders, v3(p.x + off.x, y, p.z + off.z), k / steps, tt));
          }
          grassRings.push(ring);
        }
        addStrip(shoulders, grassRings[0], grassRings[1], false);
        addStrip(shoulders, grassRings[1], grassRings[2], false);
      };
      for (const idx of junctionIdx) {
        const p = points[idx]?.pos;
        if (!p) continue;
        const safeIdx = clamp(Number(nearestRoadFrame(p)?.i ?? 0), 0, samples.length - 1);
        const baseR = Math.max(half + curbWBy[safeIdx] + shoulderWBy[safeIdx], roadWidth * 0.58);
        themePadCenters.push({ p: v3(p.x, p.y, p.z), rCurb: baseR * 0.84, rShoulder: baseR });
      }
      const maxMergePadsTheme = 96;
      for (let i = 0; i < mergePads.length && i < maxMergePadsTheme; i++) {
        const m = mergePads[i];
        const safeIdx = clamp(Number(m.idx || 0), 0, samples.length - 1);
        const baseR = Math.max((half + curbWBy[safeIdx] + shoulderWBy[safeIdx]) * 1.1, roadWidth * 0.70);
        themePadCenters.push({ p: v3(m.p.x, m.p.y, m.p.z), rCurb: baseR * 0.86, rShoulder: baseR });
      }
      carveThemeMeshAtPads(curbs, 'rCurb', Math.max(0.20, curbHeight * 10));
      carveThemeMeshAtPads(shoulders, 'rShoulder', Math.max(0.5, roadThickness * 2.2));
      carveThemeMeshAtPads(underdeck, 'rShoulder', Math.max(0.7, roadThickness * 2.8));
      for (const idx of junctionIdx) {
        const p = points[idx]?.pos;
        if (!p) continue;
        drawJunctionThemePad(p, idx, tangentAtIndex(idx), 1);
      }
      for (let i = 0; i < mergePads.length && i < maxMergePadsTheme; i++) {
        const m = mergePads[i];
        drawJunctionThemePad(m.p, m.idx, m.t, 1.10);
      }
    }

    enforceCurbOutwardNormals();
    if (shoulders.faces.length) out.push({ mesh: shoulders, kind: 'grass' });
    if (curbs.faces.length) out.push({ mesh: curbs, kind: 'curb' });
    if (underdeck.faces.length) out.push({ mesh: underdeck, kind: 'underdeck' });
    if (bridgeDeckFreeway.faces.length) out.push({ mesh: bridgeDeckFreeway, kind: 'bridgeDeckFreeway' });
    if (bridgeDeckWood.faces.length) out.push({ mesh: bridgeDeckWood, kind: 'bridgeDeckWood' });
    if (bridgeDeckSteel.faces.length) out.push({ mesh: bridgeDeckSteel, kind: 'bridgeDeckSteel' });
    return out;
  }

  function sampleTerrainHeight(terrain, x, z) {
    const g = terrain?._grid;
    const verts = terrain?.verts;
    if (!g || !Array.isArray(verts) || verts.length < 4) return null;
    if (!Number.isFinite(g.sx) || !Number.isFinite(g.sz) || g.sx <= 1e-9 || g.sz <= 1e-9) return null;
    const fx = (x - g.minX) / g.sx;
    const fz = (z - g.minZ) / g.sz;
    if (!Number.isFinite(fx) || !Number.isFinite(fz) || fx < 0 || fz < 0 || fx > g.nx - 1 || fz > g.nz - 1) return null;
    const ix = clamp(Math.floor(fx), 0, g.nx - 1);
    const iz = clamp(Math.floor(fz), 0, g.nz - 1);
    const ix1 = clamp(ix + 1, 0, g.nx - 1);
    const iz1 = clamp(iz + 1, 0, g.nz - 1);
    const tx = clamp(fx - ix, 0, 1);
    const tz = clamp(fz - iz, 0, 1);
    const idx = (cx, cz) => {
      const i = cz * g.nx + cx;
      const p = verts[i];
      return Number.isFinite(p?.y) ? p.y : 0;
    };
    const y00 = idx(ix, iz);
    const y10 = idx(ix1, iz);
    const y01 = idx(ix, iz1);
    const y11 = idx(ix1, iz1);
    const y0 = y00 * (1 - tx) + y10 * tx;
    const y1 = y01 * (1 - tx) + y11 * tx;
    return y0 * (1 - tz) + y1 * tz;
  }

  function supportStyleKey(style) {
    const k = String(style || '').toLowerCase().trim();
    if (k === 'tree' || k === 'slicer_tree') return 'tree';
    if (k === 'coaster' || k === 'trestle' || k === 'wooden_coaster' || k === 'wood' || k === 'wooden') return 'coaster';
    if (k === 'cliff' || k === 'cliff_brace') return 'cliff';
    if (k === 'concrete' || k === 'concrete_pier') return 'concrete';
    return 'highway';
  }

  function bridgeMaterialKey(style) {
    const k = String(style || '').toLowerCase().trim();
    if (!k || k === 'auto') return 'auto';
    if (k === 'city_mix' || k === 'mixed' || k === 'mix' || k === 'multi') return 'city_mix';
    if (k === 'wood' || k === 'planks' || k === 'wood_planks' || k === 'mario' || k === 'mario_kart') return 'wood_planks';
    if (k === 'steel' || k === 'steel_grate' || k === 'grate') return 'steel';
    if (k === 'freeway' || k === 'highway' || k === 'concrete') return 'freeway';
    return 'auto';
  }

  function bridgeMaterialLabel(style) {
    const k = bridgeMaterialKey(style);
    if (k === 'city_mix') return 'City mix (multi-material)';
    if (k === 'wood_planks') return 'Wood planks (Mario Kart)';
    if (k === 'steel') return 'Steel deck';
    if (k === 'freeway') return 'Freeway slab';
    return 'Auto (match support)';
  }

  function bridgeMaterialForSupportStyle(style) {
    const s = supportStyleKey(style);
    if (s === 'coaster' || s === 'tree') return 'wood_planks';
    return 'freeway';
  }

  function buildSupportBlockerIndex(meshes, opts = {}) {
    const cellSize = clamp(Number(opts.cellSize || 2.4), 0.45, 12);
    const invCell = 1 / cellSize;
    const buckets = new Map();
    const pushCell = (ix, iz, tri) => {
      const key = `${ix}:${iz}`;
      let arr = buckets.get(key);
      if (!arr) { arr = []; buckets.set(key, arr); }
      arr.push(tri);
    };
    if (!Array.isArray(meshes) || !meshes.length) return { cellSize, invCell, buckets };
    for (const mesh of meshes) {
      if (!mesh || !Array.isArray(mesh.faces) || !Array.isArray(mesh.verts)) continue;
      for (const f of mesh.faces) {
        const A = mesh.verts[f.a - 1];
        const B = mesh.verts[f.b - 1];
        const C = mesh.verts[f.c - 1];
        if (!A || !B || !C) continue;
        const minX = Math.min(A.x, B.x, C.x);
        const maxX = Math.max(A.x, B.x, C.x);
        const minZ = Math.min(A.z, B.z, C.z);
        const maxZ = Math.max(A.z, B.z, C.z);
        const area2 = Math.abs((B.x - A.x) * (C.z - A.z) - (C.x - A.x) * (B.z - A.z));
        if (area2 < 1e-6) continue;
        const tri = {
          ax: A.x, ay: A.y, az: A.z,
          bx: B.x, by: B.y, bz: B.z,
          cx: C.x, cy: C.y, cz: C.z,
          minX, maxX, minZ, maxZ,
        };
        const ix0 = Math.floor(minX * invCell);
        const iz0 = Math.floor(minZ * invCell);
        const ix1 = Math.floor(maxX * invCell);
        const iz1 = Math.floor(maxZ * invCell);
        for (let iz = iz0; iz <= iz1; iz++) {
          for (let ix = ix0; ix <= ix1; ix++) pushCell(ix, iz, tri);
        }
      }
    }
    return { cellSize, invCell, buckets };
  }

  function sampleSupportBlockerHeight(index, x, z, yMin = -1e9, yMax = +1e9) {
    if (!index?.buckets || !Number.isFinite(index.invCell) || index.invCell <= 0) return null;
    const ix = Math.floor(x * index.invCell);
    const iz = Math.floor(z * index.invCell);
    const tris = index.buckets.get(`${ix}:${iz}`);
    if (!tris || !tris.length) return null;
    let best = -1e18;
    const eps = 1e-6;
    for (const t of tris) {
      if (x < t.minX - eps || x > t.maxX + eps || z < t.minZ - eps || z > t.maxZ + eps) continue;
      const v0x = t.bx - t.ax;
      const v0z = t.bz - t.az;
      const v1x = t.cx - t.ax;
      const v1z = t.cz - t.az;
      const den = v0x * v1z - v1x * v0z;
      if (Math.abs(den) < 1e-9) continue;
      const px = x - t.ax;
      const pz = z - t.az;
      const wb = (px * v1z - v1x * pz) / den;
      const wc = (v0x * pz - px * v0z) / den;
      const wa = 1 - wb - wc;
      if (wa < -eps || wb < -eps || wc < -eps) continue;
      const y = wa * t.ay + wb * t.by + wc * t.cy;
      if (!Number.isFinite(y) || y <= yMin || y >= yMax) continue;
      if (y > best) best = y;
    }
    return best > -1e17 ? best : null;
  }

  function buildSupportMeshes(samples, frames, terrain, opts = {}) {
    if (!opts.enabled || !terrain || !samples || samples.length < 3 || !frames || frames.length < 3) return [];
    const out = [];
    const roadWidth = Math.max(1, Number(opts.roadWidth || 4.5));
    const roadThickness = Math.max(0.02, Number(opts.roadThickness || 0.2));
    const closed = !!opts.closed;
    const isBranch = !!opts.isBranch;
    const style = supportStyleKey(opts.style || 'highway');
    const blockerIndex = opts.blockerIndex || null;
    let totalLen = 0;
    for (let i = 1; i < samples.length; i++) totalLen += len(sub(samples[i].pos, samples[i - 1].pos));
    if (totalLen < 1e-3) return out;

    const spacingMul = style === 'coaster'
      ? (isBranch ? 1.68 : 1.95)
      : (style === 'tree'
        ? (isBranch ? 1.92 : 2.22)
        : (style === 'cliff'
          ? (isBranch ? 1.85 : 2.15)
          : (style === 'concrete'
            ? (isBranch ? 2.35 : 2.85)
            : (isBranch ? 2.15 : 2.60))));
    const spacing = clamp(Number(opts.spacing || roadWidth * spacingMul), 2.6, 18.0);
    const avgSeg = totalLen / Math.max(1, samples.length - 1);
    const step = clamp(Math.round(spacing / Math.max(0.15, avgSeg)), 1, Math.max(1, samples.length - 1));
    const edgeSkip = closed ? 0 : Math.max(2, step);
    const minGap = clamp(Number(opts.minGap || (roadThickness + 0.42)), 0.28, 6.5);
    const pillarHalf = clamp(roadWidth * 0.075, 0.16, 0.55);
    const beamHalfW = clamp(roadWidth * 0.33, 0.45, 2.45);
    const beamHalfH = clamp(roadThickness * 0.42, 0.08, 0.38);
    const beamHalfZ = clamp(pillarHalf * 1.18, 0.16, 0.72);
    const supports = makeMesh(isBranch ? 'road_supports_branches' : 'road_supports_main');
    const hasBlockerAt = (x, z, yMin, yMax, radius = 0, ringSamples = 8) => {
      if (!blockerIndex || !(yMax > yMin)) return false;
      const hit0 = sampleSupportBlockerHeight(blockerIndex, x, z, yMin, yMax);
      if (Number.isFinite(hit0)) return true;
      const r = Math.max(0, Number(radius) || 0);
      if (r <= 1e-4) return false;
      const rings = [r * 0.55, r];
      const n = clamp(Math.round(ringSamples), 4, 16);
      for (const rr of rings) {
        for (let i = 0; i < n; i++) {
          const a = (i / n) * Math.PI * 2;
          const px = x + Math.cos(a) * rr;
          const pz = z + Math.sin(a) * rr;
          const hit = sampleSupportBlockerHeight(blockerIndex, px, pz, yMin, yMax);
          if (Number.isFinite(hit)) return true;
        }
      }
      return false;
    };
    const blockedByAnyAnchor = (anchors, yMin, yMax) => {
      if (!Array.isArray(anchors) || !anchors.length || !blockerIndex) return false;
      for (const a of anchors) {
        if (!a) continue;
        if (hasBlockerAt(a.x, a.z, yMin, yMax, a.r || 0, a.samples || 8)) return true;
      }
      return false;
    };
    const addBeamBetween = (A, B, halfW, halfH = halfW) => {
      const AB = sub(B, A);
      const L = len(AB);
      if (L < 1e-4) return;
      const xAx = norm(AB);
      let up = v3(0, 1, 0);
      if (Math.abs(dot(xAx, up)) > 0.94) up = v3(0, 0, 1);
      let zAx = cross(xAx, up);
      if (len(zAx) < 1e-6) zAx = v3(1, 0, 0);
      zAx = norm(zAx);
      const yAx = norm(cross(zAx, xAx));
      const ctr = mul(add(A, B), 0.5);
      meshAddOrientedBox(supports, ctr, xAx, yAx, zAx, L * 0.5, halfH, halfW);
    };

    for (let i = edgeSkip; i < samples.length - edgeSkip; i += step) {
      const P = samples[i]?.pos;
      if (!P) continue;
      const f = frames[Math.min(i, frames.length - 1)];
      if (!f) continue;
      const groundY = sampleTerrainHeight(terrain, P.x, P.z);
      if (!Number.isFinite(groundY)) continue;
      const deckY = P.y - roadThickness;
      const h = deckY - groundY;
      if (!Number.isFinite(h) || h < minGap) continue;
      const yPad = Math.max(0.05, roadThickness * 0.24);
      const yMin = groundY + yPad;
      const yMax = deckY - yPad;
      if (!(yMax > yMin)) continue;

      let xAx = norm(v3(f.R.x, 0, f.R.z));
      let zAx = norm(v3(f.T.x, 0, f.T.z));
      if (Math.hypot(xAx.x, xAx.z) < 1e-6) xAx = v3(1, 0, 0);
      if (Math.hypot(zAx.x, zAx.z) < 1e-6) zAx = v3(0, 0, 1);
      if (Math.abs(dot(xAx, zAx)) > 0.98) zAx = norm(v3(-xAx.z, 0, xAx.x));

      if (style === 'coaster') {
        const postHalf = clamp(pillarHalf * 0.62, 0.10, 0.46);
        const postSpread = clamp(beamHalfW * 0.76, 0.38, roadWidth * 0.44);
        if (blockedByAnyAnchor([
          { x: P.x, z: P.z, r: postHalf + 0.26, samples: 8 },
          { x: P.x + xAx.x * postSpread, z: P.z + xAx.z * postSpread, r: postHalf + 0.22, samples: 8 },
          { x: P.x - xAx.x * postSpread, z: P.z - xAx.z * postSpread, r: postHalf + 0.22, samples: 8 },
        ], yMin, yMax)) continue;
        const topY = deckY - Math.min(0.06 + roadThickness * 0.22, h * 0.24);
        const postTopY = topY - postHalf * 0.6;
        const postH = Math.max(0.20, postTopY - groundY);
        const yMid = groundY + postH * 0.5;
        const baseL = add(P, mul(xAx, postSpread));
        const baseC = P;
        const baseR = add(P, mul(xAx, -postSpread));
        meshAddOrientedBox(supports, v3(baseL.x, yMid, baseL.z), xAx, v3(0, 1, 0), zAx, postHalf, postH * 0.5, postHalf * 0.82);
        meshAddOrientedBox(supports, v3(baseC.x, yMid, baseC.z), xAx, v3(0, 1, 0), zAx, postHalf, postH * 0.5, postHalf * 0.82);
        meshAddOrientedBox(supports, v3(baseR.x, yMid, baseR.z), xAx, v3(0, 1, 0), zAx, postHalf, postH * 0.5, postHalf * 0.82);

        const lBot = v3(baseL.x, groundY + postHalf * 0.9, baseL.z);
        const cBot = v3(baseC.x, groundY + postHalf * 0.9, baseC.z);
        const rBot = v3(baseR.x, groundY + postHalf * 0.9, baseR.z);
        const lTop = v3(baseL.x, postTopY, baseL.z);
        const cTop = v3(baseC.x, postTopY, baseC.z);
        const rTop = v3(baseR.x, postTopY, baseR.z);
        const tieHalf = clamp(postHalf * 0.50, 0.05, 0.18);
        const braceHalf = clamp(postHalf * 0.42, 0.045, 0.16);
        addBeamBetween(lTop, cTop, tieHalf, tieHalf);
        addBeamBetween(cTop, rTop, tieHalf, tieHalf);
        addBeamBetween(lBot, cBot, tieHalf * 0.86, tieHalf * 0.86);
        addBeamBetween(cBot, rBot, tieHalf * 0.86, tieHalf * 0.86);
        addBeamBetween(lBot, cTop, braceHalf, braceHalf);
        addBeamBetween(cBot, lTop, braceHalf, braceHalf);
        addBeamBetween(cBot, rTop, braceHalf, braceHalf);
        addBeamBetween(rBot, cTop, braceHalf, braceHalf);

        const capA = add(v3(P.x, topY, P.z), mul(zAx, beamHalfZ));
        const capB = add(v3(P.x, topY, P.z), mul(zAx, -beamHalfZ));
        addBeamBetween(capA, capB, clamp(postHalf * 0.55, 0.06, 0.20), clamp(beamHalfH * 0.9, 0.05, 0.22));
      } else if (style === 'cliff') {
        const braceHalf = clamp(pillarHalf * 0.50, 0.07, 0.24);
        const coreHalf = clamp(pillarHalf * 0.76, 0.14, 0.56);
        const braceSpread = clamp(beamHalfW * 0.86, 0.54, roadWidth * 0.58);
        if (blockedByAnyAnchor([
          { x: P.x, z: P.z, r: coreHalf + 0.26, samples: 8 },
          { x: P.x + xAx.x * braceSpread, z: P.z + xAx.z * braceSpread, r: braceHalf + 0.22, samples: 8 },
          { x: P.x - xAx.x * braceSpread, z: P.z - xAx.z * braceSpread, r: braceHalf + 0.22, samples: 8 },
        ], yMin, yMax)) continue;
        const topY = deckY - Math.min(0.07 + roadThickness * 0.24, h * 0.22);
        const colH = Math.max(0.24, topY - groundY);
        meshAddOrientedBox(supports, v3(P.x, groundY + colH * 0.5, P.z), xAx, v3(0, 1, 0), zAx, coreHalf, colH * 0.5, coreHalf * 0.95);
        const topNode = v3(P.x, topY, P.z);
        const leftFoot = add(v3(P.x, groundY + braceHalf * 0.9, P.z), mul(xAx, braceSpread));
        const rightFoot = add(v3(P.x, groundY + braceHalf * 0.9, P.z), mul(xAx, -braceSpread));
        addBeamBetween(leftFoot, topNode, braceHalf, braceHalf);
        addBeamBetween(rightFoot, topNode, braceHalf, braceHalf);
        addBeamBetween(leftFoot, rightFoot, braceHalf * 0.68, braceHalf * 0.68);
        const capA = add(topNode, mul(zAx, beamHalfZ * 1.08));
        const capB = add(topNode, mul(zAx, -beamHalfZ * 1.08));
        addBeamBetween(capA, capB, clamp(coreHalf * 0.58, 0.09, 0.28), clamp(beamHalfH, 0.08, 0.30));
      } else if (style === 'concrete') {
        const pierHalfX = clamp(pillarHalf * 0.92, 0.16, 0.68);
        const pierHalfZ = clamp(pillarHalf * 1.34, 0.22, 0.92);
        const pierSpread = clamp(beamHalfW * 0.60, 0.42, roadWidth * 0.46);
        if (blockedByAnyAnchor([
          { x: P.x + xAx.x * pierSpread, z: P.z + xAx.z * pierSpread, r: pierHalfZ + 0.20, samples: 8 },
          { x: P.x - xAx.x * pierSpread, z: P.z - xAx.z * pierSpread, r: pierHalfZ + 0.20, samples: 8 },
        ], yMin, yMax)) continue;
        const topY = deckY - Math.min(0.08 + roadThickness * 0.25, h * 0.20);
        const pierH = Math.max(0.24, topY - groundY);
        const L = add(P, mul(xAx, pierSpread));
        const R = add(P, mul(xAx, -pierSpread));
        meshAddOrientedBox(supports, v3(L.x, groundY + pierH * 0.5, L.z), xAx, v3(0, 1, 0), zAx, pierHalfX, pierH * 0.5, pierHalfZ);
        meshAddOrientedBox(supports, v3(R.x, groundY + pierH * 0.5, R.z), xAx, v3(0, 1, 0), zAx, pierHalfX, pierH * 0.5, pierHalfZ);
        const beamCenter = v3(P.x, topY, P.z);
        const beamHalfWConcrete = clamp(beamHalfW * 1.04, 0.56, roadWidth * 0.66);
        const beamHalfHConcrete = clamp(beamHalfH * 1.28, 0.11, 0.46);
        const beamHalfZConcrete = clamp(beamHalfZ * 1.22, 0.24, 1.08);
        meshAddOrientedBox(supports, beamCenter, xAx, v3(0, 1, 0), zAx, beamHalfWConcrete, beamHalfHConcrete, beamHalfZConcrete);
      } else if (style === 'tree') {
        const trunkHalf = clamp(pillarHalf * 0.90, 0.11, 0.50);
        if (blockedByAnyAnchor([
          { x: P.x, z: P.z, r: trunkHalf + 0.30, samples: 10 },
        ], yMin, yMax)) continue;
        const trunkTopY = groundY + h * 0.74;
        const trunkH = Math.max(0.22, trunkTopY - groundY);
        meshAddOrientedBox(supports, v3(P.x, groundY + trunkH * 0.5, P.z), xAx, v3(0, 1, 0), zAx, trunkHalf, trunkH * 0.5, trunkHalf);

        const hub = v3(P.x, trunkTopY, P.z);
        const topY = deckY - Math.min(0.05 + roadThickness * 0.20, h * 0.20);
        const reachX = clamp(beamHalfW * 0.72, 0.28, roadWidth * 0.34);
        const reachZ = clamp(beamHalfZ * 1.24, 0.24, roadWidth * 0.26);
        const aL = add(v3(P.x, topY, P.z), mul(xAx, reachX));
        const aR = add(v3(P.x, topY, P.z), mul(xAx, -reachX));
        const aF = add(v3(P.x, topY - 0.05, P.z), mul(zAx, reachZ));
        const aB = add(v3(P.x, topY - 0.05, P.z), mul(zAx, -reachZ));
        const branchHalf = clamp(trunkHalf * 0.42, 0.05, 0.20);
        addBeamBetween(hub, aL, branchHalf, branchHalf);
        addBeamBetween(hub, aR, branchHalf, branchHalf);
        addBeamBetween(hub, aF, branchHalf * 0.95, branchHalf * 0.95);
        addBeamBetween(hub, aB, branchHalf * 0.95, branchHalf * 0.95);
        addBeamBetween(aL, aR, branchHalf * 0.82, branchHalf * 0.82);
      } else {
        if (blockedByAnyAnchor([
          { x: P.x, z: P.z, r: pillarHalf + 0.26, samples: 10 },
        ], yMin, yMax)) continue;
        const colCenter = v3(P.x, groundY + h * 0.5, P.z);
        meshAddOrientedBox(supports, colCenter, xAx, v3(0, 1, 0), zAx, pillarHalf, h * 0.5, pillarHalf);
        const beamY = deckY - Math.min(0.06 + roadThickness * 0.22, h * 0.25);
        const beamCenter = v3(P.x, beamY, P.z);
        meshAddOrientedBox(supports, beamCenter, xAx, v3(0, 1, 0), zAx, beamHalfW, beamHalfH, beamHalfZ);
      }
    }

    if (supports.faces.length) out.push({ mesh: supports, kind: 'support' });
    return out;
  }

  function buildSupportMeshesWithFallback(samples, frames, terrain, opts = {}) {
    const primary = buildSupportMeshes(samples, frames, terrain, opts);
    if (primary.length > 0) return primary;
    if (!opts?.enabled || !terrain || !samples || samples.length < 3) return primary;
    const roadBlockers = opts.roadBlockerIndex || opts.blockerIndex || null;
    const relaxed = buildSupportMeshes(samples, frames, terrain, {
      ...opts,
      blockerIndex: roadBlockers,
      minGap: Math.max(0.24, Math.min(0.72, (Number(opts.roadThickness || num('roadThickness')) * 0.72) + 0.18)),
      spacing: Math.max(2.0, Number(opts.spacing || (Number(opts.roadWidth || num('roadWidth')) * 1.75))),
    });
    return relaxed;
  }

  function meshAddSphere(mesh, center, radius, rings = 6, segs = 10) {
    const ring = [];
    for (let iy = 0; iy <= rings; iy++) {
      const v = iy / rings;
      const th = v * Math.PI;
      const y = Math.cos(th) * radius;
      const rr = Math.sin(th) * radius;
      const row = [];
      for (let ix = 0; ix <= segs; ix++) {
        const u = ix / segs;
        const ph = u * Math.PI * 2;
        const p = v3(center.x + Math.cos(ph) * rr, center.y + y, center.z + Math.sin(ph) * rr);
        row.push(meshAddVertex(mesh, p, u, v));
      }
      ring.push(row);
    }
    for (let iy = 0; iy < rings; iy++) {
      for (let ix = 0; ix < segs; ix++) {
        const a = ring[iy][ix];
        const b = ring[iy][ix + 1];
        const c = ring[iy + 1][ix + 1];
        const d = ring[iy + 1][ix];
        meshAddTri(mesh, a, b, c);
        meshAddTri(mesh, a, c, d);
      }
    }
  }

  function buildPlacedPropMeshes(opts, placements) {
    if (!opts?.enabled) return [];
    const out = [];
    const fences = placements?.fences || [];
    const trees = placements?.trees || [];
    const boulders = placements?.boulders || [];
    const fenceScale = clamp(opts.fenceScale ?? 0.55, 0, 1);
    const treeScale = clamp(opts.treeScale ?? 0.60, 0, 1);
    const rockScale = clamp(opts.rockScale ?? 0.65, 0, 1);

    if (fences.length) {
      const fence = makeMesh('placed_fences');
      const railH = 0.95 + fenceScale * 1.0;
      const spacing = 1.7;
      for (const seg of fences) {
        const a = seg.a, b = seg.b;
        const ab = sub(b, a);
        const L = len(ab);
        if (L < 0.6) continue;
        const dir = norm(ab);
        let side = cross(v3(0, 1, 0), dir);
        if (len(side) < 1e-6) side = v3(1, 0, 0); else side = norm(side);
        const posts = Math.max(2, Math.floor(L / spacing) + 1);
        const anchors = [];
        for (let i = 0; i < posts; i++) {
          const t = i / (posts - 1);
          const p = add(a, mul(ab, t));
          const postH = railH + 0.08 * Math.sin(i * 0.7);
          const c = v3(p.x, p.y + postH * 0.5, p.z);
          meshAddOrientedBox(fence, c, v3(1, 0, 0), v3(0, 1, 0), v3(0, 0, 1), 0.06, postH * 0.5, 0.06);
          anchors.push(v3(p.x, p.y + railH * 0.86, p.z));
        }
        for (let i = 0; i < anchors.length - 1; i++) {
          const p0 = anchors[i], p1 = anchors[i + 1];
          const vv = sub(p1, p0);
          const ll = len(vv);
          if (ll < 0.1) continue;
          const axis = norm(vv);
          const mid = mul(add(p0, p1), 0.5);
          meshAddOrientedBox(fence, mid, axis, v3(0, 1, 0), side, ll * 0.5, 0.035, 0.035);
          meshAddOrientedBox(fence, add(mid, v3(0, -0.26, 0)), axis, v3(0, 1, 0), side, ll * 0.5, 0.028, 0.03);
        }
      }
      if (fence.faces.length) out.push({ mesh: fence, kind: 'fence' });
    }

    if (trees.length) {
      const trunks = makeMesh('placed_tree_trunks');
      const leaves = makeMesh('placed_tree_leaves');
      for (const tr of trees) {
        const p = tr.pos;
        const s = (tr.scale || 1) * (0.75 + treeScale * 1.05);
        const rot = {
          x: Number(tr.rot?.x || 0),
          y: Number(tr.rot?.y || 0),
          z: Number(tr.rot?.z || 0),
        };
        const trunkH = 0.9 * s;
        const trunkR = 0.11 * s;
        const ax = rotateEuler(v3(1, 0, 0), rot);
        const ay = rotateEuler(v3(0, 1, 0), rot);
        const az = rotateEuler(v3(0, 0, 1), rot);
        const trunkCtr = add(v3(p.x, p.y, p.z), rotateEuler(v3(0, trunkH * 0.5, 0), rot));
        meshAddOrientedBox(trunks, trunkCtr, ax, ay, az, trunkR, trunkH * 0.5, trunkR);
        const leaf0 = add(v3(p.x, p.y, p.z), rotateEuler(v3(0, trunkH + 0.38 * s, 0), rot));
        const leaf1 = add(v3(p.x, p.y, p.z), rotateEuler(v3(0.16 * s, trunkH + 0.86 * s, -0.08 * s), rot));
        meshAddSphere(leaves, leaf0, 0.55 * s, 5, 9);
        meshAddSphere(leaves, leaf1, 0.40 * s, 5, 8);
      }
      if (trunks.faces.length) out.push({ mesh: trunks, kind: 'treeTrunk' });
      if (leaves.faces.length) out.push({ mesh: leaves, kind: 'treeLeaf' });
    }
    if (boulders.length) {
      const rocks = makeMesh('placed_boulders');
      for (let i = 0; i < boulders.length; i++) {
        const rk = boulders[i];
        const p = rk?.pos;
        if (!p) continue;
        const rot = {
          x: Number(rk.rot?.x || 0),
          y: Number(rk.rot?.y || 0),
          z: Number(rk.rot?.z || 0),
        };
        const seed = Number.isFinite(rk.seed) ? Number(rk.seed) : hash01(i + p.x * 0.37 + p.z * 0.19);
        const s = (rk.scale || 1) * (0.55 + rockScale * 1.05);
        const r0 = s * (0.38 + hash01(seed * 3.17 + 1.1) * 0.26);
        const r1 = r0 * (0.55 + hash01(seed * 5.91 + 2.3) * 0.32);
        const r2 = r0 * (0.36 + hash01(seed * 8.73 + 4.7) * 0.28);
        const o0 = rotateEuler(v3(0, r0 * 0.58, 0), rot);
        const o1 = rotateEuler(v3(
          (hash01(seed * 11.21 + 0.7) - 0.5) * r0 * 0.9,
          r0 * (0.35 + hash01(seed * 7.17 + 3.9) * 0.28),
          (hash01(seed * 13.47 + 1.2) - 0.5) * r0 * 0.9
        ), rot);
        const o2 = rotateEuler(v3(
          (hash01(seed * 17.03 + 2.1) - 0.5) * r0 * 1.1,
          r0 * (0.26 + hash01(seed * 19.87 + 5.4) * 0.24),
          (hash01(seed * 23.77 + 6.2) - 0.5) * r0 * 1.1
        ), rot);
        const c0 = add(v3(p.x, p.y, p.z), o0);
        const c1 = add(v3(p.x, p.y, p.z), o1);
        const c2 = add(v3(p.x, p.y, p.z), o2);
        meshAddSphere(rocks, c0, r0, 4, 7);
        meshAddSphere(rocks, c1, r1, 4, 6);
        meshAddSphere(rocks, c2, r2, 3, 5);
      }
      if (rocks.faces.length) out.push({ mesh: rocks, kind: 'rock' });
    }
    return out;
  }

  function materialKeyForMeshName(name = '') {
    const n = String(name || '').toLowerCase();
    if (n.includes('road_top')) return 'road_surface';
    if (n.includes('road_sides')) return 'road_walls';
    if (n.includes('road_bottom')) return 'road_bottom';
    if (n.includes('terrain')) return 'terrain';
    if (n.includes('theme_curb')) return 'curb';
    if (n.includes('theme_grass')) return 'grass';
    if (n.includes('theme_underdeck')) return 'underdeck';
    if (n.includes('bridge_deck_freeway')) return 'bridge_freeway';
    if (n.includes('bridge_deck_wood')) return 'bridge_wood';
    if (n.includes('bridge_deck_steel')) return 'bridge_steel';
    if (n.includes('support')) return 'support';
    if (n.includes('placed_fence')) return 'fence';
    if (n.includes('tree_trunk')) return 'tree_trunk';
    if (n.includes('tree_leaf')) return 'tree_leaf';
    if (n.includes('boulder') || n.includes('rock')) return 'rock';
    return 'default';
  }

  function buildDefaultMtlLibrary() {
    const mats = {
      road_surface: { kd: [0.28, 0.31, 0.38], ks: [0.04, 0.04, 0.04], ns: 30 },
      road_walls: { kd: [0.20, 0.22, 0.28], ks: [0.03, 0.03, 0.03], ns: 20 },
      road_bottom: { kd: [0.18, 0.19, 0.24], ks: [0.02, 0.02, 0.02], ns: 14 },
      terrain: { kd: [0.46, 0.40, 0.31], ks: [0.01, 0.01, 0.01], ns: 8 },
      curb: { kd: [0.81, 0.73, 0.53], ks: [0.05, 0.05, 0.05], ns: 18 },
      grass: { kd: [0.29, 0.53, 0.32], ks: [0.02, 0.02, 0.02], ns: 10 },
      underdeck: { kd: [0.38, 0.41, 0.46], ks: [0.03, 0.03, 0.03], ns: 14 },
      bridge_freeway: { kd: [0.48, 0.50, 0.54], ks: [0.05, 0.05, 0.05], ns: 24 },
      bridge_wood: { kd: [0.63, 0.44, 0.26], ks: [0.02, 0.02, 0.02], ns: 10 },
      bridge_steel: { kd: [0.49, 0.54, 0.61], ks: [0.07, 0.07, 0.07], ns: 34 },
      support: { kd: [0.56, 0.58, 0.62], ks: [0.04, 0.04, 0.04], ns: 20 },
      fence: { kd: [0.49, 0.36, 0.23], ks: [0.02, 0.02, 0.02], ns: 10 },
      tree_trunk: { kd: [0.42, 0.30, 0.18], ks: [0.01, 0.01, 0.01], ns: 6 },
      tree_leaf: { kd: [0.31, 0.65, 0.35], ks: [0.02, 0.02, 0.02], ns: 8 },
      rock: { kd: [0.53, 0.55, 0.58], ks: [0.03, 0.03, 0.03], ns: 12 },
      default: { kd: [0.60, 0.60, 0.60], ks: [0.02, 0.02, 0.02], ns: 8 },
    };
    let out = '# Track Generator MTL\n';
    for (const [name, m] of Object.entries(mats)) {
      out += `\nnewmtl ${name}\n`;
      out += `Ka ${(m.kd[0] * 0.25).toFixed(6)} ${(m.kd[1] * 0.25).toFixed(6)} ${(m.kd[2] * 0.25).toFixed(6)}\n`;
      out += `Kd ${m.kd[0].toFixed(6)} ${m.kd[1].toFixed(6)} ${m.kd[2].toFixed(6)}\n`;
      out += `Ks ${m.ks[0].toFixed(6)} ${m.ks[1].toFixed(6)} ${m.ks[2].toFixed(6)}\n`;
      out += `Ns ${Number(m.ns || 8).toFixed(6)}\n`;
      out += 'illum 2\n';
    }
    return out;
  }

  function meshesToOBJ(meshes, opts = {}) {
    const mtllib = String(opts.mtllib || '').trim();
    let out = '# Track Generator OBJ (Y up)\n';
    if (mtllib) out += `mtllib ${mtllib}\n`;
    let vOff = 0, vtOff = 0;
    for (const m of meshes) {
      out += `\no ${m.name}\n`;
      out += `usemtl ${materialKeyForMeshName(m.name)}\n`;
      for (const v of m.verts) out += `v ${v.x.toFixed(6)} ${v.y.toFixed(6)} ${v.z.toFixed(6)}\n`;
      for (const uv of m.uvs) out += `vt ${uv.u.toFixed(6)} ${uv.v.toFixed(6)}\n`;
      for (const f of m.faces) {
        const a = f.a + vOff, b = f.b + vOff, c = f.c + vOff;
        const au = (f.au ?? f.a) + vtOff, bu = (f.bu ?? f.b) + vtOff, cu = (f.cu ?? f.c) + vtOff;
        out += `f ${a}/${au} ${b}/${bu} ${c}/${cu}\n`;
      }
      vOff += m.verts.length;
      vtOff += m.uvs.length;
    }
    return out;
  }

  function triSoupMesh(name, meshes) {
    const out = { name, verts: [], faces: [] };
    for (const mesh of meshes || []) {
      if (!mesh?.verts?.length || !mesh?.faces?.length) continue;
      for (const f of mesh.faces) {
        const a = mesh.verts[f.a - 1];
        const b = mesh.verts[f.b - 1];
        const c = mesh.verts[f.c - 1];
        if (!a || !b || !c) continue;
        const ai = out.verts.push(v3(a.x, a.y, a.z)) - 1;
        const bi = out.verts.push(v3(b.x, b.y, b.z)) - 1;
        const ci = out.verts.push(v3(c.x, c.y, c.z)) - 1;
        out.faces.push([ai, bi, ci]);
      }
    }
    return out;
  }

  function buildEnfusionFbxModels(scene) {
    const visuals = [
      scene.roadTop,
      ...(scene.roadSides ? [scene.roadSides] : []),
      ...(scene.roadBottom ? [scene.roadBottom] : []),
      ...(scene.terrain ? [scene.terrain] : []),
      ...((scene.theme || []).map((t) => t?.mesh).filter(Boolean)),
      ...((scene.placed || []).map((t) => t?.mesh).filter(Boolean)),
    ];
    const collisionGeo = [
      scene.roadTop,
      ...(scene.roadSides ? [scene.roadSides] : []),
      ...(scene.roadBottom ? [scene.roadBottom] : []),
      ...((scene.theme || []).map((t) => t?.mesh).filter(Boolean)),
    ];
    const roadway = [scene.roadTop].filter(Boolean);
    return [
      triSoupMesh('VIS_Main_LOD0', visuals),
      triSoupMesh('GEO_Collision', collisionGeo),
      triSoupMesh('ROADWAY_Collision', roadway),
    ].filter((m) => m.verts.length && m.faces.length);
  }

  function meshesToFbxAscii(models, opts = {}) {
    const creator = String(opts.creator || 'KARTMAKER ARGH');
    const now = new Date();
    const pad2 = (v) => String(v).padStart(2, '0');
    const geomChunks = [];
    const modelChunks = [];
    const connChunks = [];
    let geomId = 900000;
    let modelId = 950000;

    for (const m of models || []) {
      if (!m?.verts?.length || !m?.faces?.length) continue;
      const gid = geomId++;
      const mid = modelId++;
      const verts = [];
      const polys = [];
      for (const v of m.verts) {
        verts.push(Number(v.x || 0).toFixed(6), Number(v.y || 0).toFixed(6), Number(v.z || 0).toFixed(6));
      }
      for (const f of m.faces) {
        polys.push(String(f[0]), String(f[1]), String(-(f[2] + 1)));
      }
      geomChunks.push(`
\t\tGeometry: ${gid}, \"Geometry::${m.name}\", \"Mesh\" {
\t\t\tVertices: *${verts.length} {
\t\t\t\ta: ${verts.join(',')}
\t\t\t}
\t\t\tPolygonVertexIndex: *${polys.length} {
\t\t\t\ta: ${polys.join(',')}
\t\t\t}
\t\t\tGeometryVersion: 124
\t\t}`);
      modelChunks.push(`
\t\tModel: ${mid}, \"Model::${m.name}\", \"Mesh\" {
\t\t\tVersion: 232
\t\t\tProperties70:  {
\t\t\t\tP: \"InheritType\", \"enum\", \"\",\"\",1
\t\t\t\tP: \"Lcl Translation\", \"Lcl Translation\", \"\",\"A\",0,0,0
\t\t\t\tP: \"Lcl Rotation\", \"Lcl Rotation\", \"\",\"A\",0,0,0
\t\t\t\tP: \"Lcl Scaling\", \"Lcl Scaling\", \"\",\"A\",1,1,1
\t\t\t}
\t\t\tShading: T
\t\t\tCulling: \"CullingOff\"
\t\t}`);
      connChunks.push(`
\t\tC: \"OO\",${gid},${mid}`);
      connChunks.push(`
\t\tC: \"OO\",${mid},0`);
    }
    if (!geomChunks.length) return '';

    return `; FBX 7.4.0 project file
; Created by ${creator}
FBXHeaderExtension:  {
\tFBXHeaderVersion: 1003
\tFBXVersion: 7400
\tCreationTimeStamp:  {
\t\tVersion: 1000
\t\tYear: ${now.getUTCFullYear()}
\t\tMonth: ${pad2(now.getUTCMonth() + 1)}
\t\tDay: ${pad2(now.getUTCDate())}
\t\tHour: ${pad2(now.getUTCHours())}
\t\tMinute: ${pad2(now.getUTCMinutes())}
\t\tSecond: ${pad2(now.getUTCSeconds())}
\t\tMillisecond: 0
\t}
\tCreator: \"${creator}\"
}
GlobalSettings:  {
\tVersion: 1000
\tProperties70:  {
\t\tP: \"UpAxis\", \"int\", \"Integer\", \"\",1
\t\tP: \"UpAxisSign\", \"int\", \"Integer\", \"\",1
\t\tP: \"FrontAxis\", \"int\", \"Integer\", \"\",2
\t\tP: \"FrontAxisSign\", \"int\", \"Integer\", \"\",1
\t\tP: \"CoordAxis\", \"int\", \"Integer\", \"\",0
\t\tP: \"CoordAxisSign\", \"int\", \"Integer\", \"\",1
\t\tP: \"UnitScaleFactor\", \"double\", \"Number\", \"\",1
\t}
}
Definitions:  {
\tVersion: 100
\tCount: 2
\tObjectType: \"Geometry\" {
\t\tCount: ${geomChunks.length}
\t}
\tObjectType: \"Model\" {
\t\tCount: ${modelChunks.length}
\t}
}
Objects:  {${geomChunks.join('')}${modelChunks.join('')}
}
Connections:  {${connChunks.join('')}
}
`;
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.rel = 'noopener';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadBinary(filename, bytes, mime = 'application/octet-stream') {
    const blob = new Blob([bytes], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.rel = 'noopener';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function encodePortableGraymap(width, height, values) {
    const header = `P5
${width} ${height}
255
`;
    const enc = new TextEncoder();
    const headBytes = enc.encode(header);
    const out = new Uint8Array(headBytes.length + values.length);
    out.set(headBytes, 0);
    out.set(values, headBytes.length);
    return out;
  }

  function terrainOptsFromUi(networkRoadWidthMax) {
    return {
      roadWidth: networkRoadWidthMax,
      roadThickness: num('roadThickness'),
      shoulderWidth: chk('themeOn') ? num('themeGrass') : 1.8,
      roadClearance: num('terrainClearance'),
      followRoad: num('terrainFollow'),
      detail: num('terrainDetail'),
      roughness: num('terrainRough'),
      cliffHeight: num('terrainCliff'),
      islandEnabled: chk('terrainIsland'),
      islandOffset: num('terrainIslandOffset'),
      islandFalloff: num('terrainIslandFalloff'),
      islandDrop: num('terrainIslandDrop'),
    };
  }

  function exportTerrainForEnfusion(baseName, terrain) {
    const grid = terrain?._grid;
    const meta = terrain?._meta;
    if (!grid || !meta) return false;
    const n = grid.nx * grid.nz;
    if (!n) return false;
    const hMin = Number.isFinite(meta.heightMin) ? meta.heightMin : 0;
    const hMax = Number.isFinite(meta.heightMax) ? meta.heightMax : 1;
    const hSpan = Math.max(1e-5, hMax - hMin);
    const h16 = new Uint16Array(n);
    for (let i = 0; i < n; i++) {
      const h = terrain.verts[i]?.y ?? hMin;
      const t = clamp((h - hMin) / hSpan, 0, 1);
      h16[i] = Math.round(t * 65535);
    }
    const hBytes = new Uint8Array(h16.buffer.slice(0));
    downloadBinary(`${baseName}_terrain_h16le.r16`, hBytes);

    const roadMask = new Uint8Array(n);
    const islandMask = new Uint8Array(n);
    const rm = meta.roadMask;
    const im = meta.islandMask;
    for (let i = 0; i < n; i++) {
      roadMask[i] = Math.round(clamp(Number(rm?.[i] ?? 0), 0, 1) * 255);
      islandMask[i] = Math.round(clamp(Number(im?.[i] ?? 0), 0, 1) * 255);
    }
    downloadBinary(`${baseName}_road_mask.pgm`, encodePortableGraymap(grid.nx, grid.nz, roadMask), 'image/x-portable-graymap');
    downloadBinary(`${baseName}_island_mask.pgm`, encodePortableGraymap(grid.nx, grid.nz, islandMask), 'image/x-portable-graymap');

    const exportMeta = {
      format: 'kartmaker-enfusion-terrain-v1',
      source: 'KARTMAKER ARGH',
      heightmapFile: `${baseName}_terrain_h16le.r16`,
      roadMaskFile: `${baseName}_road_mask.pgm`,
      islandMaskFile: `${baseName}_island_mask.pgm`,
      grid: {
        widthSamples: grid.nx,
        heightSamples: grid.nz,
        cellSizeX: grid.sx,
        cellSizeZ: grid.sz,
        originX: grid.minX,
        originZ: grid.minZ,
      },
      heights: {
        min: hMin,
        max: hMax,
        span: hSpan,
      },
      island: {
        enabled: !!meta.islandEnabled,
        offset: Number(meta.islandOffset || 0),
        falloff: Number(meta.islandFalloff || 0),
        drop: Number(meta.islandDrop || 0),
      },
      reforgerNotes: [
        'Import heightmap as 16-bit RAW little-endian.',
        'Use grid cell size to match world scale in Enfusion terrain project.',
        'Use road_mask.pgm to paint navmesh-safe road corridors and material masks before regenerating navmesh.',
      ],
    };
    downloadText(`${baseName}_terrain_enfusion.json`, JSON.stringify(exportMeta, null, 2));
    return true;
  }

  // ---------- DOM ----------
  const $ = (id) => document.getElementById(id);
  const num = (id) => Number($(id).value);
  const chk = (id) => $(id).checked;
  const txt = (id) => $(id).value;

  const ROAD_CLASS_DEFAULTS = Object.freeze({
    local: { direction: 'two_way', lanesForward: 1, lanesReverse: 1, speedTarget: 30, minRadius: 16, maxGrade: 0.12 },
    collector: { direction: 'two_way', lanesForward: 1, lanesReverse: 1, speedTarget: 40, minRadius: 28, maxGrade: 0.10 },
    arterial: { direction: 'two_way', lanesForward: 2, lanesReverse: 2, speedTarget: 50, minRadius: 60, maxGrade: 0.08 },
    freeway: { direction: 'two_way', lanesForward: 2, lanesReverse: 2, speedTarget: 65, minRadius: 120, maxGrade: 0.06 },
    ramp: { direction: 'a_to_b', lanesForward: 1, lanesReverse: 0, speedTarget: 40, minRadius: 36, maxGrade: 0.10 },
  });

  function roadClassKey(k) {
    if (typeof k !== 'string') return 'collector';
    const key = k.toLowerCase().trim();
    return ROAD_CLASS_DEFAULTS[key] ? key : 'collector';
  }

  function roadDirKey(dir) {
    if (dir === 'two_way' || dir === 'a_to_b' || dir === 'b_to_a') return dir;
    return 'a_to_b';
  }

  function normalizeRoadEdgeSpec(raw, fallbackClass = 'collector', fallbackDir = 'two_way') {
    const cls = roadClassKey(raw?.roadClass || fallbackClass);
    const def = ROAD_CLASS_DEFAULTS[cls];
    const dir = roadDirKey(raw?.direction || fallbackDir || def.direction);
    const lanesForward = clamp(Math.round(Number(raw?.lanesForward ?? def.lanesForward)), 1, 8);
    let lanesReverse = clamp(Math.round(Number(raw?.lanesReverse ?? def.lanesReverse)), 0, 8);
    if (dir !== 'two_way') lanesReverse = 0;
    else if (lanesReverse < 1) lanesReverse = 1;
    const speedTarget = clamp(Number.isFinite(raw?.speedTarget) ? Number(raw.speedTarget) : def.speedTarget, 15, 120);
    const minRadius = Math.max(4, Number.isFinite(raw?.minRadius) ? Number(raw.minRadius) : def.minRadius);
    const maxGrade = clamp(Number.isFinite(raw?.maxGrade) ? Number(raw.maxGrade) : def.maxGrade, 0.01, 0.25);
    return { roadClass: cls, direction: dir, lanesForward, lanesReverse, speedTarget, minRadius, maxGrade };
  }

  function edgeLaneCount(spec) {
    if (!spec) return 0;
    return spec.direction === 'two_way'
      ? (Number(spec.lanesForward || 0) + Number(spec.lanesReverse || 0))
      : Number(spec.lanesForward || 0);
  }

  function roadWidthMultiplierForSpec(spec) {
    const lanes = clamp(edgeLaneCount(spec), 1, 16);
    let mul = 0.65 + lanes * 0.175;
    if (spec?.roadClass === 'freeway') mul *= 1.08;
    if (spec?.roadClass === 'ramp') mul *= 0.92;
    return clamp(mul, 0.75, 2.7);
  }

  function setClassPresetControls(classId, dirId, lanesFId, lanesRId) {
    const cls = roadClassKey(txt(classId));
    const def = ROAD_CLASS_DEFAULTS[cls];
    $(dirId).value = def.direction;
    $(lanesFId).value = String(def.lanesForward);
    $(lanesRId).value = String(def.lanesReverse);
  }

  function getMainRoadSpec() {
    return normalizeRoadEdgeSpec({
      roadClass: txt('mainRoadClass'),
      direction: txt('mainRoadDir'),
      lanesForward: num('mainLanesF'),
      lanesReverse: num('mainLanesR'),
    }, 'collector', 'a_to_b');
  }

  function getNewBranchSpecDefaults(kind = 'join') {
    const fallbackClass = kind === 'fork' ? 'ramp' : 'collector';
    return normalizeRoadEdgeSpec({
      roadClass: txt('newBranchClass') || fallbackClass,
      direction: txt('newBranchDir'),
      lanesForward: num('newBranchLanesF'),
      lanesReverse: num('newBranchLanesR'),
    }, fallbackClass, kind === 'fork' ? 'a_to_b' : 'two_way');
  }

  function describeRoadSpec(spec) {
    const lanes = edgeLaneCount(spec);
    return `${lanes} lane${lanes === 1 ? '' : 's'} • ${Math.round(spec.speedTarget)} mph • Rmin ${Math.round(spec.minRadius)} • Grade ${(spec.maxGrade * 100).toFixed(1)}%`;
  }

  const editWrap = $('editWrap');
  const editCard = $('editCard');
  const edit = $('edit');
  const ectx = edit.getContext('2d');
  const ctrlCard = $('ctrlCard');
  const ctrlToggleBtn = $('ctrlToggle');
  const genQuickBtn = $('genQuickBtn');
  const saveBtn = $('saveBtn');
  const loadBtn = $('loadBtn');
  const loadProjectFile = $('loadProjectFile');
  const toggleHintsBtn = $('toggleHintsBtn');
  const helpModal = $('helpModal');
  const helpCloseBtn = $('helpCloseBtn');
  const helpCloseBtn2 = $('helpCloseBtn2');
  const helpInlineToggleBtn = $('helpInlineToggle');
  const viewWrap = $('viewWrap');
  const viewCard = $('viewCard');
  const splitter = $('splitter');
  const view = $('view');
  const vctx = view.getContext('2d');
  const wrapEl = document.querySelector('.wrap');
  if (!ectx || !vctx) throw new Error('Canvas context failed');

  // keyboard state
  const keysDown = new Set();
  window.addEventListener('keydown', (e) => { keysDown.add(e.code); });
  window.addEventListener('keyup', (e) => { keysDown.delete(e.code); });
  const isSpace = () => keysDown.has('Space');

  // state
  let mode = 'draw';
  let points = [
    { pos: v3(-6, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(-2, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(4, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(7, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(4, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    { pos: v3(-2, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
  ];
  let selected = -1;
  let selectedBranch = null; // { sec:number, mid:number }
  let selectedBranchSet = new Set(); // key: "sec:mid"
  let selectedSet = new Set();
  let dragIndex = null;
  let dragBranch = null; // { sec:number, mid:number }
  let dragBranchGroupOffsets = null; // [{sec,mid,dx,dz}]
  let dragGroupOffsets = null;
  let dragHandle = null; // {i, which:'in'|'out', len:number}
  let pan2 = { x: 0, y: 0 };
  let isPanning2 = false;
  let last2 = null;
  let cached = null;
  let joinTool = { phase: 0, startIdx: -1 };
  let ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
  let splitEnds = [];
  let mainBreaks = new Set(); // break edge i -> i+1 in main polyline
  let branchSections = []; // { a,b,kind,bend,lift,roadClass,direction,lanesForward,lanesReverse,speedTarget,minRadius,maxGrade,mids[] }
  let lastGeneratedMeta = null; // { style, comboStyles[], branchCount }
  let roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
  let placedTrees = [];   // { pos:v3, scale:number, rot:{x,y,z} }
  let placedFences = [];  // { a:v3, b:v3 }
  let placedBoulders = []; // { pos:v3, scale:number, seed:number, rot:{x,y,z} }
  let fencePlaceStart = null;
  let selectedProp = null; // { kind:'tree'|'fence'|'fenceEndpoint'|'boulder', i:number, end?:'a'|'b' }
  let propHover = null;    // hover shape like selectedProp
  let propGizmoMode = 'move'; // move | rotate | scale
  let drawTool = { anchorIdx: -1, pendingNewLine: false };

  // 3D camera (free look + orbit selected)
  const CAM_SPEED_DEFAULT = 22;
  const camBaseSpeedFromRadius = (r) => clamp(Number(r || 0) * 2.2, 18, 120);
  let camEye = v3(24, 12, -24);
  let camYaw = 0.75, camPitch = 0.35;
  let camSpeedBase = CAM_SPEED_DEFAULT;
  let camMoveSpeed = CAM_SPEED_DEFAULT;
  let isLookR = false, isLookL = false, isPan3 = false, isOrbitSel = false;
  let last3 = null;
  let lastViewMouse = null; // {sx,sy,w,h}
  let lmbMoved = false, mmbMoved = false;
  let pickOnRelease = -1;

  // gizmo
  let gizmo = { active: false, target: null, mode: 'move', axis: null, startMouse: null, startPos: null, startProp: null, startSel: null, depth: 1 };
  let gizmoHoverAxis = null;
  let gizmoGhost = null; // {pos, axis}
  let bezier3DHover = null; // {kind:'main'|'branch', i?|sec?|mid?, which:'in'|'out'}
  let bezier3DDrag = null;  // {target, which, depth, startMouse, startHX, startHZ}
  let viewMode = 'normal'; // render | normal | wireframe
  let ctrlUiMode = 'simple'; // simple | advanced
  const PROJECT_STORAGE_KEY = 'mk_track_project_v1';
  let autoSaveTimer = null;
  let latestMathReport = null;
  let mathReportCacheKey = '';
  let mathReportCacheAt = 0;
  let sceneVersion = 1;
  let overlay2DCache = { version: -1, net: null, netDesc: null, mathReport: null };

  function bumpSceneVersion() {
    sceneVersion++;
    cached = null;
    overlay2DCache.version = -1;
  }

  // ---------- undo / redo ----------
  const undoStack = [];
  const redoStack = [];
  function deepClonePoints(ps) {
    return ps.map(p => ({
      pos: v3(p.pos.x, p.pos.y, p.pos.z),
      bank: Number(p.bank || 0),
      node: p.node || 'smooth',
      hin: { x: Number(p.hin?.x || 0), z: Number(p.hin?.z || 0) },
      hout: { x: Number(p.hout?.x || 0), z: Number(p.hout?.z || 0) },
    }));
  }
  function cloneTrees(ts) {
    return (ts || []).map((t) => ({
      pos: v3(t.pos.x, t.pos.y, t.pos.z),
      scale: Number(t.scale || 1),
      rot: {
        x: Number(t.rot?.x || 0),
        y: Number(t.rot?.y || 0),
        z: Number(t.rot?.z || 0),
      },
    }));
  }
  function cloneFences(fs) {
    return (fs || []).map(f => ({ a: v3(f.a.x, f.a.y, f.a.z), b: v3(f.b.x, f.b.y, f.b.z) }));
  }
  function cloneBoulders(rs) {
    return (rs || []).map((r) => ({
      pos: v3(r.pos.x, r.pos.y, r.pos.z),
      scale: Number(r.scale || 1),
      seed: Number.isFinite(r.seed) ? Number(r.seed) : hash01((r.pos?.x || 0) * 0.37 + (r.pos?.z || 0) * 0.19),
      rot: {
        x: Number(r.rot?.x || 0),
        y: Number(r.rot?.y || 0),
        z: Number(r.rot?.z || 0),
      },
    }));
  }
  function snapshot() {
    return {
      points: deepClonePoints(points),
      placedTrees: cloneTrees(placedTrees),
      placedFences: cloneFences(placedFences),
      placedBoulders: cloneBoulders(placedBoulders),
      fencePlaceStart: fencePlaceStart ? v3(fencePlaceStart.x, fencePlaceStart.y, fencePlaceStart.z) : null,
      selected,
      selectedIndices: Array.from(selectedSet),
      selectedBranchIndices: Array.from(selectedBranchSet),
      splitEnds: Array.from(splitEnds),
      mainBreaks: Array.from(mainBreaks),
      branchSections: branchSections.map((s) => ({
        a: s.a,
        b: s.b,
        kind: s.kind || 'join',
        bend: Number(s.bend || 0),
        lift: Number(s.lift || 0),
        roadClass: roadClassKey(s.roadClass || 'collector'),
        direction: roadDirKey(s.direction || 'two_way'),
        lanesForward: clamp(Math.round(Number(s.lanesForward || 1)), 1, 8),
        lanesReverse: clamp(Math.round(Number(s.lanesReverse || 0)), 0, 8),
        speedTarget: Number.isFinite(s.speedTarget) ? Number(s.speedTarget) : undefined,
        minRadius: Number.isFinite(s.minRadius) ? Number(s.minRadius) : undefined,
        maxGrade: Number.isFinite(s.maxGrade) ? Number(s.maxGrade) : undefined,
        mids: Array.isArray(s.mids) ? s.mids.map((m) => ({
          u: Number(m.u || 0),
          x: Number(m.x || 0),
          y: Number(m.y || 0),
          z: Number(m.z || 0),
          bevel: Number(m.bevel ?? 0.55),
          node: m.node || 'smooth',
          hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
          hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
        })) : [],
      })),
      pan2: { x: pan2.x, y: pan2.y },
      cam: { camEye: v3(camEye.x, camEye.y, camEye.z), camYaw, camPitch, camMoveSpeed },
    };
  }
  function restoreSnap(s) {
    points = deepClonePoints(s.points || []);
    placedTrees = cloneTrees(s.placedTrees || []);
    placedFences = cloneFences(s.placedFences || []);
    placedBoulders = cloneBoulders(s.placedBoulders || []);
    fencePlaceStart = s.fencePlaceStart ? v3(s.fencePlaceStart.x, s.fencePlaceStart.y, s.fencePlaceStart.z) : null;
    selectedProp = null;
    propHover = null;
    selected = typeof s.selected === 'number' ? s.selected : -1;
    selectedSet = new Set((s.selectedIndices || []).filter((i) => Number.isInteger(i) && i >= 0 && i < points.length));
    if (selected >= 0) selectedSet.add(selected);
    selectedBranchSet = new Set((s.selectedBranchIndices || []).filter((k) => typeof k === 'string'));
    selectedBranch = null;
    splitEnds = Array.from(new Set((s.splitEnds || []).filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
    mainBreaks = new Set((s.mainBreaks || []).filter((i) => Number.isInteger(i) && i >= 0 && i < Math.max(0, points.length - 1)));
    branchSections = Array.isArray(s.branchSections) ? s.branchSections.map((x) => ({
      a: Number(x.a),
      b: Number(x.b),
      kind: x.kind === 'fork' ? 'fork' : 'join',
      bend: Number(x.bend || 0),
      lift: Number(x.lift || 0),
      roadClass: roadClassKey(x.roadClass || 'collector'),
      direction: roadDirKey(x.direction || 'two_way'),
      lanesForward: clamp(Math.round(Number(x.lanesForward || 1)), 1, 8),
      lanesReverse: clamp(Math.round(Number(x.lanesReverse || 0)), 0, 8),
      speedTarget: Number.isFinite(x.speedTarget) ? Number(x.speedTarget) : undefined,
      minRadius: Number.isFinite(x.minRadius) ? Number(x.minRadius) : undefined,
      maxGrade: Number.isFinite(x.maxGrade) ? Number(x.maxGrade) : undefined,
      mids: Array.isArray(x.mids) ? x.mids.map((m) => ({
        u: Number(m.u || 0),
        x: Number(m.x || 0),
        y: Number(m.y || 0),
        z: Number(m.z || 0),
        bevel: Number(m.bevel ?? 0.55),
        node: m.node || 'smooth',
        hin: { x: Number(m.hin?.x || 0), z: Number(m.hin?.z || 0) },
        hout: { x: Number(m.hout?.x || 0), z: Number(m.hout?.z || 0) },
      })) : [],
    })) : [];
    pan2 = { x: Number(s.pan2?.x || 0), y: Number(s.pan2?.y || 0) };
    if (s.cam) {
      // Back-compat: camTarget/camDist snapshots from earlier builds.
      if (s.cam.camEye) camEye = v3(s.cam.camEye?.x || 0, s.cam.camEye?.y || 0, s.cam.camEye?.z || 0);
      else {
        const ct = v3(s.cam.camTarget?.x || 0, s.cam.camTarget?.y || 0, s.cam.camTarget?.z || 0);
        const cy = Math.cos(Number(s.cam.camYaw ?? camYaw)), sy = Math.sin(Number(s.cam.camYaw ?? camYaw));
        const cp = Math.cos(Number(s.cam.camPitch ?? camPitch)), sp = Math.sin(Number(s.cam.camPitch ?? camPitch));
        const dist = Number(s.cam.camDist ?? 28);
        const dir = v3(cy * cp, sp, -sy * cp);
        camEye = add(ct, mul(dir, dist));
      }
      camYaw = Number(s.cam.camYaw ?? camYaw);
      camPitch = Number(s.cam.camPitch ?? camPitch);
      camMoveSpeed = Number(s.cam.camMoveSpeed ?? camMoveSpeed);
    }
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    drawTool = { anchorIdx: -1, pendingNewLine: false };
    drawTool.anchorIdx = -1;
    drawTool.pendingNewLine = false;
    sanitizeBranchSections();
    selectedBranch = null;
    if (mode !== 'fenceplace') fencePlaceStart = null;
    gizmo.active = false;
    gizmo.target = null;
    gizmo.mode = 'move';
    gizmo.axis = null;
    gizmo.startProp = null;
    gizmo.startSel = null;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    bumpSceneVersion();
  }
  function pushUndo() {
    undoStack.push(snapshot());
    if (undoStack.length > 160) undoStack.shift();
    redoStack.length = 0;
  }
  function undo() {
    if (!undoStack.length) return;
    redoStack.push(snapshot());
    restoreSnap(undoStack.pop());
  }
  function redo() {
    if (!redoStack.length) return;
    undoStack.push(snapshot());
    restoreSnap(redoStack.pop());
  }

  function isTypingTarget(el) {
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
  }

  window.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && String(e.key || '').toLowerCase() === 'f') {
      e.preventDefault();
      if (document.body.classList.contains('ctrl-collapsed')) {
        document.body.classList.remove('ctrl-collapsed');
        syncCtrlToggleUI();
        resizeAll();
      }
      ctrlUiMode = 'advanced';
      applyControlUiFilters();
      return;
    }

    // node type hotkeys (when not typing)
    if (!isTypingTarget(document.activeElement) && selected >= 0) {
      if (e.key === '1') { e.preventDefault(); setSelectedNode('smooth'); }
      if (e.key === '2') { e.preventDefault(); setSelectedNode('aligned'); }
      if (e.key === '3') { e.preventDefault(); setSelectedNode('corner'); }
    }

    // Reforger-like camera discrete rotate
    if (!isTypingTarget(document.activeElement)) {
      const step = 7.5 * Math.PI / 180;
      if (e.code === 'Numpad8') { e.preventDefault(); camPitch = clamp(camPitch + step, -1.48, 1.48); }
      if (e.code === 'Numpad2') { e.preventDefault(); camPitch = clamp(camPitch - step, -1.48, 1.48); }
      if (e.code === 'Numpad4') { e.preventDefault(); camYaw += step; }
      if (e.code === 'Numpad6') { e.preventDefault(); camYaw -= step; }
      if (e.code === 'KeyN' && mode === 'draw' && !(e.ctrlKey || e.metaKey || e.altKey)) {
        e.preventDefault();
        startNewDetachedLine();
      }
      if (e.key.toLowerCase() === 'f') { e.preventDefault(); frame3D(); }
      if (e.key === 'Escape' && mode === 'fenceplace') { fencePlaceStart = null; }
      if (e.key === 'Escape' && mode === 'roundabout' && roundTool.phase > 0) {
        roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
      }
      if (e.key === 'Escape' && mode === 'propedit' && selectedProp) {
        clearPropSelection();
        syncSelectedUI();
      }
      if (e.code === 'KeyG' && !(e.ctrlKey || e.metaKey || e.altKey) && mode !== 'propedit' && mode !== 'treeplace' && mode !== 'fenceplace' && mode !== 'boulderplace') {
        const hasMain = selected >= 0 && !!points[selected];
        const hasBranch = !!branchMidRef(selectedBranch);
        if (hasMain || hasBranch) {
          e.preventDefault();
          const r = viewWrap.getBoundingClientRect();
          const w = r.width;
          const h = r.height;
          const sx = clamp(Number(lastViewMouse?.sx ?? (w * 0.5)), 0, Math.max(1, w - 1));
          const sy = clamp(Number(lastViewMouse?.sy ?? (h * 0.5)), 0, Math.max(1, h - 1));
          const eye = camPos();
          const target = add(eye, camForward());
          const basis = lookAtBasis(eye, target);
          beginRoadGizmoDrag3D(hasBranch ? 'branch' : 'point', sx, sy, eye, basis, w, h);
          keysDown.delete('KeyG');
        }
      }
      if (mode === 'propedit' && !(e.ctrlKey || e.metaKey || e.altKey)) {
        if (e.code === 'KeyW') {
          e.preventDefault();
          propGizmoMode = 'move';
          syncPropGizmoUI();
          keysDown.delete('KeyW');
        } else if (e.code === 'KeyE') {
          e.preventDefault();
          propGizmoMode = 'rotate';
          syncPropGizmoUI();
          keysDown.delete('KeyE');
        } else if (e.code === 'KeyR') {
          e.preventDefault();
          propGizmoMode = 'scale';
          syncPropGizmoUI();
          keysDown.delete('KeyR');
        }
      }
    }

    // Undo/redo
    if ((e.ctrlKey || e.metaKey) && !isTypingTarget(document.activeElement)) {
      const k = e.key.toLowerCase();
      if (k === 'z') {
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
        return;
      }
      if (k === 'y') {
        e.preventDefault();
        redo();
        return;
      }
    }

    // Delete selected point(s)
    if ((e.key === 'Delete' || e.key === 'Backspace') && !isTypingTarget(document.activeElement)) {
      sanitizePropSelection();
      if (selectedProp) {
        e.preventDefault();
        pushUndo();
        if (selectedProp.kind === 'tree') {
          if (selectedProp.i >= 0 && selectedProp.i < placedTrees.length) placedTrees.splice(selectedProp.i, 1);
        } else if (selectedProp.kind === 'boulder') {
          if (selectedProp.i >= 0 && selectedProp.i < placedBoulders.length) placedBoulders.splice(selectedProp.i, 1);
        } else {
          if (selectedProp.i >= 0 && selectedProp.i < placedFences.length) placedFences.splice(selectedProp.i, 1);
        }
        clearPropSelection();
        syncSelectedUI();
        bumpSceneVersion();
        return;
      }
      sanitizeBranchSelection();
      if (selectedBranchSet.size || selectedBranch) {
        e.preventDefault();
        pushUndo();
        const all = selectedBranchSet.size ? Array.from(selectedBranchSet) : [branchSelKey(selectedBranch.sec, selectedBranch.mid)];
        const pairs = all.map(parseBranchSelKey).filter(Boolean)
          .sort((a, b) => (b.sec - a.sec) || (b.mid - a.mid));
        for (const p of pairs) {
          const mids = branchSections[p.sec]?.mids;
          if (!Array.isArray(mids) || !mids[p.mid]) continue;
          mids.splice(p.mid, 1);
        }
        sanitizeBranchSections();
        selectedBranch = null;
        selectedBranchSet.clear();
        syncSelectedUI();
        bumpSceneVersion();
        return;
      }
      if (selectedSet.size > 0 || selected >= 0) {
        e.preventDefault();
        pushUndo();
        const del = selectedSet.size ? new Set(selectedSet) : new Set(selected >= 0 ? [selected] : []);
        const idxs = Array.from(del).sort((a, b) => b - a);
        for (const idx of idxs) {
          if (idx < 0 || idx >= points.length) continue;
          points.splice(idx, 1);
          remapSplitEndsForSplice(idx, 1, 0);
        }
        selected = -1;
        selectedSet.clear();
        syncSelectedUI();
        bumpSceneVersion();
      }
    }
  });

  // ---------- selection / picking ----------
  function origin2() {
    const r = editWrap.getBoundingClientRect();
    return { x: r.width / 2 + pan2.x, y: r.height / 2 + pan2.y };
  }
  function screenFromWorld2(p, org, s) {
    const iso = isoProject(p, s);
    return { x: org.x + iso.x, y: org.y + iso.y };
  }

  function nearestPointScreen(sx, sy, org, s, maxPix) {
    let best = -1;
    let bd = maxPix;
    for (let i = 0; i < points.length; i++) {
      const sp = screenFromWorld2(points[i].pos, org, s);
      const d = Math.hypot(sp.x - sx, sp.y - sy);
      if (d < bd) { bd = d; best = i; }
    }
    return best;
  }

  function closestPointOnScreenSegment(sx, sy, ax, ay, bx, by) {
    const vx = bx - ax;
    const vy = by - ay;
    const len2 = vx * vx + vy * vy;
    if (len2 < 1e-8) return { t: 0, x: ax, y: ay, d: Math.hypot(sx - ax, sy - ay) };
    let t = ((sx - ax) * vx + (sy - ay) * vy) / len2;
    t = clamp(t, 0, 1);
    const x = ax + vx * t;
    const y = ay + vy * t;
    return { t, x, y, d: Math.hypot(sx - x, sy - y) };
  }

  function nearestCurveHitScreen(sx, sy, org, s, maxPix = 12) {
    if (points.length < 2) return null;
    ensureHandles(points);
    const segs = mainConnectedSegments();
    if (!segs.length) return null;
    const steps = Math.max(10, Math.min(48, Math.round(effectiveSubdiv() * 2)));
    let best = null;

    for (const segDesc of segs) {
      const i = segDesc.a;
      const j = segDesc.b;
      const a = points[i];
      const b = points[j];
      const p0 = a.pos;
      const p1 = b.pos;
      const c0 = add(p0, v3(a.hout.x, 0, a.hout.z));
      const c1 = add(p1, v3(b.hin.x, 0, b.hin.z));
      let prev = bezier(p0, c0, c1, p1, 0);
      let prevSp = screenFromWorld2(prev, org, s);
      for (let k = 1; k <= steps; k++) {
        const t1 = k / steps;
        const cur = bezier(p0, c0, c1, p1, t1);
        const curSp = screenFromWorld2(cur, org, s);
        const hit = closestPointOnScreenSegment(sx, sy, prevSp.x, prevSp.y, curSp.x, curSp.y);
        if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
          const t0 = (k - 1) / steps;
          const t = t0 + (t1 - t0) * hit.t;
          const pos = bezier(p0, c0, c1, p1, t);
          const tan = bezierDeriv(p0, c0, c1, p1, t);
          best = {
            dist: hit.d,
            seg: segDesc.seg,
            segA: i,
            segB: j,
            t,
            pos,
            tan,
            insertIndex: segDesc.insertIndex,
            bank: (1 - t) * a.bank + t * b.bank,
          };
        }
        prev = cur;
        prevSp = curSp;
      }
    }
    return best;
  }


  function clearPropSelection() {
    selectedProp = null;
    propHover = null;
  }

  function clonePropSel(sel) {
    if (!sel || typeof sel !== 'object') return null;
    if (!Number.isInteger(sel.i) || sel.i < 0) return null;
    const kind = sel.kind;
    if (kind !== 'tree' && kind !== 'fence' && kind !== 'fenceEndpoint' && kind !== 'boulder') return null;
    if (kind === 'fenceEndpoint') {
      const end = sel.end === 'b' ? 'b' : 'a';
      return { kind, i: sel.i, end };
    }
    return { kind, i: sel.i };
  }

  function sanitizePropSelection() {
    if (!selectedProp) return;
    const i = selectedProp.i;
    if (!Number.isInteger(i) || i < 0) { selectedProp = null; return; }
    if (selectedProp.kind === 'tree' && i >= placedTrees.length) { selectedProp = null; return; }
    if (selectedProp.kind === 'boulder' && i >= placedBoulders.length) { selectedProp = null; return; }
    if ((selectedProp.kind === 'fence' || selectedProp.kind === 'fenceEndpoint') && i >= placedFences.length) { selectedProp = null; return; }
  }

  function setSelectedProp(sel) {
    const next = clonePropSel(sel);
    selectedProp = next;
    propHover = next ? clonePropSel(next) : null;
    selected = -1;
    selectedSet.clear();
    selectedBranch = null;
    selectedBranchSet.clear();
  }

  function selectedPropCount() {
    return selectedProp ? 1 : 0;
  }

  function propGizmoModeLabel(m) {
    if (m === 'rotate') return 'Rotate';
    if (m === 'scale') return 'Scale';
    return 'Move';
  }

  function syncPropGizmoUI() {
    const btn = $('propGizmoBtn');
    if (!btn) return;
    btn.textContent = `Gizmo: ${propGizmoModeLabel(propGizmoMode)}`;
  }

  function cyclePropGizmoMode() {
    const modes = ['move', 'rotate', 'scale'];
    const i = modes.indexOf(propGizmoMode);
    propGizmoMode = modes[(i + 1) % modes.length];
    syncPropGizmoUI();
  }

  function axisVec(axis) {
    if (axis === 'x') return v3(1, 0, 0);
    if (axis === 'y') return v3(0, 1, 0);
    return v3(0, 0, 1);
  }

  function propPivot(sel = selectedProp) {
    if (!sel) return null;
    if (sel.kind === 'tree') return placedTrees[sel.i]?.pos || null;
    if (sel.kind === 'boulder') return placedBoulders[sel.i]?.pos || null;
    const f = placedFences[sel.i];
    if (!f) return null;
    if (sel.kind === 'fenceEndpoint') return sel.end === 'b' ? f.b : f.a;
    return mul(add(f.a, f.b), 0.5);
  }

  function capturePropTransform(sel = selectedProp) {
    if (!sel) return null;
    if (sel.kind === 'tree') {
      const t = placedTrees[sel.i];
      if (!t) return null;
      return {
        pos: v3(t.pos.x, t.pos.y, t.pos.z),
        scale: Number(t.scale || 1),
        rot: { x: Number(t.rot?.x || 0), y: Number(t.rot?.y || 0), z: Number(t.rot?.z || 0) },
        pivot: v3(t.pos.x, t.pos.y, t.pos.z),
      };
    }
    if (sel.kind === 'boulder') {
      const r = placedBoulders[sel.i];
      if (!r) return null;
      return {
        pos: v3(r.pos.x, r.pos.y, r.pos.z),
        scale: Number(r.scale || 1),
        rot: { x: Number(r.rot?.x || 0), y: Number(r.rot?.y || 0), z: Number(r.rot?.z || 0) },
        pivot: v3(r.pos.x, r.pos.y, r.pos.z),
      };
    }
    const f = placedFences[sel.i];
    if (!f) return null;
    const a = v3(f.a.x, f.a.y, f.a.z);
    const b = v3(f.b.x, f.b.y, f.b.z);
    return {
      a,
      b,
      pivot: sel.kind === 'fenceEndpoint'
        ? (sel.end === 'b' ? b : a)
        : mul(add(a, b), 0.5),
    };
  }

  function applyPropTranslate(sel, start, delta) {
    if (!sel || !start) return;
    if (sel.kind === 'tree') {
      const t = placedTrees[sel.i];
      if (!t) return;
      t.pos = add(start.pos, delta);
      return;
    }
    if (sel.kind === 'boulder') {
      const r = placedBoulders[sel.i];
      if (!r) return;
      r.pos = add(start.pos, delta);
      return;
    }
    const f = placedFences[sel.i];
    if (!f) return;
    if (sel.kind === 'fenceEndpoint') {
      if (sel.end === 'b') f.b = add(start.b, delta);
      else f.a = add(start.a, delta);
      return;
    }
    f.a = add(start.a, delta);
    f.b = add(start.b, delta);
  }

  function applyPropRotate(sel, start, axis, angle) {
    if (!sel || !start) return;
    const axisWorld = axisVec(axis === 'free' ? 'y' : axis);
    if (sel.kind === 'tree') {
      const t = placedTrees[sel.i];
      if (!t) return;
      const rot = { ...start.rot };
      rot[axis === 'free' ? 'y' : axis] = Number(rot[axis === 'free' ? 'y' : axis] || 0) + angle;
      t.rot = rot;
      return;
    }
    if (sel.kind === 'boulder') {
      const r = placedBoulders[sel.i];
      if (!r) return;
      const rot = { ...start.rot };
      rot[axis === 'free' ? 'y' : axis] = Number(rot[axis === 'free' ? 'y' : axis] || 0) + angle;
      r.rot = rot;
      return;
    }
    const f = placedFences[sel.i];
    if (!f) return;
    const P = start.pivot;
    const ra = rotateAxis(sub(start.a, P), axisWorld, angle);
    const rb = rotateAxis(sub(start.b, P), axisWorld, angle);
    if (sel.kind === 'fenceEndpoint') {
      if (sel.end === 'b') {
        f.b = start.b;
        f.a = add(P, ra);
      } else {
        f.a = start.a;
        f.b = add(P, rb);
      }
      return;
    }
    f.a = add(P, ra);
    f.b = add(P, rb);
  }

  function applyPropScale(sel, start, factor) {
    if (!sel || !start) return;
    const fSafe = clamp(factor, 0.1, 12);
    if (sel.kind === 'tree') {
      const t = placedTrees[sel.i];
      if (!t) return;
      t.scale = clamp(start.scale * fSafe, 0.12, 18);
      return;
    }
    if (sel.kind === 'boulder') {
      const r = placedBoulders[sel.i];
      if (!r) return;
      r.scale = clamp(start.scale * fSafe, 0.12, 18);
      return;
    }
    const f = placedFences[sel.i];
    if (!f) return;
    const P = start.pivot;
    const va = mul(sub(start.a, P), fSafe);
    const vb = mul(sub(start.b, P), fSafe);
    if (sel.kind === 'fenceEndpoint') {
      if (sel.end === 'b') {
        f.b = start.b;
        f.a = add(P, va);
      } else {
        f.a = start.a;
        f.b = add(P, vb);
      }
      return;
    }
    f.a = add(P, va);
    f.b = add(P, vb);
  }

  function selectOnly(i) {
    clearPropSelection();
    selectedBranch = null;
    selectedBranchSet.clear();
    selected = i;
    selectedSet.clear();
    if (i >= 0) selectedSet.add(i);
  }

  function sanitizeDrawAnchor() {
    if (!Number.isInteger(drawTool.anchorIdx) || drawTool.anchorIdx < 0 || drawTool.anchorIdx >= points.length) {
      drawTool.anchorIdx = -1;
    }
    return drawTool.anchorIdx;
  }

  function setDrawAnchor(i) {
    drawTool.anchorIdx = (Number.isInteger(i) && i >= 0 && i < points.length) ? i : -1;
  }

  function startNewDetachedLine() {
    setTool('draw');
    setDrawAnchor(-1);
    drawTool.pendingNewLine = true;
    if ($('closed')) $('closed').checked = false;
    syncControlToolHint();
  }

  function addDrawPointAt(snappedPos, yFallback = 0) {
    const p = v3(
      Number(snappedPos?.x || 0),
      Number(snappedPos?.y ?? yFallback),
      Number(snappedPos?.z || 0),
    );
    const np = {
      pos: p,
      bank: 0,
      node: 'smooth',
      hin: { x: 0, z: 0 },
      hout: { x: 0, z: 0 },
    };
    const anchor = sanitizeDrawAnchor();
    if (anchor >= 0 && anchor < points.length) {
      const ins = clamp(anchor + 1, 0, points.length);
      points.splice(ins, 0, np);
      remapSplitEndsForSplice(ins, 0, 1);
      smoothNeighborhood([ins - 1, ins, ins + 1]);
      selectOnly(ins);
      setDrawAnchor(ins);
      return ins;
    }
    const oldLast = points.length - 1;
    points.push(np);
    const idx = points.length - 1;
    if (drawTool.pendingNewLine && oldLast >= 0) {
      mainBreaks.add(oldLast);
      sanitizeMainBreaks();
      if ($('closed')) $('closed').checked = false;
    }
    drawTool.pendingNewLine = false;
    smoothNeighborhood([idx - 1, idx]);
    selectOnly(idx);
    setDrawAnchor(idx);
    return idx;
  }

  function branchSelKey(sec, mid) { return `${sec}:${mid}`; }
  function parseBranchSelKey(k) {
    const m = /^(-?\d+):(-?\d+)$/.exec(String(k || ''));
    if (!m) return null;
    return { sec: Number(m[1]), mid: Number(m[2]) };
  }
  function sanitizeBranchSelection() {
    const next = new Set();
    for (const key of selectedBranchSet) {
      const p = parseBranchSelKey(key);
      if (!p) continue;
      if (p.sec < 0 || p.mid < 0) continue;
      if (!branchSections[p.sec]?.mids?.[p.mid]) continue;
      next.add(branchSelKey(p.sec, p.mid));
    }
    selectedBranchSet = next;
    if (selectedBranch) {
      const key = branchSelKey(selectedBranch.sec, selectedBranch.mid);
      if (!selectedBranchSet.has(key)) {
        if (branchSections[selectedBranch.sec]?.mids?.[selectedBranch.mid]) selectedBranchSet.add(key);
        else selectedBranch = null;
      }
    }
  }

  function selectBranchMidpoint(sec, mid) {
    clearPropSelection();
    selected = -1;
    selectedSet.clear();
    selectedBranchSet.clear();
    selectedBranchSet.add(branchSelKey(sec, mid));
    selectedBranch = { sec, mid };
  }

  function toggleBranchSelection(sec, mid) {
    clearPropSelection();
    selected = -1;
    selectedSet.clear();
    const key = branchSelKey(sec, mid);
    if (selectedBranchSet.has(key)) selectedBranchSet.delete(key);
    else selectedBranchSet.add(key);
    if (selectedBranchSet.size) {
      const first = parseBranchSelKey(Array.from(selectedBranchSet).sort()[0]);
      selectedBranch = first ? { sec: first.sec, mid: first.mid } : null;
    } else {
      selectedBranch = null;
    }
  }

  function collectActiveBranchSelection(anchor = null) {
    const out = [];
    sanitizeBranchSelection();
    if (selectedBranchSet.size) {
      for (const k of Array.from(selectedBranchSet).sort()) {
        const p = parseBranchSelKey(k);
        if (!p) continue;
        if (branchSections[p.sec]?.mids?.[p.mid]) out.push({ sec: p.sec, mid: p.mid });
      }
    }
    if (!out.length && anchor && branchSections[anchor.sec]?.mids?.[anchor.mid]) out.push(anchor);
    if (!out.length && selectedBranch && branchSections[selectedBranch.sec]?.mids?.[selectedBranch.mid]) out.push({ sec: selectedBranch.sec, mid: selectedBranch.mid });
    return out;
  }

  function toggleSelection(i) {
    if (i < 0) return;
    clearPropSelection();
    selectedBranch = null;
    selectedBranchSet.clear();
    if (selectedSet.has(i)) selectedSet.delete(i);
    else selectedSet.add(i);
    selected = selectedSet.size ? Array.from(selectedSet).sort((a, b) => a - b)[0] : -1;
  }

  function collectActiveSelection(anchorIndex = -1) {
    const out = selectedSet.size ? Array.from(selectedSet).sort((a, b) => a - b) : [];
    if (!out.length && anchorIndex >= 0) out.push(anchorIndex);
    if (!out.length && selected >= 0) out.push(selected);
    return out;
  }

  function selYRange() {
    const lo = Number($('selY').min);
    const hi = Number($('selY').max);
    return {
      lo: Number.isFinite(lo) ? lo : -20,
      hi: Number.isFinite(hi) ? hi : 40,
    };
  }

  function applyHeightDeltaToMainSelection(delta) {
    const { lo, hi } = selYRange();
    for (const idx of collectActiveSelection()) {
      const p = points[idx];
      if (!p) continue;
      const y0 = clamp(Number(p.pos.y || 0) + delta, lo, hi);
      p.pos.y = clamp(snapRoadY(y0), lo, hi);
    }
  }

  function applyHeightDeltaToBranchSelection(delta) {
    sanitizeBranchSelection();
    const { lo, hi } = selYRange();
    const active = collectActiveBranchSelection();
    for (const a of active) {
      const m = branchSections[a.sec]?.mids?.[a.mid];
      if (!m) continue;
      const y0 = clamp(Number(m.y || 0) + delta, lo, hi);
      m.y = clamp(snapRoadY(y0), lo, hi);
    }
  }

  function handleWorld(i, which) {
    const p = points[i];
    ensurePointShape(p);
    const h = which === 'in' ? p.hin : p.hout;
    return v3(p.pos.x + (h?.x || 0), p.pos.y, p.pos.z + (h?.z || 0));
  }

  function branchMidRef(sel = selectedBranch) {
    if (!sel) return null;
    const sec = branchSections[sel.sec];
    const mid = sec?.mids?.[sel.mid];
    if (!sec || !mid) return null;
    return { sec, mid };
  }

  function branchHandleWorld(sel, which) {
    const ref = branchMidRef(sel);
    if (!ref) return null;
    const m = ref.mid;
    const h = which === 'in' ? m.hin : m.hout;
    return v3(m.x + (h?.x || 0), m.y, m.z + (h?.z || 0));
  }

  function nearestHandle2D(sx, sy, org, s, maxPix) {
    if (selectedBranch) {
      const hiW = branchHandleWorld(selectedBranch, 'in');
      const hoW = branchHandleWorld(selectedBranch, 'out');
      if (hiW && hoW) {
        const hi = screenFromWorld2(hiW, org, s);
        const ho = screenFromWorld2(hoW, org, s);
        const di = Math.hypot(hi.x - sx, hi.y - sy);
        const doo = Math.hypot(ho.x - sx, ho.y - sy);
        if (di <= maxPix) return { kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'in' };
        if (doo <= maxPix) return { kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'out' };
      }
    }
    if (selected < 0) return null;
    const hi = screenFromWorld2(handleWorld(selected, 'in'), org, s);
    const ho = screenFromWorld2(handleWorld(selected, 'out'), org, s);
    const di = Math.hypot(hi.x - sx, hi.y - sy);
    const doo = Math.hypot(ho.x - sx, ho.y - sy);
    if (di <= maxPix) return { kind: 'main', i: selected, which: 'in' };
    if (doo <= maxPix) return { kind: 'main', i: selected, which: 'out' };
    return null;
  }

  function snapXZ(x, z, g) { return { x: Math.round(x / g) * g, z: Math.round(z / g) * g }; }
  function roadSnapCfg() {
    return {
      enabled: chk('roadIsoSnap'),
      xzStep: Math.max(0.01, Math.abs(num('grid')) || 1),
      yStep: clamp(Math.abs(num('roadSnapY')) || 0.5, 0.05, 10),
    };
  }
  function snapRoadXZ(x, z) {
    const cfg = roadSnapCfg();
    if (!cfg.enabled) return { x, z };
    return snapXZ(x, z, cfg.xzStep);
  }
  function snapRoadY(y) {
    const cfg = roadSnapCfg();
    if (!cfg.enabled) return y;
    const step = Math.max(1e-6, cfg.yStep);
    return Math.round(y / step) * step;
  }
  function snapRoadXYZ(x, y, z) {
    const p = snapRoadXZ(x, z);
    return { x: p.x, y: snapRoadY(y), z: p.z };
  }
  function snapRoadXYZWithCfg(x, y, z, cfg = null) {
    const sc = cfg || roadSnapCfg();
    if (!sc?.enabled) return { x, y, z };
    const sx = Math.max(1e-6, Number(sc.xzStep || 1));
    const sy = Math.max(1e-6, Number(sc.yStep || 0.5));
    return {
      x: Math.round(x / sx) * sx,
      y: Math.round(y / sy) * sy,
      z: Math.round(z / sx) * sx,
    };
  }
  function generationSnapCfg() {
    const cfg = roadSnapCfg();
    if (!cfg.enabled) return cfg;
    // Generation uses soft snap so coarse editor grids don't force self-overlap/jank.
    const roadW = Math.max(1, num('roadWidth'));
    const roadT = Math.max(0.08, num('roadThickness'));
    const xzSoftCap = Math.max(0.25, roadW * 0.32);
    const ySoftCap = Math.max(0.05, roadT * 0.9);
    return {
      enabled: true,
      xzStep: Math.min(cfg.xzStep, xzSoftCap),
      yStep: Math.min(cfg.yStep, ySoftCap),
    };
  }
  function shouldSnap3DDrag(e = null) {
    const snapOn = chk('roadIsoSnap');
    if (e?.altKey) return false;
    if (snapOn) return true;
    return !!e?.ctrlKey;
  }
  function dragFineScale(e = null) {
    return e?.shiftKey ? 0.22 : 1;
  }
  function updateSnapStatus() {
    const el = $('snapStatus');
    if (!el) return;
    const cfg = roadSnapCfg();
    if (!cfg.enabled) {
      el.textContent = 'Snap: Off';
      return;
    }
    el.textContent = `Snap: XZ ${cfg.xzStep.toFixed(2)} • Y ${cfg.yStep.toFixed(2)}`;
  }

  function uniqueMainPointCount(epsXZ = 0.08, epsY = 0.04) {
    if (!Array.isArray(points) || !points.length) return 0;
    const unique = [];
    for (const p of points) {
      const pp = p?.pos;
      if (!pp) continue;
      let seen = false;
      for (const q of unique) {
        if (Math.hypot(pp.x - q.x, pp.z - q.z) <= epsXZ && Math.abs(pp.y - q.y) <= epsY) {
          seen = true;
          break;
        }
      }
      if (!seen) unique.push(v3(pp.x, pp.y, pp.z));
    }
    return unique.length;
  }

  function effectiveMainClosed() {
    sanitizeMainBreaks();
    return !!chk('closed') && mainBreaks.size === 0 && uniqueMainPointCount() >= 3;
  }

  function tangentAtIndex(i) {
    if (points.length < 2) return v3(1, 0, 0);
    const ip = mainPrevIndex(i);
    const inx = mainNextIndex(i);
    const prev = ip >= 0 ? points[ip]?.pos : null;
    const next = inx >= 0 ? points[inx]?.pos : null;
    let t;
    if (prev && next) t = sub(next, prev);
    else if (next) t = sub(next, points[i].pos);
    else if (prev) t = sub(points[i].pos, prev);
    else t = v3(1, 0, 0);
    t.y = 0;
    if (len(t) < 1e-6) t = v3(1, 0, 0);
    return norm(t);
  }

  function smoothPointHandles(i) {
    if (i < 0 || i >= points.length) return;
    const p = points[i];
    ensurePointShape(p);
    p.node = 'smooth';
    const pi = mainPrevIndex(i);
    const ni = mainNextIndex(i);
    const prev = pi >= 0 ? points[pi] : null;
    const next = ni >= 0 ? points[ni] : null;
    const inVec = prev ? sub(p.pos, prev.pos) : v3(0, 0, 0);
    const outVec = next ? sub(next.pos, p.pos) : v3(0, 0, 0);

    let t;
    if (prev && next) t = norm(add(norm(inVec), norm(outVec)));
    else if (next) t = norm(outVec);
    else if (prev) t = norm(inVec);
    else t = v3(1, 0, 0);
    if (len(t) < 1e-6) t = v3(1, 0, 0);

    const inLen = prev ? Math.max(0.05, len(inVec) * 0.30) : 0.8;
    const outLen = next ? Math.max(0.05, len(outVec) * 0.30) : 0.8;
    p.hin = { x: -t.x * inLen, z: -t.z * inLen };
    p.hout = { x: t.x * outLen, z: t.z * outLen };
  }

  function smoothNeighborhood(indices) {
    const unique = Array.from(new Set(indices.filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
    for (const i of unique) smoothPointHandles(i);
  }

  function smoothAllPointHandles() {
    for (let i = 0; i < points.length; i++) smoothPointHandles(i);
  }

  function mkCtrlPoint(x, y, z, bank = 0) {
    return { pos: v3(x, y, z), bank, node: 'smooth', hin: { x: 0, z: 0 }, hout: { x: 0, z: 0 } };
  }

  function cloneCtrlPoint(p) {
    ensurePointShape(p);
    return {
      pos: v3(p.pos.x, p.pos.y, p.pos.z),
      bank: Number(p.bank || 0),
      node: p.node || 'smooth',
      hin: { x: Number(p.hin?.x || 0), z: Number(p.hin?.z || 0) },
      hout: { x: Number(p.hout?.x || 0), z: Number(p.hout?.z || 0) },
    };
  }

  function cloneBranchSection(sec) {
    return {
      a: Number(sec?.a || 0),
      b: Number(sec?.b || 0),
      kind: sec?.kind === 'fork' ? 'fork' : 'join',
      bend: Number.isFinite(sec?.bend) ? Number(sec.bend) : 1,
      lift: Number.isFinite(sec?.lift) ? Number(sec.lift) : 0.8,
      roadClass: roadClassKey(sec?.roadClass || 'collector'),
      direction: roadDirKey(sec?.direction || 'two_way'),
      lanesForward: clamp(Math.round(Number(sec?.lanesForward || 1)), 1, 8),
      lanesReverse: clamp(Math.round(Number(sec?.lanesReverse || 0)), 0, 8),
      speedTarget: Number.isFinite(sec?.speedTarget) ? Number(sec.speedTarget) : undefined,
      minRadius: Number.isFinite(sec?.minRadius) ? Number(sec.minRadius) : undefined,
      maxGrade: Number.isFinite(sec?.maxGrade) ? Number(sec.maxGrade) : undefined,
      mids: Array.isArray(sec?.mids) ? sec.mids.map((m) => ({
        u: clamp(Number(m?.u || 0), 0.001, 0.999),
        x: Number(m?.x || 0),
        y: Number(m?.y || 0),
        z: Number(m?.z || 0),
        bevel: clamp(Number.isFinite(m?.bevel) ? Number(m.bevel) : 0.55, 0, 1),
        node: (m?.node === 'aligned' || m?.node === 'corner') ? m.node : 'smooth',
        hin: { x: Number(m?.hin?.x || 0), z: Number(m?.hin?.z || 0) },
        hout: { x: Number(m?.hout?.x || 0), z: Number(m?.hout?.z || 0) },
      })) : [],
    };
  }

  function sanitizeSplitEnds() {
    splitEnds = Array.from(new Set(splitEnds.filter((i) => Number.isInteger(i) && i >= 0 && i < points.length)));
  }

  function sanitizeMainBreaks() {
    const out = new Set();
    for (const i of mainBreaks) {
      if (!Number.isInteger(i)) continue;
      if (i < 0 || i >= points.length - 1) continue;
      out.add(i);
    }
    mainBreaks = out;
  }

  function mainEdgeBroken(i) {
    return mainBreaks.has(i);
  }

  function mainConnectedSegments() {
    const out = [];
    const n = points.length;
    if (n < 2) return out;
    sanitizeMainBreaks();
    for (let i = 0; i < n - 1; i++) {
      if (mainEdgeBroken(i)) continue;
      out.push({ a: i, b: i + 1, insertIndex: i + 1, seg: i });
    }
    if (effectiveMainClosed()) out.push({ a: n - 1, b: 0, insertIndex: 0, seg: n - 1 });
    return out;
  }

  function mainPrevIndex(i) {
    if (!Number.isInteger(i) || i < 0 || i >= points.length) return -1;
    if (effectiveMainClosed()) return (i - 1 + points.length) % points.length;
    const p = i - 1;
    if (p < 0) return -1;
    if (mainEdgeBroken(p)) return -1;
    return p;
  }

  function mainNextIndex(i) {
    if (!Number.isInteger(i) || i < 0 || i >= points.length) return -1;
    if (effectiveMainClosed()) return (i + 1) % points.length;
    if (i >= points.length - 1) return -1;
    if (mainEdgeBroken(i)) return -1;
    return i + 1;
  }

  function mainConnectedComponents() {
    const out = [];
    const n = points.length;
    if (n < 1) return out;
    sanitizeMainBreaks();
    let cur = [0];
    for (let i = 0; i < n - 1; i++) {
      if (mainEdgeBroken(i)) {
        if (cur.length) out.push(cur);
        cur = [i + 1];
      } else {
        cur.push(i + 1);
      }
    }
    if (cur.length) out.push(cur);
    return out;
  }

  function sanitizeBranchSections() {
    const seen = new Set();
    const next = [];
    for (const s of branchSections) {
      const a = Number(s?.a);
      const b = Number(s?.b);
      if (!Number.isInteger(a) || !Number.isInteger(b)) continue;
      if (a < 0 || b < 0 || a >= points.length || b >= points.length || a === b) continue;
      const kind = s?.kind === 'fork' ? 'fork' : 'join';
      const defaults = getNewBranchSpecDefaults(kind);
      const spec = normalizeRoadEdgeSpec(s, defaults.roadClass, defaults.direction);
      const lo = Math.min(a, b), hi = Math.max(a, b);
      const key = `${kind}:${lo}:${hi}`;
      if (seen.has(key)) continue;
      seen.add(key);
      next.push({
        a, b, kind,
        bend: Number.isFinite(s?.bend) ? Number(s.bend) : 1,
        lift: Number.isFinite(s?.lift) ? Number(s.lift) : 0.8,
        roadClass: spec.roadClass,
        direction: spec.direction,
        lanesForward: spec.lanesForward,
        lanesReverse: spec.lanesReverse,
        speedTarget: spec.speedTarget,
        minRadius: spec.minRadius,
        maxGrade: spec.maxGrade,
        mids: Array.isArray(s?.mids)
          ? s.mids
            .map((m) => ({
              u: clamp(Number(m?.u || 0), 0.001, 0.999),
              x: Number(m?.x || 0),
              y: Number(m?.y || 0),
              z: Number(m?.z || 0),
              bevel: clamp(Number.isFinite(m?.bevel) ? Number(m.bevel) : 0.55, 0, 1),
              node: (m?.node === 'aligned' || m?.node === 'corner') ? m.node : 'smooth',
              hin: { x: Number(m?.hin?.x || 0), z: Number(m?.hin?.z || 0) },
              hout: { x: Number(m?.hout?.x || 0), z: Number(m?.hout?.z || 0) },
            }))
            .filter((m) => Number.isFinite(m.x) && Number.isFinite(m.y) && Number.isFinite(m.z) && Number.isFinite(m.hin.x) && Number.isFinite(m.hin.z) && Number.isFinite(m.hout.x) && Number.isFinite(m.hout.z))
            .sort((m1, m2) => m1.u - m2.u)
          : [],
      });
    }
    branchSections = next;
  }

  function remapBranchSectionsForSplice(start, deleteCount, insertCount) {
    const delta = insertCount - deleteCount;
    const cutEnd = start + deleteCount;
    const mapIdx = (idx) => {
      if (!Number.isInteger(idx)) return -1;
      if (idx < start) return idx;
      if (idx >= cutEnd) return idx + delta;
      return -1;
    };
    branchSections = branchSections.map((s) => ({
      ...s,
      a: mapIdx(s.a),
      b: mapIdx(s.b),
    }));
    sanitizeBranchSections();
  }

  function remapSplitEndsForSplice(start, deleteCount, insertCount, insertedRel = []) {
    const next = [];
    const delta = insertCount - deleteCount;
    const cutEnd = start + deleteCount;
    for (const idx of splitEnds) {
      if (!Number.isInteger(idx)) continue;
      if (idx < start) next.push(idx);
      else if (idx >= cutEnd) next.push(idx + delta);
    }
    for (const rel of insertedRel) next.push(start + rel);
    splitEnds = next;
    sanitizeSplitEnds();
    const remappedBreaks = new Set();
    for (const bi of mainBreaks) {
      if (!Number.isInteger(bi)) continue;
      if (bi < start - 1) remappedBreaks.add(bi);
      else if (bi >= cutEnd) remappedBreaks.add(bi + delta);
      else if (deleteCount > 0 && bi === start - 1) remappedBreaks.add(bi);
    }
    mainBreaks = remappedBreaks;
    sanitizeMainBreaks();
    remapBranchSectionsForSplice(start, deleteCount, insertCount);
  }

  function addBranchSection(iA, iB, kind = 'join') {
    if (iA === iB) return false;
    if (!Number.isInteger(iA) || !Number.isInteger(iB)) return false;
    if (iA < 0 || iB < 0 || iA >= points.length || iB >= points.length) return false;
    const A = points[iA]?.pos;
    const B = points[iB]?.pos;
    if (!A || !B) return false;
    const d = Math.hypot(B.x - A.x, B.z - A.z);
    const minSpan = Math.max(0.25, Math.abs(num('grid')) * 0.35, Math.max(1, num('roadWidth')) * 0.10);
    if (!Number.isFinite(d) || d < minSpan) return false;
    const liftBase = Math.max(num('roadThickness') * 1.25, 0.7);
    const spec = getNewBranchSpecDefaults(kind === 'fork' ? 'fork' : 'join');
    const sec = {
      a: iA,
      b: iB,
      kind: kind === 'fork' ? 'fork' : 'join',
      bend: iA < iB ? 1 : -1,
      lift: liftBase + Math.min(2.4, d * 0.035),
      roadClass: spec.roadClass,
      direction: spec.direction,
      lanesForward: spec.lanesForward,
      lanesReverse: spec.lanesReverse,
      speedTarget: spec.speedTarget,
      minRadius: spec.minRadius,
      maxGrade: spec.maxGrade,
      mids: [],
    };
    branchSections.push(sec);
    sanitizeBranchSections();
    if (sec.kind === 'fork') {
      splitEnds.push(iA, iB);
      sanitizeSplitEnds();
    } else {
      splitEnds = splitEnds.filter((idx) => idx !== iA && idx !== iB);
      sanitizeSplitEnds();
    }
    return true;
  }

  function splitPointForFork(i) {
    if (!Number.isInteger(i) || i < 0 || i >= points.length) return false;
    const src = points[i];
    if (!src) return false;
    const dupe = cloneCtrlPoint(src);
    const t = tangentAtIndex(i);
    const n = norm(v3(-t.z, 0, t.x));
    const side = (Math.hypot(n.x, n.z) > 1e-5) ? n : v3(1, 0, 0);
    const sep = clamp(num('roadWidth') * 0.55, 0.35, 2.8);
    src.pos.x += side.x * sep * 0.5;
    src.pos.z += side.z * sep * 0.5;
    dupe.pos.x -= side.x * sep * 0.5;
    dupe.pos.z -= side.z * sep * 0.5;
    const srcSnap = snapRoadXYZ(src.pos.x, src.pos.y, src.pos.z);
    src.pos.x = srcSnap.x; src.pos.y = srcSnap.y; src.pos.z = srcSnap.z;
    const dupSnap = snapRoadXYZ(dupe.pos.x, dupe.pos.y, dupe.pos.z);
    dupe.pos.x = dupSnap.x; dupe.pos.y = dupSnap.y; dupe.pos.z = dupSnap.z;
    points.splice(i + 1, 0, dupe);
    remapSplitEndsForSplice(i + 1, 0, 1);
    splitEnds.push(i, i + 1);
    sanitizeSplitEnds();
    mainBreaks.add(i);
    sanitizeMainBreaks();
    smoothNeighborhood([i - 1, i, i + 1, i + 2]);
    selectOnly(i + 1);
    return true;
  }

  function insertYSplitModule(iA, iB) {
    if (iA === iB || points.length < 2) return;
    let a = iA, b = iB;
    if (a > b) { const t = a; a = b; b = t; }
    const S = points[a].pos, J = points[b].pos;
    const d = sub(J, S);
    const flat = v3(d.x, 0, d.z);
    const L = Math.max(0.01, len(flat));
    const t = norm(flat);
    const n = v3(-t.z, 0, t.x);
    const w = Math.max(num('roadWidth') * 2.6, L * 0.22);
    const ySpan = Math.abs(J.y - S.y);

    const p = (u, v) => {
      const px = S.x + t.x * L * u + n.x * w * v;
      const pz = S.z + t.z * L * u + n.z * w * v;
      const py = S.y * (1 - u) + J.y * u + Math.sin(u * Math.PI) * (0.35 + ySpan * 0.15);
      const sp = snapRoadXYZ(px, py, pz);
      return mkCtrlPoint(sp.x, sp.y, sp.z, 0);
    };

    // Fork profile tuned to read as a clear Y split in top view.
    const modulePts = [
      p(0.12, 0.06),
      p(0.28, 0.82),
      p(0.47, 1.30),
      p(0.71, 0.50),
      p(0.73, -0.50),
      p(0.49, -1.30),
      p(0.31, -0.82),
      p(0.14, -0.06),
    ];
    const start = a + 1;
    const delCount = Math.max(0, b - a - 1);
    points.splice(start, delCount, ...modulePts);
    remapSplitEndsForSplice(start, delCount, modulePts.length, [2, 5]);
    selectOnly(a + Math.ceil(modulePts.length / 2));
  }

  function trimSection(iA, iB) {
    if (!Number.isInteger(iA) || !Number.isInteger(iB)) return false;
    if (iA === iB) return false;
    const n = points.length;
    if (n < 3) return false;
    const closed = effectiveMainClosed();
    if (!closed) {
      let a = iA, b = iB;
      if (a > b) { const t = a; a = b; b = t; }
      if (b - a <= 1) return false;
      const start = a + 1;
      const delCount = b - a - 1;
      points.splice(start, delCount);
      splitEnds = [a, b];
      remapSplitEndsForSplice(start, delCount, 0);
      mainBreaks.add(a);
      sanitizeMainBreaks();
      selectOnly(a);
      return true;
    }

    const a = ((iA % n) + n) % n;
    const b = ((iB % n) + n) % n;
    if (a === b) return false;
    const fwdLen = loopPathLength(a, b, 1, points);
    const revLen = loopPathLength(a, b, -1, points);
    const removeStep = fwdLen <= revLen ? 1 : -1;
    const removeInterior = circularInteriorIndices(a, b, removeStep, n);
    if (!removeInterior.length) return false;
    const removeSet = new Set(removeInterior);
    const nextPoints = [];
    let aNew = -1;
    let bNew = -1;
    for (let i = 0; i < n; i++) {
      if (removeSet.has(i)) continue;
      const outIdx = nextPoints.length;
      if (i === a) aNew = outIdx;
      if (i === b) bNew = outIdx;
      nextPoints.push(cloneCtrlPoint(points[i]));
    }
    if (nextPoints.length < 3) return false;
    points = nextPoints;
    branchSections = [];
    splitEnds = [aNew, bNew].filter((idx) => Number.isInteger(idx) && idx >= 0 && idx < points.length);
    sanitizeSplitEnds();
    mainBreaks = new Set([aNew].filter((idx) => Number.isInteger(idx) && idx >= 0 && idx < points.length - 1));
    sanitizeMainBreaks();
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    smoothNeighborhood([aNew - 1, aNew, aNew + 1, bNew - 1, bNew, bNew + 1]);
    selectOnly(Math.max(0, Math.min(points.length - 1, aNew)));
    return true;
  }

  function circularInteriorIndices(iA, iB, step, n) {
    const out = [];
    let idx = (iA + step + n) % n;
    let guard = 0;
    while (idx !== iB && guard < n + 2) {
      out.push(idx);
      idx = (idx + step + n) % n;
      guard++;
    }
    return out;
  }

  function loopPathLength(iA, iB, step, ctrl) {
    const n = ctrl.length;
    if (n < 2) return 0;
    let total = 0;
    let idx = iA;
    let guard = 0;
    while (idx !== iB && guard < n + 2) {
      const next = (idx + step + n) % n;
      const a = ctrl[idx]?.pos;
      const b = ctrl[next]?.pos;
      if (a && b) total += Math.hypot(b.x - a.x, b.z - a.z);
      idx = next;
      guard++;
    }
    return total;
  }

  function compactLoopPoints(ctrl, epsXZ = 0.08, epsY = 0.04) {
    if (!Array.isArray(ctrl) || ctrl.length < 2) return Array.isArray(ctrl) ? ctrl.slice() : [];
    const out = [];
    for (const p of ctrl) {
      if (!p?.pos) continue;
      if (!out.length) {
        out.push(cloneCtrlPoint(p));
        continue;
      }
      const last = out[out.length - 1];
      const dx = p.pos.x - last.pos.x;
      const dz = p.pos.z - last.pos.z;
      const dy = p.pos.y - last.pos.y;
      if (Math.hypot(dx, dz) <= epsXZ && Math.abs(dy) <= epsY) continue;
      out.push(cloneCtrlPoint(p));
    }
    if (out.length >= 2) {
      const first = out[0];
      const last = out[out.length - 1];
      if (Math.hypot(first.pos.x - last.pos.x, first.pos.z - last.pos.z) <= epsXZ && Math.abs(first.pos.y - last.pos.y) <= epsY) {
        out.pop();
      }
    }
    return out;
  }

  function joinSection(iA, iB) {
    if (!Number.isInteger(iA) || !Number.isInteger(iB)) return false;
    if (iA === iB) return false;
    const n = points.length;
    if (n < 3) return false;
    const a = ((iA % n) + n) % n;
    const b = ((iB % n) + n) % n;
    if (a === b) return false;
    const A = points[a];
    const B = points[b];
    if (!A || !B) return false;

    // Keep a single closed circuit by replacing one arc (shorter geometric side) with a connector.
    const fwdLen = loopPathLength(a, b, 1, points);
    const revLen = loopPathLength(a, b, -1, points);
    const removeStep = fwdLen <= revLen ? 1 : -1;
    const keepStep = removeStep;
    const keepInterior = circularInteriorIndices(b, a, keepStep, n);

    const pA = cloneCtrlPoint(A);
    const pB = cloneCtrlPoint(B);
    const chord = sub(pB.pos, pA.pos);
    const flat = v3(chord.x, 0, chord.z);
    const dist = Math.max(0.01, len(flat));
    const dir = norm(flat);
    const normal = norm(v3(-dir.z, 0, dir.x));
    if (dist < Math.max(0.2, num('grid') * 0.35)) return false;
    const side = removeStep;
    const targetStep = Math.max(2.0, num('roadWidth') * 1.0);
    const midCount = clamp(Math.round(dist / targetStep) - 1, 1, 4);
    const bend = 0;
    const connector = [];
    for (let i = 1; i <= midCount; i++) {
      const t = i / (midCount + 1);
      const lift = Math.sin(Math.PI * t) * bend;
      const px = pA.pos.x + chord.x * t + normal.x * side * lift;
      const py = pA.pos.y * (1 - t) + pB.pos.y * t;
      const pz = pA.pos.z + chord.z * t + normal.z * side * lift;
      const bank = pA.bank * (1 - t) + pB.bank * t;
      const sp = snapRoadXYZ(px, py, pz);
      connector.push(mkCtrlPoint(sp.x, sp.y, sp.z, bank));
    }

    const rebuilt = [
      pA,
      ...connector,
      pB,
      ...keepInterior.map((idx) => cloneCtrlPoint(points[idx])),
    ];
    const cleaned = compactLoopPoints(rebuilt);
    if (cleaned.length < 3) return false;

    points = cleaned;
    $('closed').checked = true;
    branchSections = [];
    splitEnds = [];
    mainBreaks.clear();
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    smoothAllPointHandles();
    const selIdx = Math.min(points.length - 1, connector.length + 1);
    selectOnly(selIdx);
    return true;
  }

  function insertRoundaboutAt(startIdx, center, radius, exitAngle, dir) {
    if (startIdx < 0 || !center || radius < 0.5) return;
    const S = points[startIdx].pos;
    const entry = Math.atan2(S.z - center.z, S.x - center.x);
    let delta = exitAngle - entry;
    if (dir > 0) while (delta <= 0) delta += Math.PI * 2;
    else while (delta >= 0) delta -= Math.PI * 2;
    const minSweep = Math.PI * 1.08;
    const maxSweep = Math.PI * 1.88;
    if (Math.abs(delta) < minSweep) delta += dir * (minSweep - Math.abs(delta));
    if (Math.abs(delta) > maxSweep) delta = dir * maxSweep;

    const segs = clamp(Math.round(Math.abs(delta) / (Math.PI / 11)), 8, 26);
    const pts = [];
    for (let i = 1; i <= segs; i++) {
      const a = entry + delta * (i / segs);
      const sp = snapRoadXYZ(center.x + Math.cos(a) * radius, S.y, center.z + Math.sin(a) * radius);
      pts.push(mkCtrlPoint(sp.x, sp.y, sp.z, 0));
    }
    points.splice(startIdx + 1, 0, ...pts);
    remapSplitEndsForSplice(startIdx + 1, 0, pts.length);
    splitEnds = [];
    mainBreaks.clear();
    selectOnly(startIdx + pts.length);
  }

  function toolHintText(t = mode) {
    if (t === 'draw') return 'Step 1: Add Points. Click a point to set draw start, then click space to place next points. Click another point to join/close. Click New Line to start a disconnected road. Click yellow/blue curve to insert between points.';
    if (t === 'move') return 'Step 2: Move Road. Drag selected points to shape the layout. Hold Shift for fine movement.';
    if (t === 'erase') return 'Cleanup: Delete points or branch mids you do not want.';
    if (t === 'join') return 'Join: click point A then B to convert that segment into a smooth single-loop shortcut.';
    if (t === 'ysplit') return 'Branching: Split Road by clicking a source point/curve, then a target point.';
    if (t === 'roundabout') return 'Branching: Create Roundabout by clicking a point, dragging radius, then clicking exit direction.';
    if (t === 'fenceplace') return 'Scenery: click two terrain points to place a fence segment (repeat to chain).';
    if (t === 'treeplace') return 'Scenery: click terrain in 3D to plant trees.';
    if (t === 'boulderplace') return 'Scenery: click terrain in 3D to place rocks.';
    if (t === 'propedit') return 'Scenery: select a prop and use W/E/R to move, rotate, or scale.';
    return 'Build flow: Generate a base, Add Points, Move Road, then Split/Connect for branching.';
  }

  function syncControlToolHint() {
    const el = $('ctrlToolHint');
    if (!el) return;
    let txtHint = toolHintText(mode);
    if (mode === 'draw' && drawTool.pendingNewLine) txtHint += ' New line armed: next click starts a disconnected segment.';
    el.textContent = txtHint;
  }

  function normalizeSearchText(v) {
    return String(v || '').toLowerCase().replace(/\s+/g, ' ').trim();
  }

  function controlSectionIsAdvanced(name) {
    const n = normalizeSearchText(name);
    if (!n) return true;
    if (n === 'project' || n === 'build setup' || n.includes('generator') || n.includes('terrain') || n.includes('scenery')) return false;
    return true;
  }

  function syncControlModeButtons() {
    $('ctrlModeSimple')?.classList.toggle('active', ctrlUiMode !== 'advanced');
    $('ctrlModeAdvanced')?.classList.toggle('active', ctrlUiMode === 'advanced');
  }

  function applyControlUiFilters() {
    const panel = ctrlCard?.querySelector('.panel');
    if (!panel) return;
    const sections = panel.querySelectorAll('details.uiSection');
    for (const sec of sections) {
      const sum = sec.querySelector('summary');
      const name = sum ? (sum.dataset.rawName || sum.textContent) : '';
      const adv = controlSectionIsAdvanced(name);
      const visible = ctrlUiMode === 'advanced' || !adv;
      sec.classList.toggle('uiHidden', !visible);
    }
    syncControlModeButtons();
  }

  function segmentIntersectionXZDetail(a0, a1, b0, b1, eps = 1e-6) {
    const ax = a1.x - a0.x;
    const az = a1.z - a0.z;
    const bx = b1.x - b0.x;
    const bz = b1.z - b0.z;
    const den = ax * bz - az * bx;
    if (Math.abs(den) <= eps) return null;
    const cx = b0.x - a0.x;
    const cz = b0.z - a0.z;
    const t = (cx * bz - cz * bx) / den;
    const u = (cx * az - cz * ax) / den;
    if (!(t > eps && t < 1 - eps && u > eps && u < 1 - eps)) return null;
    return {
      t,
      u,
      x: a0.x + ax * t,
      z: a0.z + az * t,
    };
  }

  function segmentIntersectXZ(a0, a1, b0, b1, eps = 1e-6) {
    return !!segmentIntersectionXZDetail(a0, a1, b0, b1, eps);
  }

  // Closest points between two XZ line segments.
  function segmentClosestXZDetail(a0, a1, b0, b1, eps = 1e-7) {
    const ux = a1.x - a0.x;
    const uz = a1.z - a0.z;
    const vx = b1.x - b0.x;
    const vz = b1.z - b0.z;
    const wx = a0.x - b0.x;
    const wz = a0.z - b0.z;
    const A = ux * ux + uz * uz;
    const B = ux * vx + uz * vz;
    const C = vx * vx + vz * vz;
    const D = ux * wx + uz * wz;
    const E = vx * wx + vz * wz;
    let den = A * C - B * B;
    let sN = 0;
    let sD = den;
    let tN = 0;
    let tD = den;

    if (den <= eps) {
      // Nearly parallel.
      sN = 0;
      sD = 1;
      tN = E;
      tD = C > eps ? C : 1;
    } else {
      sN = (B * E - C * D);
      tN = (A * E - B * D);
      if (sN < 0) {
        sN = 0;
        tN = E;
        tD = C > eps ? C : 1;
      } else if (sN > sD) {
        sN = sD;
        tN = E + B;
        tD = C > eps ? C : 1;
      }
    }

    if (tN < 0) {
      tN = 0;
      if (-D < 0) sN = 0;
      else if (-D > A) sN = sD;
      else {
        sN = -D;
        sD = A > eps ? A : 1;
      }
    } else if (tN > tD) {
      tN = tD;
      if ((-D + B) < 0) sN = 0;
      else if ((-D + B) > A) sN = sD;
      else {
        sN = -D + B;
        sD = A > eps ? A : 1;
      }
    }

    const s = clamp((Math.abs(sN) <= eps ? 0 : (sN / (Math.abs(sD) <= eps ? 1 : sD))), 0, 1);
    const t = clamp((Math.abs(tN) <= eps ? 0 : (tN / (Math.abs(tD) <= eps ? 1 : tD))), 0, 1);
    const ax = a0.x + ux * s;
    const az = a0.z + uz * s;
    const bx = b0.x + vx * t;
    const bz = b0.z + vz * t;
    return {
      s,
      t,
      ax,
      az,
      bx,
      bz,
      dist: Math.hypot(bx - ax, bz - az),
    };
  }

  function pointToSegmentXZDetail(p, a, b, eps = 1e-7) {
    const vx = b.x - a.x;
    const vz = b.z - a.z;
    const wx = p.x - a.x;
    const wz = p.z - a.z;
    const len2 = vx * vx + vz * vz;
    if (len2 <= eps) {
      return { t: 0, x: a.x, z: a.z, dist: Math.hypot(p.x - a.x, p.z - a.z) };
    }
    const t = clamp((wx * vx + wz * vz) / len2, 0, 1);
    const x = a.x + vx * t;
    const z = a.z + vz * t;
    return { t, x, z, dist: Math.hypot(p.x - x, p.z - z) };
  }

  function segmentDirXZ(seg) {
    const dx = (seg?.b?.x || 0) - (seg?.a?.x || 0);
    const dz = (seg?.b?.z || 0) - (seg?.a?.z || 0);
    const m = Math.hypot(dx, dz);
    if (m <= 1e-7) return v3(1, 0, 0);
    return v3(dx / m, 0, dz / m);
  }

  function segmentsHaveIntentionalMergeTouch(sa, sb, minGap, clearanceY) {
    const touchDist = Math.max(0.12, minGap * 0.26);
    const dirA = segmentDirXZ(sa);
    const dirB = segmentDirXZ(sb);
    const parallel = Math.abs(dot(dirA, dirB)) >= 0.45;
    if (!parallel) return false;

    const ptsA = [sa.a, sa.b];
    const ptsB = [sb.a, sb.b];
    for (const p of ptsA) {
      const hit = pointToSegmentXZDetail(p, sb.a, sb.b);
      if (hit.dist > touchDist) continue;
      const yB = sb.a.y + (sb.b.y - sb.a.y) * hit.t;
      if (Math.abs((p.y || 0) - yB) > clearanceY * 0.55) continue;
      return true;
    }
    for (const p of ptsB) {
      const hit = pointToSegmentXZDetail(p, sa.a, sa.b);
      if (hit.dist > touchDist) continue;
      const yA = sa.a.y + (sa.b.y - sa.a.y) * hit.t;
      if (Math.abs((p.y || 0) - yA) > clearanceY * 0.55) continue;
      return true;
    }
    return false;
  }

  function buildNetworkSegmentsForCrossing(net) {
    const segs = [];
    const addPolyline = (samples, closed, polyKind, polyIndex) => {
      if (!Array.isArray(samples) || samples.length < 2) return;
      const n = samples.length;
      const segCount = closed ? n : (n - 1);
      for (let i = 0; i < segCount; i++) {
        const j = closed ? ((i + 1) % n) : (i + 1);
        const a = samples[i]?.pos;
        const b = samples[j]?.pos;
        if (!a || !b) continue;
        segs.push({
          polyKind,
          polyIndex,
          polyId: `${polyKind}:${polyIndex}`,
          segIndex: i,
          segCount,
          closed: !!closed,
          a,
          b,
        });
      }
    };
    addPolyline(net?.main || [], !!net?.mainClosed, 'main', 0);
    const branches = Array.isArray(net?.branches) ? net.branches : [];
    for (let bi = 0; bi < branches.length; bi++) addPolyline(branches[bi], false, 'branch', bi);
    return segs;
  }

  function segmentsAreAdjacentInPolyline(sa, sb) {
    if (!sa || !sb || sa.polyId !== sb.polyId) return false;
    const d = Math.abs(sa.segIndex - sb.segIndex);
    if (d <= 1) return true;
    if (!sa.closed) return false;
    return (sa.segIndex === 0 && sb.segIndex === sa.segCount - 1) || (sb.segIndex === 0 && sa.segIndex === sb.segCount - 1);
  }

  function gatherNetworkCrossings(net, opts = {}) {
    const clearance = Math.max(0.2, Number(opts.clearance || 0.8));
    const includeStacked = opts.includeStacked !== false;
    const dedupDist = Math.max(0.08, Number(opts.dedupDist || 0.30));
    const maxPairs = clamp(Math.round(Number(opts.maxPairs || 240000)), 10000, 1200000);
    const cellSize = Math.max(0.6, Number(opts.cellSize || Math.max(1.2, num('roadWidth') * 0.85)));
    const invCell = 1 / cellSize;
    const segs = buildNetworkSegmentsForCrossing(net);
    const buckets = new Map();
    const pairSeen = new Set();
    const out = [];
    let pairChecks = 0;
    let truncated = false;

    const pushOrMergeCross = (cross) => {
      let mergeIdx = -1;
      for (let i = 0; i < out.length; i++) {
        const ex = out[i];
        if (Math.hypot(ex.x - cross.x, ex.z - cross.z) <= dedupDist) {
          mergeIdx = i;
          break;
        }
      }
      if (mergeIdx < 0) {
        out.push(cross);
        return;
      }
      const ex = out[mergeIdx];
      const preferNew =
        (cross.type === 'conflict' && ex.type !== 'conflict') ||
        (cross.type === ex.type && cross.dy < ex.dy);
      if (preferNew) out[mergeIdx] = cross;
    };

    for (let si = 0; si < segs.length; si++) {
      const s = segs[si];
      const minX = Math.min(s.a.x, s.b.x);
      const maxX = Math.max(s.a.x, s.b.x);
      const minZ = Math.min(s.a.z, s.b.z);
      const maxZ = Math.max(s.a.z, s.b.z);
      const ix0 = Math.floor(minX * invCell);
      const ix1 = Math.floor(maxX * invCell);
      const iz0 = Math.floor(minZ * invCell);
      const iz1 = Math.floor(maxZ * invCell);
      const localCandidates = new Set();

      for (let iz = iz0; iz <= iz1; iz++) {
        for (let ix = ix0; ix <= ix1; ix++) {
          const key = `${ix}:${iz}`;
          const arr = buckets.get(key);
          if (!arr) continue;
          for (const oi of arr) localCandidates.add(oi);
        }
      }

      for (const oi of localCandidates) {
        if (pairChecks >= maxPairs) { truncated = true; break; }
        const a = oi < si ? oi : si;
        const b = oi < si ? si : oi;
        const pairKey = `${a}:${b}`;
        if (pairSeen.has(pairKey)) continue;
        pairSeen.add(pairKey);
        pairChecks++;
        const o = segs[oi];
        if (!o) continue;
        if (segmentsAreAdjacentInPolyline(s, o)) continue;
        const hit = segmentIntersectionXZDetail(s.a, s.b, o.a, o.b, 1e-6);
        if (!hit) continue;
        const yA = s.a.y + (s.b.y - s.a.y) * hit.t;
        const yB = o.a.y + (o.b.y - o.a.y) * hit.u;
        const dy = Math.abs(yA - yB);
        const type = dy < clearance ? 'conflict' : 'stacked';
        if (!includeStacked && type === 'stacked') continue;
        pushOrMergeCross({
          x: hit.x,
          y: (yA + yB) * 0.5,
          z: hit.z,
          yA,
          yB,
          dy,
          type,
          a: {
            polyKind: s.polyKind,
            polyIndex: s.polyIndex,
            segIndex: s.segIndex,
            t: hit.t,
            p0: s.a,
            p1: s.b,
          },
          b: {
            polyKind: o.polyKind,
            polyIndex: o.polyIndex,
            segIndex: o.segIndex,
            t: hit.u,
            p0: o.a,
            p1: o.b,
          },
        });
      }
      if (truncated) break;

      for (let iz = iz0; iz <= iz1; iz++) {
        for (let ix = ix0; ix <= ix1; ix++) {
          const key = `${ix}:${iz}`;
          let arr = buckets.get(key);
          if (!arr) { arr = []; buckets.set(key, arr); }
          arr.push(si);
        }
      }
    }

    return { crossings: out, pairChecks, truncated };
  }

  function gatherMergeableCrossings(net, opts = {}) {
    const clearance = Math.max(0.2, Number(opts.clearance || Math.max(0.75, num('roadThickness') * 1.9)));
    const scan = gatherNetworkCrossings(net, {
      clearance,
      includeStacked: false,
      dedupDist: Math.max(0.20, Number(opts.dedupDist || Math.max(0.24, num('roadWidth') * 0.16))),
      maxPairs: clamp(Math.round(Number(opts.maxPairs || 260000)), 10000, 1200000),
    });
    const out = [];
    for (const c of (scan.crossings || [])) {
      if (c.type !== 'conflict') continue;
      const a0 = c.a?.p0 || null;
      const a1 = c.a?.p1 || null;
      const b0 = c.b?.p0 || null;
      const b1 = c.b?.p1 || null;
      let ang = Math.PI * 0.5;
      if (a0 && a1 && b0 && b1) {
        const da = norm(v3(a1.x - a0.x, 0, a1.z - a0.z));
        const db = norm(v3(b1.x - b0.x, 0, b1.z - b0.z));
        ang = Math.acos(clamp(Math.abs(dot(da, db)), -1, 1));
      }
      if (ang < (12 * Math.PI / 180)) continue;
      out.push({
        x: c.x,
        y: Math.max(c.yA || c.y || 0, c.yB || c.y || 0) + 0.012,
        z: c.z,
        dy: c.dy || 0,
        a: c.a,
        b: c.b,
      });
    }
    return out;
  }

  // Detect non-intersecting but too-close same-level roads (parallel squeeze / side overlap).
  function gatherNetworkSideClearanceConflicts(net, opts = {}) {
    const minGap = Math.max(0.45, Number(opts.minGap || Math.max(0.9, num('roadWidth') * 0.98)));
    const clearanceY = Math.max(0.2, Number(opts.clearanceY || 0.8));
    const dedupDist = Math.max(0.10, Number(opts.dedupDist || 0.34));
    const maxPairs = clamp(Math.round(Number(opts.maxPairs || 240000)), 10000, 1200000);
    const cellSize = Math.max(0.8, Number(opts.cellSize || Math.max(minGap * 1.35, num('roadWidth') * 0.95)));
    const invCell = 1 / cellSize;
    const endpointTouchEps = Math.max(0.12, minGap * 0.22);
    const mainOnly = !!opts.mainOnly;
    const ignoreSamePolyline = opts.ignoreSamePolyline !== false;
    let segs = buildNetworkSegmentsForCrossing(net);
    if (mainOnly) segs = segs.filter((s) => s?.polyKind === 'main');
    const polyStats = new Map();
    for (const s of segs) {
      const L = Math.hypot((s?.b?.x || 0) - (s?.a?.x || 0), (s?.b?.z || 0) - (s?.a?.z || 0));
      const st = polyStats.get(s.polyId) || { len: 0, count: 0 };
      st.len += L;
      st.count += 1;
      polyStats.set(s.polyId, st);
    }
    const buckets = new Map();
    const pairSeen = new Set();
    const out = [];
    let pairChecks = 0;
    let truncated = false;

    const pushOrMergeConflict = (conflict) => {
      let mergeIdx = -1;
      for (let i = 0; i < out.length; i++) {
        const ex = out[i];
        if (Math.hypot(ex.x - conflict.x, ex.z - conflict.z) <= dedupDist) {
          mergeIdx = i;
          break;
        }
      }
      if (mergeIdx < 0) {
        out.push(conflict);
        return;
      }
      const ex = out[mergeIdx];
      const preferNew = (conflict.gap < ex.gap) || (Math.abs(conflict.gap - ex.gap) < 1e-4 && conflict.dy < ex.dy);
      if (preferNew) out[mergeIdx] = conflict;
    };

    for (let si = 0; si < segs.length; si++) {
      const s = segs[si];
      const minX = Math.min(s.a.x, s.b.x) - minGap;
      const maxX = Math.max(s.a.x, s.b.x) + minGap;
      const minZ = Math.min(s.a.z, s.b.z) - minGap;
      const maxZ = Math.max(s.a.z, s.b.z) + minGap;
      const ix0 = Math.floor(minX * invCell);
      const ix1 = Math.floor(maxX * invCell);
      const iz0 = Math.floor(minZ * invCell);
      const iz1 = Math.floor(maxZ * invCell);
      const localCandidates = new Set();

      for (let iz = iz0; iz <= iz1; iz++) {
        for (let ix = ix0; ix <= ix1; ix++) {
          const key = `${ix}:${iz}`;
          const arr = buckets.get(key);
          if (!arr) continue;
          for (const oi of arr) localCandidates.add(oi);
        }
      }

      for (const oi of localCandidates) {
        if (pairChecks >= maxPairs) { truncated = true; break; }
        const a = oi < si ? oi : si;
        const b = oi < si ? si : oi;
        const pairKey = `${a}:${b}`;
        if (pairSeen.has(pairKey)) continue;
        pairSeen.add(pairKey);
        pairChecks++;
        const o = segs[oi];
        if (!o) continue;
        if (segmentsAreAdjacentInPolyline(s, o)) continue;
        if (s.polyId === o.polyId && ignoreSamePolyline) continue;
        if (s.polyId === o.polyId) {
          const st = polyStats.get(s.polyId);
          const avgSeg = Math.max(0.08, st && st.count > 0 ? (st.len / st.count) : 1);
          const minArcGapWorld = Math.max(minGap * 1.08, avgSeg * 2.4);
          const minIdxGap = Math.max(2, Math.ceil(minArcGapWorld / avgSeg));
          const dIdxRaw = Math.abs(s.segIndex - o.segIndex);
          const dIdx = s.closed ? Math.min(dIdxRaw, Math.max(0, s.segCount - dIdxRaw)) : dIdxRaw;
          if (dIdx <= minIdxGap) continue;
        }
        const sharesEndpoint =
          Math.hypot(s.a.x - o.a.x, s.a.z - o.a.z) <= endpointTouchEps ||
          Math.hypot(s.a.x - o.b.x, s.a.z - o.b.z) <= endpointTouchEps ||
          Math.hypot(s.b.x - o.a.x, s.b.z - o.a.z) <= endpointTouchEps ||
          Math.hypot(s.b.x - o.b.x, s.b.z - o.b.z) <= endpointTouchEps;
        if (sharesEndpoint) continue;
        if (segmentsHaveIntentionalMergeTouch(s, o, minGap, clearanceY)) continue;
        if (segmentIntersectionXZDetail(s.a, s.b, o.a, o.b, 1e-6)) continue;
        const near = segmentClosestXZDetail(s.a, s.b, o.a, o.b, 1e-7);
        if (!near || !Number.isFinite(near.dist) || near.dist >= minGap) continue;
        const yA = s.a.y + (s.b.y - s.a.y) * near.s;
        const yB = o.a.y + (o.b.y - o.a.y) * near.t;
        const dy = Math.abs(yA - yB);
        if (dy >= clearanceY) continue;
        const x = (near.ax + near.bx) * 0.5;
        const z = (near.az + near.bz) * 0.5;
        pushOrMergeConflict({
          x,
          y: (yA + yB) * 0.5,
          z,
          yA,
          yB,
          dy,
          gap: near.dist,
          minGap,
          issueKind: 'side_clearance',
          type: 'conflict',
          a: {
            polyKind: s.polyKind,
            polyIndex: s.polyIndex,
            segIndex: s.segIndex,
            t: near.s,
          },
          b: {
            polyKind: o.polyKind,
            polyIndex: o.polyIndex,
            segIndex: o.segIndex,
            t: near.t,
          },
        });
      }
      if (truncated) break;

      for (let iz = iz0; iz <= iz1; iz++) {
        for (let ix = ix0; ix <= ix1; ix++) {
          const key = `${ix}:${iz}`;
          let arr = buckets.get(key);
          if (!arr) { arr = []; buckets.set(key, arr); }
          arr.push(si);
        }
      }
    }

    return { conflicts: out, pairChecks, truncated, minGap };
  }

  function smoothPolylineY(samples, closed, passes = 2, strength = 0.30) {
    if (!Array.isArray(samples) || samples.length < 3) return;
    const n = samples.length;
    const k = clamp(Number(strength || 0.30), 0.05, 0.75);
    const loop = !!closed && n >= 3;
    for (let pass = 0; pass < passes; pass++) {
      const nextY = new Array(n);
      for (let i = 0; i < n; i++) {
        if (!loop && (i === 0 || i === n - 1)) {
          nextY[i] = samples[i].pos.y;
          continue;
        }
        const ip = loop ? ((i - 1 + n) % n) : Math.max(0, i - 1);
        const inx = loop ? ((i + 1) % n) : Math.min(n - 1, i + 1);
        const avg = (samples[ip].pos.y + samples[inx].pos.y) * 0.5;
        nextY[i] = samples[i].pos.y * (1 - k) + avg * k;
      }
      for (let i = 0; i < n; i++) samples[i].pos.y = nextY[i];
    }
  }

  function applyPolylineLift(samples, closed, segIndex, t, amount, worldRadius = 6) {
    if (!Array.isArray(samples) || samples.length < 2) return 0;
    const n = samples.length;
    const loop = !!closed && n >= 3;
    const liftAmount = Math.max(0, Number(amount || 0));
    if (liftAmount <= 1e-5) return 0;
    let totalLen = 0;
    for (let i = 1; i < n; i++) totalLen += Math.hypot(samples[i].pos.x - samples[i - 1].pos.x, samples[i].pos.z - samples[i - 1].pos.z);
    if (loop && n > 2) totalLen += Math.hypot(samples[0].pos.x - samples[n - 1].pos.x, samples[0].pos.z - samples[n - 1].pos.z);
    const avgSeg = Math.max(0.08, totalLen / Math.max(1, loop ? n : (n - 1)));
    const idxRadius = clamp(Math.round(Math.max(1, worldRadius) / avgSeg), 2, Math.max(2, Math.floor(n * 0.45)));
    const center = Number(segIndex || 0) + clamp(Number(t || 0), 0, 1);
    let bumped = 0;
    for (let off = -idxRadius; off <= idxRadius; off++) {
      const raw = Math.round(center + off);
      const idx = loop ? ((raw % n) + n) % n : raw;
      if (idx < 0 || idx >= n) continue;
      if (!loop && (idx <= 0 || idx >= n - 1)) continue;
      const u = Math.abs(off) / Math.max(1, idxRadius);
      const w = Math.pow(Math.cos(u * Math.PI * 0.5), 2);
      const yLift = liftAmount * w;
      if (yLift <= 1e-4) continue;
      samples[idx].pos.y += yLift;
      bumped++;
    }
    return bumped;
  }

  function pickCrossingLiftTarget(cross) {
    const aBranch = cross?.a?.polyKind === 'branch';
    const bBranch = cross?.b?.polyKind === 'branch';
    if (aBranch !== bBranch) return aBranch ? 'a' : 'b';
    if ((cross?.yA ?? 0) > (cross?.yB ?? 0)) return 'a';
    if ((cross?.yB ?? 0) > (cross?.yA ?? 0)) return 'b';
    const aKey = `${cross?.a?.polyKind || ''}:${cross?.a?.polyIndex || 0}:${cross?.a?.segIndex || 0}`;
    const bKey = `${cross?.b?.polyKind || ''}:${cross?.b?.polyIndex || 0}:${cross?.b?.segIndex || 0}`;
    return aKey >= bKey ? 'a' : 'b';
  }

  function enforceNetworkGradeSeparation(net, opts = {}) {
    if (!net || !Array.isArray(net.main) || !Array.isArray(net.branches)) return { adjustedCrossings: 0, bumpedSamples: 0, pairChecks: 0, truncated: false };
    const clearance = Math.max(0.45, Number(opts.clearance || 0.8));
    const blendStrength = clamp(Number(opts.blendStrength || 0.30), 0.12, 0.65);
    const worldRadius = Math.max(2.2, num('roadWidth') * 2.15);
    const scan = gatherNetworkCrossings(net, {
      clearance,
      includeStacked: false,
      dedupDist: 0.24,
      maxPairs: 260000,
    });
    const conflicts = scan.crossings.filter((c) => c.type === 'conflict');
    if (!conflicts.length) {
      return { adjustedCrossings: 0, bumpedSamples: 0, pairChecks: scan.pairChecks, truncated: scan.truncated };
    }

    const touched = new Map();
    let adjusted = 0;
    let bumpedSamples = 0;
    for (const cross of conflicts) {
      const side = pickCrossingLiftTarget(cross);
      const target = side === 'a' ? cross.a : cross.b;
      const isMain = target.polyKind === 'main';
      const poly = isMain ? net.main : net.branches[target.polyIndex];
      const closed = isMain ? !!net.mainClosed : false;
      if (!Array.isArray(poly) || poly.length < 2) continue;
      const needed = Math.max(0.08, clearance - cross.dy + 0.10);
      const bumped = applyPolylineLift(poly, closed, target.segIndex, target.t, needed, worldRadius);
      if (bumped <= 0) continue;
      adjusted++;
      bumpedSamples += bumped;
      touched.set(`${target.polyKind}:${target.polyIndex}`, { poly, closed });
    }
    for (const hit of touched.values()) smoothPolylineY(hit.poly, hit.closed, 2, blendStrength);
    return { adjustedCrossings: adjusted, bumpedSamples, pairChecks: scan.pairChecks, truncated: scan.truncated };
  }

  function countMainSelfIntersections(samples, closedMain, clearanceY = 0.8) {
    const pts = Array.isArray(samples) ? samples : [];
    const n = pts.length;
    if (n < 4) return { conflict: 0, stacked: 0 };
    const segCount = closedMain ? n : (n - 1);
    if (segCount < 3) return { conflict: 0, stacked: 0 };
    const segs = [];
    for (let i = 0; i < segCount; i++) {
      const j = closedMain ? ((i + 1) % n) : (i + 1);
      const a = pts[i]?.pos;
      const b = pts[j]?.pos;
      if (!a || !b) continue;
      segs.push({ i, j, a, b, segIndex: i, segCount, closed: !!closedMain });
    }
    let conflict = 0;
    let stacked = 0;
    for (let a = 0; a < segs.length; a++) {
      for (let b = a + 1; b < segs.length; b++) {
        const s1 = segs[a];
        const s2 = segs[b];
        if (!s1.a || !s1.b || !s2.a || !s2.b) continue;
        if (segmentsAreAdjacentInPolyline(s1, s2)) continue;
        const hit = segmentIntersectionXZDetail(s1.a, s1.b, s2.a, s2.b, 1e-6);
        if (!hit) continue;
        const yA = s1.a.y + (s1.b.y - s1.a.y) * hit.t;
        const yB = s2.a.y + (s2.b.y - s2.a.y) * hit.u;
        if (Math.abs(yA - yB) < clearanceY) conflict++;
        else stacked++;
      }
    }
    return { conflict, stacked };
  }

  function buildMathConformityReport(net, netDesc) {
    const issues = [];
    const closedWanted = !!chk('closed');
    const closedMain = !!net?.mainClosed;
    const uniquePts = uniqueMainPointCount();
    const hasDetachedMain = mainBreaks && mainBreaks.size > 0;
    if (closedWanted && !closedMain && !hasDetachedMain) issues.push('Closed loop needs at least 3 unique control points');

    const mainSamples = Array.isArray(net?.main) ? net.main : [];
    let minSeg = Infinity;
    let tinySegs = 0;
    for (let i = 1; i < mainSamples.length; i++) {
      const a = mainSamples[i - 1]?.pos;
      const b = mainSamples[i]?.pos;
      if (!a || !b) continue;
      const d = Math.hypot(b.x - a.x, b.z - a.z);
      if (d < minSeg) minSeg = d;
      if (d < Math.max(0.04, num('roadWidth') * 0.02)) tinySegs++;
    }
    if (closedMain && mainSamples.length > 2) {
      const a = mainSamples[mainSamples.length - 1]?.pos;
      const b = mainSamples[0]?.pos;
      if (a && b) {
        const d = Math.hypot(b.x - a.x, b.z - a.z);
        if (d < minSeg) minSeg = d;
        if (d < Math.max(0.04, num('roadWidth') * 0.02)) tinySegs++;
      }
    }
    if (!Number.isFinite(minSeg)) minSeg = 0;
    if (tinySegs > 0) issues.push(`${tinySegs} tiny road segment${tinySegs === 1 ? '' : 's'}`);

    const shortBranches = branchSections.filter((sec) => {
      const A = points[sec.a]?.pos;
      const B = points[sec.b]?.pos;
      if (!A || !B) return false;
      const d = Math.hypot(B.x - A.x, B.z - A.z);
      return d < Math.max(0.25, Math.abs(num('grid')) * 0.35);
    }).length;
    if (shortBranches > 0) issues.push(`${shortBranches} branch link${shortBranches === 1 ? '' : 's'} too short`);

    const overlapClearance = Math.max(0.75, num('roadThickness') * 1.9);
    const selfXScan = countMainSelfIntersections(mainSamples, closedMain, overlapClearance);
    const selfX = Number(selfXScan?.conflict || 0);
    const selfXStacked = Number(selfXScan?.stacked || 0);
    if (selfX > 0) issues.push(`${selfX} main-path self intersection${selfX === 1 ? '' : 's'}`);
    const overlapScan = gatherNetworkCrossings(net, {
      clearance: overlapClearance,
      includeStacked: true,
      dedupDist: 0.26,
      maxPairs: 140000,
    });
    const overlapCrossings = overlapScan.crossings;
    const mergeableCrossings = gatherMergeableCrossings(net, {
      clearance: overlapClearance,
      dedupDist: 0.24,
      maxPairs: 140000,
    });
    const mergeableDedupDist = Math.max(0.18, num('roadWidth') * 0.14);
    const isMergeable = (c) => mergeableCrossings.some((m) => Math.hypot((m.x || 0) - (c.x || 0), (m.z || 0) - (c.z || 0)) <= mergeableDedupDist);
    const overlapCrossingsTagged = overlapCrossings.map((c) => {
      if (c.type === 'conflict' && isMergeable(c)) return { ...c, type: 'mergeable' };
      return c;
    });
    const overlapCrossConflicts = overlapCrossings.filter((o) => o.type === 'conflict' && !isMergeable(o)).length;
    const overlapStacked = overlapCrossings.filter((o) => o.type === 'stacked').length;
    if (overlapCrossConflicts > 0) issues.push(`${overlapCrossConflicts} overlap conflict${overlapCrossConflicts === 1 ? '' : 's'} (same-level crossing)`);
    const sideGapTarget = Math.max(0.85, num('roadWidth') * 0.90);
    const hasBranches = Array.isArray(net?.branches) && net.branches.length > 0;
    const sideGapScan = hasBranches
      ? gatherNetworkSideClearanceConflicts(net, {
        minGap: sideGapTarget,
        clearanceY: overlapClearance,
        dedupDist: Math.max(0.6, sideGapTarget * 0.85),
        maxPairs: 90000,
        mainOnly: false,
        ignoreSamePolyline: true,
      })
      : { conflicts: [], pairChecks: 0, truncated: false };
    const sideGapConflicts = Array.isArray(sideGapScan?.conflicts) ? sideGapScan.conflicts : [];
    if (sideGapConflicts.length > 0) {
      issues.push(`${sideGapConflicts.length} side-clearance conflict${sideGapConflicts.length === 1 ? '' : 's'} (< ${sideGapTarget.toFixed(2)} center gap)`);
    }

    const overlaps = overlapCrossingsTagged.concat(sideGapConflicts);
    const overlapConflicts = overlapCrossConflicts + sideGapConflicts.length;
    if (overlapScan.truncated || sideGapScan.truncated) issues.push('Overlap scan hit safety limit (lower detail to inspect every crossing)');

    const topoIssueCount = Number(netDesc?.summary?.topologyIssueCount || 0);
    if (topoIssueCount > 0) issues.push(`${topoIssueCount} network topology warning${topoIssueCount === 1 ? '' : 's'}`);

    return {
      closedWanted,
      closedMain,
      uniquePts,
      minSeg,
      selfX,
      selfXStacked,
      overlaps,
      overlapConflicts,
      overlapStacked,
      mergeableCrossings: mergeableCrossings.length,
      overlapPairChecks: overlapScan.pairChecks + (sideGapScan.pairChecks || 0),
      overlapTruncated: overlapScan.truncated || !!sideGapScan.truncated,
      sideGapConflicts: sideGapConflicts.length,
      sideGapTarget,
      autoOverpassAdjusted: Number(net?.overpass?.adjustedCrossings || 0),
      topoIssueCount,
      issues,
      ok: issues.length === 0,
    };
  }

  function mathReportKeyFromNetwork(net) {
    const main = Array.isArray(net?.main) ? net.main : [];
    const branches = Array.isArray(net?.branches) ? net.branches : [];
    let sx = 0, sz = 0, sy = 0;
    let bx = 0, bz = 0, by = 0;
    const mainStep = Math.max(1, Math.floor(main.length / 28));
    for (let i = 0; i < main.length; i += mainStep) {
      const p = main[i]?.pos;
      if (!p) continue;
      sx += p.x;
      sy += p.y;
      sz += p.z;
    }
    let branchSamples = 0;
    for (const br of branches) {
      const step = Math.max(1, Math.floor((br?.length || 0) / 10));
      for (let i = 0; i < (br?.length || 0); i += step) {
        const p = br[i]?.pos;
        if (!p) continue;
        bx += p.x;
        by += p.y;
        bz += p.z;
        branchSamples++;
      }
    }
    return [
      main.length,
      branches.length,
      branchSamples,
      sx.toFixed(2),
      sy.toFixed(2),
      sz.toFixed(2),
      bx.toFixed(2),
      by.toFixed(2),
      bz.toFixed(2),
      Number(num('roadWidth')).toFixed(3),
      Number(num('roadThickness')).toFixed(3),
      Number(num('grid')).toFixed(3),
      Number(num('roadSnapY')).toFixed(3),
      chk('closed') ? 1 : 0,
      chk('roadIsoSnap') ? 1 : 0,
      `mb:${Array.from(mainBreaks).sort((a, b) => a - b).join(',')}`,
    ].join('|');
  }

  function getMathConformityReportCached(net, netDesc, force = false) {
    const now = (typeof performance !== 'undefined' && performance?.now) ? performance.now() : Date.now();
    const key = mathReportKeyFromNetwork(net);
    const hasCached = !!latestMathReport;
    const sameKey = key === mathReportCacheKey;
    const age = now - mathReportCacheAt;
    if (!force && hasCached) {
      if (sameKey && age < 180) return latestMathReport;
      if (!sameKey && age < 90) return latestMathReport;
    }
    const report = buildMathConformityReport(net, netDesc);
    latestMathReport = report;
    mathReportCacheKey = key;
    mathReportCacheAt = now;
    return report;
  }

  function getOverlay2DData() {
    if (overlay2DCache.version === sceneVersion && overlay2DCache.net && overlay2DCache.netDesc && overlay2DCache.mathReport) {
      return overlay2DCache;
    }
    const net = sampleRoadNetwork();
    const netDesc = buildRoadNetworkDescriptor(net);
    const mathReport = getMathConformityReportCached(net, netDesc, true);
    overlay2DCache = { version: sceneVersion, net, netDesc, mathReport };
    return overlay2DCache;
  }

  function syncMathConformityUI(report) {
    const el = $('ctrlMathStatus');
    if (!el || !report) return;
    el.classList.toggle('ok', !!report.ok);
    el.classList.toggle('warn', !report.ok);
    if (report.ok) {
      const closedTxt = report.closedMain ? 'closed' : 'open';
      const stackedTxt = report.overlapStacked > 0 ? ` • stacked ${report.overlapStacked}` : '';
      const autoTxt = report.autoOverpassAdjusted > 0 ? ` • auto overpass ${report.autoOverpassAdjusted}` : '';
      const mergeTxt = report.mergeableCrossings > 0 ? ` • mergeable ${report.mergeableCrossings}` : '';
      el.textContent = `Math OK • ${closedTxt} • unique ${report.uniquePts} • min seg ${report.minSeg.toFixed(2)}${stackedTxt}${mergeTxt}${autoTxt}`;
      el.title = 'No conformity issues detected in current topology checks.';
      return;
    }
    el.textContent = `Math Issues (${report.issues.length}) • ${report.issues[0]}`;
    el.title = report.issues.join('\n');
  }

  // ---------- UI / controls ----------
  function setTool(t) {
    mode = t;
    $('toolDraw').classList.toggle('active', t === 'draw');
    $('toolMove').classList.toggle('active', t === 'move');
    $('toolErase').classList.toggle('active', t === 'erase');
    $('toolJoin').classList.toggle('active', t === 'join');
    $('toolYSplit').classList.toggle('active', t === 'ysplit');
    $('toolRound').classList.toggle('active', t === 'roundabout');
    $('toolFencePlace').classList.toggle('active', t === 'fenceplace');
    $('toolTreePlace').classList.toggle('active', t === 'treeplace');
    $('toolBoulderPlace').classList.toggle('active', t === 'boulderplace');
    $('toolPropEdit').classList.toggle('active', t === 'propedit');
    $('ctrlToolDraw')?.classList.toggle('active', t === 'draw');
    $('ctrlToolMove')?.classList.toggle('active', t === 'move');
    $('ctrlToolErase')?.classList.toggle('active', t === 'erase');
    $('ctrlToolSplit')?.classList.toggle('active', t === 'ysplit');
    $('ctrlToolJoin')?.classList.toggle('active', t === 'join');
    $('ctrlToolRound')?.classList.toggle('active', t === 'roundabout');
    $('ctrlToolPropEdit')?.classList.toggle('active', t === 'propedit');
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    drawTool = { anchorIdx: -1, pendingNewLine: false };
    if (t !== 'draw') {
      setDrawAnchor(-1);
      drawTool.pendingNewLine = false;
    }
    dragBranch = null;
    dragBranchGroupOffsets = null;
    if (t !== 'fenceplace') fencePlaceStart = null;
    if (t !== 'propedit') clearPropSelection();
    if (t !== 'propedit' && gizmo.target === 'prop') {
      gizmo.active = false;
      gizmo.target = null;
      gizmo.mode = 'move';
      gizmo.axis = null;
      gizmo.startProp = null;
      gizmo.startSel = null;
      gizmoGhost = null;
    }
    syncControlToolHint();
  }
  $('toolDraw').onclick = () => setTool('draw');
  $('startNewLineBtn').onclick = () => startNewDetachedLine();
  $('toolMove').onclick = () => setTool('move');
  $('toolErase').onclick = () => setTool('erase');
  $('toolJoin').onclick = () => setTool('join');
  $('toolYSplit').onclick = () => setTool('ysplit');
  $('toolRound').onclick = () => setTool('roundabout');
  $('toolFencePlace').onclick = () => setTool('fenceplace');
  $('toolTreePlace').onclick = () => setTool('treeplace');
  $('toolBoulderPlace').onclick = () => setTool('boulderplace');
  $('toolPropEdit').onclick = () => setTool('propedit');
  $('clearPropsBtn').onclick = () => {
    if (!placedTrees.length && !placedFences.length && !placedBoulders.length) return;
    pushUndo();
    placedTrees = [];
    placedFences = [];
    placedBoulders = [];
    fencePlaceStart = null;
    clearPropSelection();
    bumpSceneVersion();
    syncSelectedUI();
  };

  function initControlPanelUI() {
    const panel = ctrlCard?.querySelector('.panel');
    if (!panel || panel.dataset.enhanced === '1') return;
    panel.dataset.enhanced = '1';

    const children = Array.from(panel.children);
    const rootHeading = children.find((n) => n.tagName === 'H2');
    const rootTitle = rootHeading ? rootHeading.textContent.trim() : 'Controls';
    let introText = '';
    if (rootHeading) {
      const next = rootHeading.nextElementSibling;
      if (next && next.classList.contains('small')) {
        introText = next.innerHTML;
        next.remove();
      }
      rootHeading.remove();
    }

    const header = document.createElement('div');
    header.className = 'ctrlDockHeader';
    header.innerHTML = `
      <div class="ctrlDockTop">
        <div class="ctrlDockTitle">${rootTitle}</div>
        <div class="ctrlDockActions">
          <button id="ctrlExpandAllBtn" type="button">Expand</button>
          <button id="ctrlCollapseAllBtn" type="button">Collapse</button>
        </div>
      </div>`;
    panel.prepend(header);

    if (introText) {
      const intro = document.createElement('div');
      intro.className = 'ctrlIntro';
      intro.innerHTML = introText;
      panel.insertBefore(intro, header.nextSibling);
    }

    const sectionsWrap = document.createElement('div');
    sectionsWrap.className = 'ctrlSections';
    panel.appendChild(sectionsWrap);

    const sectionTitleMap = new Map([
      ['Project', 'Build Setup'],
      ['Generator', 'Track Generator'],
      ['Road Network (Stage B)', 'Traffic Rules'],
      ['Terrain', 'Terrain & Cliffs'],
      ['Theme (Yoshi mock)', 'Scenery'],
      ['Selected branch edge (Stage B)', 'Selected Branch'],
      ['Selected point', 'Selected Point'],
      ['Auto bank (optional)', 'Auto Banking'],
    ]);
    const sectionLabel = (name) => sectionTitleMap.get(name) || name;
    const sectionOpen = (name) => /project|generator/i.test(name);
    let currentBody = null;
    const beginSection = (name) => {
      const details = document.createElement('details');
      details.className = 'uiSection';
      details.open = sectionOpen(name);
      details.dataset.level = controlSectionIsAdvanced(name) ? 'advanced' : 'basic';
      const summary = document.createElement('summary');
      summary.dataset.rawName = name;
      summary.textContent = sectionLabel(name);
      currentBody = document.createElement('div');
      currentBody.className = 'uiSectionBody';
      details.appendChild(summary);
      details.appendChild(currentBody);
      sectionsWrap.appendChild(details);
    };

    const movable = Array.from(panel.children).filter((n) => !n.classList?.contains('ctrlDockHeader') && !n.classList?.contains('ctrlIntro') && !n.classList?.contains('ctrlSections'));
    for (const node of movable) {
      if (node.tagName === 'H2') {
        beginSection(node.textContent.trim());
        node.remove();
        continue;
      }
      if (!currentBody) beginSection('Project');
      currentBody.appendChild(node);
    }

    const modeToggle = document.createElement('div');
    modeToggle.className = 'ctrlModeToggle';
    modeToggle.innerHTML = `
      <button id="ctrlModeSimple" type="button" class="active" title="Show only beginner-friendly controls">Basic Controls</button>
      <button id="ctrlModeAdvanced" type="button" title="Show all controls including advanced tuning">Advanced Controls</button>
    `;
    header.appendChild(modeToggle);

    const quickTools = document.createElement('div');
    quickTools.className = 'ctrlQuickTools';
    quickTools.innerHTML = `
      <button id="ctrlToolGenerate" type="button" class="primary">Generate Track</button>
      <button id="ctrlToolDraw" type="button">Add Points</button>
      <button id="ctrlToolMove" type="button">Move Road</button>
      <button id="ctrlToolErase" type="button">Delete</button>
      <button id="ctrlToolSplit" type="button">Split Road</button>
      <button id="ctrlToolJoin" type="button">Connect Roads</button>
      <button id="ctrlToolRound" type="button">Roundabout</button>
      <button id="ctrlToolPropEdit" type="button">Prop Edit</button>
    `;
    header.appendChild(quickTools);

    const toolHint = document.createElement('div');
    toolHint.id = 'ctrlToolHint';
    toolHint.className = 'ctrlToolHint';
    header.appendChild(toolHint);

    const mathStatus = document.createElement('div');
    mathStatus.id = 'ctrlMathStatus';
    mathStatus.className = 'ctrlMathStatus';
    mathStatus.textContent = 'Math checks pending...';
    header.appendChild(mathStatus);

    $('ctrlExpandAllBtn')?.addEventListener('click', () => {
      for (const sec of panel.querySelectorAll('details.uiSection')) sec.open = true;
    });
    $('ctrlCollapseAllBtn')?.addEventListener('click', () => {
      for (const sec of panel.querySelectorAll('details.uiSection')) sec.open = false;
    });
    const toolButtons = [
      ['ctrlToolDraw', 'draw'],
      ['ctrlToolMove', 'move'],
      ['ctrlToolErase', 'erase'],
      ['ctrlToolSplit', 'ysplit'],
      ['ctrlToolJoin', 'join'],
      ['ctrlToolRound', 'roundabout'],
      ['ctrlToolPropEdit', 'propedit'],
    ];
    for (const [id, tool] of toolButtons) {
      $(id)?.addEventListener('click', () => setTool(tool));
    }
    $('ctrlToolGenerate')?.addEventListener('click', () => runGenerateTrack());
    $('ctrlModeSimple')?.addEventListener('click', () => {
      ctrlUiMode = 'simple';
      applyControlUiFilters();
      scheduleAutoSave(250);
    });
    $('ctrlModeAdvanced')?.addEventListener('click', () => {
      ctrlUiMode = 'advanced';
      applyControlUiFilters();
      scheduleAutoSave(250);
    });
    syncControlModeButtons();
    syncControlToolHint();
    applyControlUiFilters();
  }

  function syncCtrlToggleUI() {
    const collapsed = document.body.classList.contains('ctrl-collapsed');
    if (ctrlToggleBtn) {
      ctrlToggleBtn.textContent = collapsed ? '▶' : '◀';
      ctrlToggleBtn.title = collapsed ? 'Show controls' : 'Hide controls';
    }
  }

  function syncHintsUI() {
    const hidden = document.body.classList.contains('hints-hidden');
    if (toggleHintsBtn) {
      toggleHintsBtn.textContent = '?';
      toggleHintsBtn.title = 'Help and tool guide';
    }
    if (helpInlineToggleBtn) helpInlineToggleBtn.textContent = hidden ? 'Show Inline Helpers' : 'Hide Inline Helpers';
  }

  function openHelpModal() {
    helpModal?.classList.remove('hidden');
  }

  function closeHelpModal() {
    helpModal?.classList.add('hidden');
  }

  ctrlToggleBtn?.addEventListener('click', () => {
    document.body.classList.toggle('ctrl-collapsed');
    syncCtrlToggleUI();
    resizeAll();
  });
  toggleHintsBtn?.addEventListener('click', () => openHelpModal());
  helpCloseBtn?.addEventListener('click', closeHelpModal);
  helpCloseBtn2?.addEventListener('click', closeHelpModal);
  helpInlineToggleBtn?.addEventListener('click', () => {
    document.body.classList.toggle('hints-hidden');
    syncHintsUI();
    resizeAll();
  });
  helpModal?.addEventListener('click', (e) => {
    if (e.target === helpModal) closeHelpModal();
  });
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && helpModal && !helpModal.classList.contains('hidden')) closeHelpModal();
  });
  initControlPanelUI();
  setTool(mode);
  syncCtrlToggleUI();
  syncHintsUI();

  const viewModes = ['render', 'normal', 'wireframe'];
  function modeLabel(m) {
    if (m === 'normal') return 'Normal';
    if (m === 'wireframe') return 'Wireframe';
    return 'Render';
  }
  function syncViewModeUI() {
    $('viewModeBtn').textContent = `Mode: ${modeLabel(viewMode)}`;
  }
  $('viewModeBtn').addEventListener('click', () => {
    const i = viewModes.indexOf(viewMode);
    viewMode = viewModes[(i + 1) % viewModes.length];
    syncViewModeUI();
  });
  syncViewModeUI();
  $('propGizmoBtn')?.addEventListener('click', () => cyclePropGizmoMode());
  syncPropGizmoUI();

  function collectControlState() {
    const out = {};
    const nodes = ctrlCard?.querySelectorAll('input, select');
    if (!nodes) return out;
    for (const el of nodes) {
      if (!el.id) continue;
      if (el.type === 'checkbox') out[el.id] = !!el.checked;
      else out[el.id] = String(el.value);
    }
    return out;
  }

  function applyControlState(state) {
    if (!state || typeof state !== 'object') return;
    for (const [id, val] of Object.entries(state)) {
      const el = $(id);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = !!val;
      else el.value = String(val);
    }
    applyControlUiFilters();
  }

  function buildProjectState() {
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      mode,
      viewMode,
      ui: {
        hintsHidden: document.body.classList.contains('hints-hidden'),
        ctrlCollapsed: document.body.classList.contains('ctrl-collapsed'),
        controlMode: ctrlUiMode,
      },
      controls: collectControlState(),
      scene: snapshot(),
    };
  }

  function sanitizeLoadedProject(raw) {
    if (!raw || typeof raw !== 'object') return null;
    if (!raw.scene || typeof raw.scene !== 'object') return null;
    return raw;
  }

  function applyProjectState(raw, opts = {}) {
    const state = sanitizeLoadedProject(raw);
    if (!state) return false;
    const allowModes = new Set(['draw', 'move', 'erase', 'join', 'ysplit', 'roundabout', 'fenceplace', 'treeplace', 'boulderplace', 'propedit']);
    applyControlState(state.controls || {});
    const incomingMode = allowModes.has(state.mode) ? state.mode : 'draw';
    setTool(incomingMode);
    restoreSnap(state.scene);
    if (state.ui && typeof state.ui === 'object') {
      document.body.classList.toggle('hints-hidden', !!state.ui.hintsHidden);
      document.body.classList.toggle('ctrl-collapsed', !!state.ui.ctrlCollapsed);
      if (state.ui.controlMode === 'advanced' || state.ui.controlMode === 'simple') ctrlUiMode = state.ui.controlMode;
    }
    if ((!state.ui || !state.ui.controlMode) && state.controls && typeof state.controls.ctrlUxMode !== 'undefined') {
      ctrlUiMode = String(state.controls.ctrlUxMode) === 'advanced' ? 'advanced' : 'simple';
    }
    if (viewModes.includes(state.viewMode)) viewMode = state.viewMode;
    syncViewModeUI();
    syncCtrlToggleUI();
    syncHintsUI();
    applyControlUiFilters();
    updateLabels();
    syncWorkspaceMode();
    resizeAll();
    bumpSceneVersion();
    frame3D();
    if (!opts.skipPersist) {
      try { localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(state)); } catch {}
    }
    return true;
  }

  function saveProjectToLocal(silent = true) {
    try {
      localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(buildProjectState()));
      return true;
    } catch (e) {
      if (!silent) showErr('Save failed: ' + String(e?.message || e));
      return false;
    }
  }

  function loadProjectFromLocal(silent = true) {
    try {
      const raw = localStorage.getItem(PROJECT_STORAGE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      const ok = applyProjectState(data, { skipPersist: true });
      if (!ok && !silent) showErr('Saved project is invalid.');
      return ok;
    } catch (e) {
      if (!silent) showErr('Load failed: ' + String(e?.message || e));
      return false;
    }
  }

  function scheduleAutoSave(delay = 500) {
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => { saveProjectToLocal(true); }, delay);
  }

  saveBtn?.addEventListener('click', () => {
    const state = buildProjectState();
    try { localStorage.setItem(PROJECT_STORAGE_KEY, JSON.stringify(state)); }
    catch (e) { showErr('Local save failed: ' + String(e?.message || e)); }
    const name = (txt('trackName') || 'track').trim().replace(/[^a-z0-9._-]+/gi, '_') || 'track';
    downloadText(name + '.mktrack.json', JSON.stringify(state, null, 2));
  });

  loadBtn?.addEventListener('click', (e) => {
    if (e.shiftKey) {
      loadProjectFromLocal(false);
      return;
    }
    if (loadProjectFile) {
      loadProjectFile.value = '';
      loadProjectFile.click();
    } else {
      loadProjectFromLocal(false);
    }
  });

  loadProjectFile?.addEventListener('change', async (e) => {
    const f = e.target?.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      const data = JSON.parse(text);
      if (!applyProjectState(data)) showErr('Invalid project file.');
    } catch (err) {
      showErr('Could not load project file: ' + String(err?.message || err));
    } finally {
      if (loadProjectFile) loadProjectFile.value = '';
    }
  });

  function syncWorkspaceMode() {
    const m = txt('workspaceMode');
    if (window.innerWidth < 1200) {
      wrapEl.style.gridTemplateColumns = '';
      editCard.classList.remove('hidden');
      viewCard.classList.remove('hidden');
      ctrlCard.classList.remove('hidden');
      splitter.classList.add('hidden');
      resizeAll();
      return;
    }
    if (m === '2d') {
      wrapEl.style.gridTemplateColumns = 'minmax(0,1fr)';
      editCard.classList.remove('hidden');
      viewCard.classList.add('hidden');
      splitter.classList.add('hidden');
      wrapEl.style.setProperty('--split-l', '2.1fr');
      wrapEl.style.setProperty('--split-r', '0fr');
    } else if (m === '3d') {
      wrapEl.style.gridTemplateColumns = 'minmax(0,1fr)';
      editCard.classList.add('hidden');
      viewCard.classList.remove('hidden');
      splitter.classList.add('hidden');
      wrapEl.style.setProperty('--split-l', '0fr');
      wrapEl.style.setProperty('--split-r', '2.1fr');
    } else {
      wrapEl.style.gridTemplateColumns = 'minmax(0,var(--split-l)) 8px minmax(0,var(--split-r))';
      editCard.classList.remove('hidden');
      viewCard.classList.remove('hidden');
      splitter.classList.remove('hidden');
      if (!wrapEl.style.getPropertyValue('--split-l')) {
        wrapEl.style.setProperty('--split-l', '1.05fr');
        wrapEl.style.setProperty('--split-r', '1.05fr');
      }
    }
    resizeAll();
  }
  $('workspaceMode').addEventListener('change', syncWorkspaceMode);

  function resizeAll() {
    const dpr = window.devicePixelRatio || 1;
    const re = editWrap.getBoundingClientRect();
    edit.width = Math.max(2, Math.floor(re.width * dpr));
    edit.height = Math.max(2, Math.floor(re.height * dpr));
    ectx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const rv = viewWrap.getBoundingClientRect();
    view.width = Math.max(2, Math.floor(rv.width * dpr));
    view.height = Math.max(2, Math.floor(rv.height * dpr));
    vctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { syncWorkspaceMode(); resizeAll(); });
  resizeAll();
  syncWorkspaceMode();

  // 2D/3D splitter drag (desktop only)
  let splitDrag = false, splitStartX = 0, splitL = 1.05, splitR = 1.05;
  splitter.addEventListener('mousedown', (e) => {
    if (window.innerWidth < 1200 || txt('workspaceMode') !== 'both') return;
    splitDrag = true;
    splitStartX = e.clientX;
    splitL = parseFloat((wrapEl.style.getPropertyValue('--split-l') || '1.05').replace('fr', '')) || 1.05;
    splitR = parseFloat((wrapEl.style.getPropertyValue('--split-r') || '1.05').replace('fr', '')) || 1.05;
    document.body.style.cursor = 'col-resize';
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e) => {
    if (!splitDrag) return;
    const dx = e.clientX - splitStartX;
    const total = Math.max(100, editWrap.getBoundingClientRect().width + viewWrap.getBoundingClientRect().width);
    const dfr = (dx / total) * (splitL + splitR);
    const nl = clamp(splitL + dfr, 0.45, 2.4);
    const nr = clamp((splitL + splitR) - nl, 0.45, 2.4);
    wrapEl.style.setProperty('--split-l', nl.toFixed(4) + 'fr');
    wrapEl.style.setProperty('--split-r', nr.toFixed(4) + 'fr');
    resizeAll();
  });
  window.addEventListener('mouseup', () => {
    if (!splitDrag) return;
    splitDrag = false;
    document.body.style.cursor = '';
  });

  function setSelectedNode(type) {
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (!ref) return;
      pushUndo();
      ref.mid.node = type;
      $('selNode').value = type;
      bumpSceneVersion();
      return;
    }
    if (selected < 0) return;
    pushUndo();
    points[selected].node = type;
    $('selNode').value = type;
    bumpSceneVersion();
  }

  function selectedBranchSectionRef() {
    if (!selectedBranch) return null;
    const sec = branchSections[selectedBranch.sec];
    if (!sec) return null;
    return { sec, secIndex: selectedBranch.sec };
  }

  function syncRoadClassDefaultsUI() {
    const main = getMainRoadSpec();
    $('mainRoadClass').value = main.roadClass;
    $('mainRoadDir').value = main.direction;
    $('mainLanesF').value = String(main.lanesForward);
    $('mainLanesR').value = String(main.lanesReverse);
    $('mainLanesR').disabled = main.direction !== 'two_way';
    $('mainRoadSpecVal').textContent = describeRoadSpec(main);

    const branch = getNewBranchSpecDefaults('join');
    $('newBranchClass').value = branch.roadClass;
    $('newBranchDir').value = branch.direction;
    $('newBranchLanesF').value = String(branch.lanesForward);
    $('newBranchLanesR').value = String(branch.lanesReverse);
    $('newBranchLanesR').disabled = branch.direction !== 'two_way';
    $('newBranchSpecVal').textContent = describeRoadSpec(branch);
  }

  function syncSelectedBranchEdgeUI() {
    const classEl = $('selBranchClass');
    const dirEl = $('selBranchDir');
    const fEl = $('selBranchLanesF');
    const rEl = $('selBranchLanesR');
    const valEl = $('selBranchSpecVal');
    const ref = selectedBranchSectionRef();
    if (!ref) {
      classEl.disabled = true;
      dirEl.disabled = true;
      fEl.disabled = true;
      rEl.disabled = true;
      valEl.textContent = 'No branch selected';
      return;
    }
    const defaults = getNewBranchSpecDefaults(ref.sec.kind);
    const spec = normalizeRoadEdgeSpec(ref.sec, defaults.roadClass, defaults.direction);
    classEl.disabled = false;
    dirEl.disabled = false;
    fEl.disabled = false;
    rEl.disabled = spec.direction !== 'two_way';
    classEl.value = spec.roadClass;
    dirEl.value = spec.direction;
    fEl.value = String(spec.lanesForward);
    rEl.value = String(spec.lanesReverse);
    valEl.textContent = `${describeRoadSpec(spec)} • ${ref.sec.kind === 'fork' ? 'Fork' : 'Join'} edge`;
  }

  function applySelectedBranchSpec(presetClass = false) {
    const ref = selectedBranchSectionRef();
    if (!ref) return;
    pushUndo();
    let draft = {
      roadClass: txt('selBranchClass'),
      direction: txt('selBranchDir'),
      lanesForward: num('selBranchLanesF'),
      lanesReverse: num('selBranchLanesR'),
      speedTarget: ref.sec.speedTarget,
      minRadius: ref.sec.minRadius,
      maxGrade: ref.sec.maxGrade,
    };
    if (presetClass) {
      const def = ROAD_CLASS_DEFAULTS[roadClassKey(draft.roadClass)];
      draft = {
        ...draft,
        direction: def.direction,
        lanesForward: def.lanesForward,
        lanesReverse: def.lanesReverse,
        speedTarget: def.speedTarget,
        minRadius: def.minRadius,
        maxGrade: def.maxGrade,
      };
    }
    const spec = normalizeRoadEdgeSpec(draft, draft.roadClass, draft.direction);
    ref.sec.roadClass = spec.roadClass;
    ref.sec.direction = spec.direction;
    ref.sec.lanesForward = spec.lanesForward;
    ref.sec.lanesReverse = spec.lanesReverse;
    ref.sec.speedTarget = spec.speedTarget;
    ref.sec.minRadius = spec.minRadius;
    ref.sec.maxGrade = spec.maxGrade;
    bumpSceneVersion();
    syncSelectedBranchEdgeUI();
  }

  function syncSelectedUI() {
    sanitizeBranchSelection();
    sanitizePropSelection();
    syncControlToolHint();
    const selCount = selectedSet.size + selectedBranchSet.size + selectedPropCount();
    if (selectedProp) {
      if (selectedProp.kind === 'tree') $('selLabel').textContent = `tree.${selectedProp.i}`;
      else if (selectedProp.kind === 'boulder') $('selLabel').textContent = `rock.${selectedProp.i}`;
      else if (selectedProp.kind === 'fenceEndpoint') $('selLabel').textContent = `fence.${selectedProp.i}.${selectedProp.end}`;
      else $('selLabel').textContent = `fence.${selectedProp.i}`;
    } else if (selectedBranch) $('selLabel').textContent = `b${selectedBranch.sec}.${selectedBranch.mid}`;
    else $('selLabel').textContent = selected >= 0 ? String(selected) : 'none';
    $('selCount').textContent = `(${selCount})`;
    syncSelectedBranchEdgeUI();
    if (selectedProp) {
      $('selBankLabel').textContent = 'Bank (deg)';
      $('selBank').min = '-45';
      $('selBank').max = '45';
      $('selBank').step = '0.5';
      $('selNode').value = 'smooth';
      $('selY').value = '0'; $('selBank').value = '0';
      $('selYVal').textContent = '0.0'; $('selBankVal').textContent = '0.0';
      return;
    }
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      const m = ref?.mid;
      if (!m) {
        $('selNode').value = 'smooth';
        $('selY').value = '0'; $('selBank').value = '0';
        $('selYVal').textContent = '0.0'; $('selBankVal').textContent = '0.0';
        return;
      }
      $('selBankLabel').textContent = 'Bevel';
      $('selBank').min = '0';
      $('selBank').max = '1';
      $('selBank').step = '0.01';
      $('selNode').value = m.node || 'smooth';
      $('selY').value = String(m.y);
      $('selBank').value = String(clamp(Number(m.bevel ?? 0.55), 0, 1));
      $('selYVal').textContent = Number(m.y || 0).toFixed(1);
      $('selBankVal').textContent = clamp(Number(m.bevel ?? 0.55), 0, 1).toFixed(2);
      return;
    }
    if (selected < 0 || !points[selected]) {
      $('selBankLabel').textContent = 'Bank (deg)';
      $('selBank').min = '-45';
      $('selBank').max = '45';
      $('selBank').step = '0.5';
      $('selNode').value = 'smooth';
      $('selY').value = '0'; $('selBank').value = '0';
      $('selYVal').textContent = '0.0'; $('selBankVal').textContent = '0.0';
      return;
    }
    ensurePointShape(points[selected]);
    const p = points[selected];
    $('selBankLabel').textContent = 'Bank (deg)';
    $('selBank').min = '-45';
    $('selBank').max = '45';
    $('selBank').step = '0.5';
    $('selNode').value = p.node;
    $('selY').value = String(p.pos.y);
    $('selBank').value = String(p.bank);
    $('selYVal').textContent = p.pos.y.toFixed(1);
    $('selBankVal').textContent = p.bank.toFixed(1);
  }

  $('selNode').addEventListener('change', () => {
    if (selected < 0 && !selectedBranch) return;
    setSelectedNode($('selNode').value);
  });

  $('selY').addEventListener('input', () => {
    if (selectedBranchSet.size || selectedBranch) {
      let ref = branchMidRef(selectedBranch);
      if (!ref) {
        const first = collectActiveBranchSelection()[0];
        const m = first ? branchSections[first.sec]?.mids?.[first.mid] : null;
        if (m) ref = { sec: branchSections[first.sec], mid: m };
      }
      if (!ref || !ref.mid) return;
      pushUndo();
      const nextY = Number($('selY').value);
      const delta = nextY - Number(ref.mid.y || 0);
      applyHeightDeltaToBranchSelection(delta);
      syncSelectedUI();
      bumpSceneVersion();
      return;
    }
    if (selected < 0 && !selectedSet.size) return;
    pushUndo();
    const refIdx = selected >= 0 && selectedSet.has(selected) ? selected : collectActiveSelection()[0];
    const ref = points[refIdx];
    if (!ref) return;
    const nextY = Number($('selY').value);
    const delta = nextY - Number(ref.pos.y || 0);
    applyHeightDeltaToMainSelection(delta);
    syncSelectedUI();
    bumpSceneVersion();
  });
  $('selBank').addEventListener('input', () => {
    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (!ref) return;
      pushUndo();
      ref.mid.bevel = clamp(Number($('selBank').value), 0, 1);
      $('selBankVal').textContent = ref.mid.bevel.toFixed(2);
      bumpSceneVersion();
      return;
    }
    if (selected < 0) return;
    pushUndo();
    points[selected].bank = Number($('selBank').value);
    $('selBankVal').textContent = points[selected].bank.toFixed(1);
    bumpSceneVersion();
  });

  $('selBranchClass').addEventListener('change', () => {
    applySelectedBranchSpec(true);
    updateLabels();
  });
  $('selBranchDir').addEventListener('change', () => {
    applySelectedBranchSpec(false);
    updateLabels();
  });
  $('selBranchLanesF').addEventListener('input', () => {
    applySelectedBranchSpec(false);
    updateLabels();
  });
  $('selBranchLanesR').addEventListener('input', () => {
    applySelectedBranchSpec(false);
    updateLabels();
  });

  $('mainRoadClass').addEventListener('change', () => {
    setClassPresetControls('mainRoadClass', 'mainRoadDir', 'mainLanesF', 'mainLanesR');
    updateLabels();
  });
  $('mainRoadDir').addEventListener('change', updateLabels);
  $('newBranchClass').addEventListener('change', () => {
    setClassPresetControls('newBranchClass', 'newBranchDir', 'newBranchLanesF', 'newBranchLanesR');
    updateLabels();
  });
  $('newBranchDir').addEventListener('change', updateLabels);
  $('supportStyle').addEventListener('change', updateLabels);
  $('bridgeMaterial').addEventListener('change', updateLabels);

  function updateLabels() {
    $('isoScaleVal').textContent = String(num('isoScale'));
    $('roadWidthVal').textContent = num('roadWidth').toFixed(2);
    $('roadThicknessVal').textContent = num('roadThickness').toFixed(2);
    $('subdivVal').textContent = String(num('subdiv'));
    $('pathDetailVal').textContent = num('pathDetail').toFixed(2) + 'x';
    $('genRandomnessVal').textContent = num('genRandomness').toFixed(2);
    $('genScaleVal').textContent = num('genScale').toFixed(2) + 'x';
    $('genLengthVal').textContent = num('genLength').toFixed(2) + 'x';
    $('genCurvesVal').textContent = String(Math.round(num('genCurves')));
    $('genPointCapVal').textContent = String(Math.round(num('genPointCap')));
    $('genComboCountVal').textContent = String(Math.round(num('genComboCount')));
    $('genStraightsVal').textContent = num('genStraights').toFixed(2);
    $('genFlowVal').textContent = num('genFlow').toFixed(2);
    $('genRoundExitsVal').textContent = String(Math.round(num('genRoundExits')));
    $('genCrossFreqVal').textContent = String(Math.round(num('genCrossFreq')));
    $('terrainRoughVal').textContent = num('terrainRough').toFixed(1);
    $('terrainCliffVal').textContent = num('terrainCliff').toFixed(1);
    $('terrainClearanceVal').textContent = num('terrainClearance').toFixed(2);
    $('terrainFollowVal').textContent = num('terrainFollow').toFixed(2);
    $('terrainDetailVal').textContent = num('terrainDetail').toFixed(2);
    $('terrainIslandOffsetVal').textContent = String(Math.round(num('terrainIslandOffset')));
    $('terrainIslandFalloffVal').textContent = String(Math.round(num('terrainIslandFalloff')));
    $('terrainIslandDropVal').textContent = num('terrainIslandDrop').toFixed(1);
    $('themeGrassVal').textContent = num('themeGrass').toFixed(1);
    $('themeCurbVal').textContent = num('themeCurb').toFixed(2);
    $('themeFenceVal').textContent = num('themeFence').toFixed(2);
    $('themeTreesVal').textContent = num('themeTrees').toFixed(2);
    $('themeRocksVal').textContent = num('themeRocks').toFixed(2);
    $('bridgeMaterialVal').textContent = bridgeMaterialLabel(txt('bridgeMaterial'));
    $('autoBankStrengthVal').textContent = num('autoBankStrength').toFixed(2);
    $('autoBankMaxVal').textContent = String(Math.round(num('autoBankMax')));
    $('autoBankScaleVal').textContent = num('autoBankScale').toFixed(2);
    $('roadSnapYVal').textContent = num('roadSnapY').toFixed(2);
    syncRoadClassDefaultsUI();
    syncSelectedBranchEdgeUI();
    updateSnapStatus();
    bumpSceneVersion();
    scheduleAutoSave(450);
  }
  function applyTerrainPreset(kind) {
    if (kind === 'clean') {
      $('terrainRough').value = '1.0';
      $('terrainCliff').value = '3.6';
      $('terrainClearance').value = '0.34';
      $('terrainFollow').value = '0.84';
      $('terrainDetail').value = '0.78';
      $('terrainIsland').checked = true;
      $('terrainIslandOffset').value = '26';
      $('terrainIslandFalloff').value = '20';
      $('terrainIslandDrop').value = '6.2';
    } else if (kind === 'cliffs') {
      $('terrainRough').value = '3.3';
      $('terrainCliff').value = '10.8';
      $('terrainClearance').value = '0.44';
      $('terrainFollow').value = '0.82';
      $('terrainDetail').value = '0.58';
      $('terrainIsland').checked = true;
      $('terrainIslandOffset').value = '38';
      $('terrainIslandFalloff').value = '42';
      $('terrainIslandDrop').value = '13.5';
    } else if (kind === 'bridge') {
      $('terrainRough').value = '1.6';
      $('terrainCliff').value = '6.6';
      $('terrainClearance').value = '0.58';
      $('terrainFollow').value = '0.90';
      $('terrainDetail').value = '0.68';
      $('terrainIsland').checked = true;
      $('terrainIslandOffset').value = '44';
      $('terrainIslandFalloff').value = '30';
      $('terrainIslandDrop').value = '9.8';
      $('supportStyle').value = 'highway';
      $('bridgeMaterial').value = 'freeway';
    }
    updateLabels();
  }
  function applyDefaultGeneratorSetup() {
    const defaults = {
      workspaceMode: 'both',
      grid: 1.0,
      isoScale: 6.0,
      roadIsoSnap: true,
      roadSnapY: 0.25,
      showGrid: true,
      closed: true,
      includeSides: true,
      genStyle: 'diamond',
      genComboCount: 1,
      genRandomness: 0.46,
      genScale: 2.85,
      genLength: 1.95,
      genCurves: 8,
      genPointCap: 38,
      genStraights: 0.82,
      genFlow: 0.88,
      genRoundExits: 3,
      genCrossFreq: 2,
      genModY: false,
      genModRound: false,
      genModCross: false,
      roadWidth: 5.25,
      roadThickness: 0.22,
      mainRoadClass: 'collector',
      mainRoadDir: 'a_to_b',
      mainLanesF: 2,
      mainLanesR: 0,
      newBranchClass: 'ramp',
      newBranchDir: 'a_to_b',
      newBranchLanesF: 1,
      newBranchLanesR: 0,
      subdiv: 22,
      pathDetail: 0.62,
      terrainOn: true,
      terrainRough: 2.8,
      terrainCliff: 8.4,
      terrainClearance: 0.44,
      terrainFollow: 0.90,
      terrainDetail: 0.66,
      terrainIsland: true,
      terrainIslandOffset: 34,
      terrainIslandFalloff: 30,
      terrainIslandDrop: 9.4,
      themeOn: true,
      themeGrass: 0.75,
      themeCurb: 0.08,
      themeFence: 0.55,
      themeTrees: 0.60,
      themeRocks: 0.65,
      supportStyle: 'highway',
      bridgeMaterial: 'auto',
      autoBank: true,
      autoBankStrength: 0.74,
      autoBankMax: 18,
      autoBankScale: 1.65,
    };
    for (const [id, val] of Object.entries(defaults)) {
      const el = $(id);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = Boolean(val);
      else el.value = String(val);
    }
  }
  ['grid','isoScale','roadWidth','roadThickness','subdiv','pathDetail','genRandomness','genScale','genLength','genCurves','genPointCap','genComboCount','genStraights','genFlow','genRoundExits','genCrossFreq','genModY','genModRound','genModCross','terrainOn','terrainRough','terrainCliff','terrainClearance','terrainFollow','terrainDetail','terrainIsland','terrainIslandOffset','terrainIslandFalloff','terrainIslandDrop','themeOn','themeGrass','themeCurb','themeFence','themeTrees','themeRocks','supportStyle','bridgeMaterial','closed','includeSides','showGrid','roadIsoSnap','roadSnapY','autoBank','autoBankStrength','autoBankMax','autoBankScale','mainRoadClass','mainRoadDir','mainLanesF','mainLanesR','newBranchClass','newBranchDir','newBranchLanesF','newBranchLanesR'].forEach(id => $(id).addEventListener('input', updateLabels));
  $('genStyle').addEventListener('change', () => {
    if ($('genStyle').value === 'f1long') {
      if (num('genLength') < 1.8) $('genLength').value = '1.80';
      if (num('genScale') < 1.4) $('genScale').value = '1.40';
      if (num('genStraights') < 0.68) $('genStraights').value = '0.68';
      if (num('genFlow') < 0.72) $('genFlow').value = '0.72';
      if (num('genCurves') < 7) $('genCurves').value = '7';
    } else if (isInterchangeStyle($('genStyle').value)) {
      if (num('genLength') < 1.45) $('genLength').value = '1.45';
      if (num('genScale') < 1.3) $('genScale').value = '1.30';
      if (num('genFlow') < 0.62) $('genFlow').value = '0.62';
      if (num('genCurves') < 8) $('genCurves').value = '8';
      $('genComboCount').value = '1';
    }
    updateLabels();
  });
  $('terrainPresetClean').addEventListener('click', () => applyTerrainPreset('clean'));
  $('terrainPresetCliffs').addEventListener('click', () => applyTerrainPreset('cliffs'));
  $('terrainPresetBridge').addEventListener('click', () => applyTerrainPreset('bridge'));
  $('bridgePresetHighway').addEventListener('click', () => {
    $('supportStyle').value = 'highway';
    $('bridgeMaterial').value = 'freeway';
    updateLabels();
  });
  $('bridgePresetWood').addEventListener('click', () => {
    $('supportStyle').value = 'coaster';
    $('bridgeMaterial').value = 'wood_planks';
    updateLabels();
  });
  $('bridgePresetMixed').addEventListener('click', () => {
    $('supportStyle').value = 'highway';
    $('bridgeMaterial').value = 'city_mix';
    updateLabels();
  });
  applyDefaultGeneratorSetup();
  updateLabels();
  loadProjectFromLocal(true);
  setInterval(() => saveProjectToLocal(true), 12000);
  window.addEventListener('beforeunload', () => { saveProjectToLocal(true); });

  $('resetBtn').onclick = () => {
    pushUndo();
    points = [
      { pos: v3(-6, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(-2, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(4, 0, -4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(7, 0, 0), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(4, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
      { pos: v3(-2, 0, 4), bank: 0, node: 'smooth', hin: { x: -1.2, z: 0 }, hout: { x: 1.2, z: 0 } },
    ];
    smoothAllPointHandles();
    pan2 = { x: 0, y: 0 };
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    splitEnds = [];
    mainBreaks.clear();
    branchSections = [];
    lastGeneratedMeta = null;
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    placedTrees = [];
    placedFences = [];
    placedBoulders = [];
    fencePlaceStart = null;
    clearPropSelection();
    gizmo.active = false;
    gizmo.target = null;
    gizmo.mode = 'move';
    gizmo.axis = null;
    gizmo.startProp = null;
    gizmo.startSel = null;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    bumpSceneVersion();
    frame3D();
  };
  $('clearBtn').onclick = () => {
    pushUndo();
    points = [];
    placedTrees = [];
    placedFences = [];
    placedBoulders = [];
    fencePlaceStart = null;
    clearPropSelection();
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    joinTool = { phase: 0, startIdx: -1 };
    ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
    splitEnds = [];
    mainBreaks.clear();
    branchSections = [];
    lastGeneratedMeta = null;
    roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
    gizmo.active = false;
    gizmo.target = null;
    gizmo.mode = 'move';
    gizmo.axis = null;
    gizmo.startProp = null;
    gizmo.startSel = null;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    bumpSceneVersion();
  };

  function angDelta(a, b) {
    return Math.atan2(Math.sin(a - b), Math.cos(a - b));
  }

  function bridgeProfile(style, t, r, modY = false, modCross = false) {
    const sig = 0.22 + 0.08 * r;
    const g = (c) => {
      const d = angDelta(t, c);
      return Math.exp(-(d * d) / (2 * sig * sig));
    };
    const h = 3.2 + 2.0 * r;
    let y = 0;
    if (modY || style === 'figure8' || style === 'splitS') y += h * (g(0) - g(Math.PI));
    if (style === 'clover') y += (h * 0.55) * (g(Math.PI * 0.5) - g(Math.PI * 1.5));
    if (modCross) y += (h * 0.45) * (g(Math.PI * 0.5) - g(Math.PI * 1.5));
    if (style !== 'figure8') y *= 0.62;
    return y;
  }

  function applyTrackRules(ctrl) {
    const n = ctrl.length;
    if (n < 3) return ctrl;
    const maxBank = 18;
    const maxGrade = 0.11; // dy per horizontal unit

    // clamp + smooth bank so track never tries to roll over
    for (const p of ctrl) p.bank = clamp(p.bank, -maxBank, maxBank);
    for (let pass = 0; pass < 3; pass++) {
      const b = ctrl.map((p, i) => {
        const a = ctrl[(i - 1 + n) % n].bank;
        const c = ctrl[(i + 1) % n].bank;
        return a * 0.2 + p.bank * 0.6 + c * 0.2;
      });
      for (let i = 0; i < n; i++) ctrl[i].bank = clamp(b[i], -maxBank, maxBank);
    }

    // limit grade around the whole loop
    for (let pass = 0; pass < 6; pass++) {
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const a = ctrl[i].pos, b = ctrl[j].pos;
        const d = Math.max(0.01, Math.hypot(b.x - a.x, b.z - a.z));
        const lim = Math.max(0.25, d * maxGrade);
        const dy = b.y - a.y;
        if (dy > lim) b.y = a.y + lim;
        else if (dy < -lim) b.y = a.y - lim;
      }
      for (let i = n - 1; i >= 0; i--) {
        const j = (i - 1 + n) % n;
        const a = ctrl[i].pos, b = ctrl[j].pos;
        const d = Math.max(0.01, Math.hypot(b.x - a.x, b.z - a.z));
        const lim = Math.max(0.25, d * maxGrade);
        const dy = b.y - a.y;
        if (dy > lim) b.y = a.y + lim;
        else if (dy < -lim) b.y = a.y - lim;
      }
    }

    // final Y smoothing for race-course continuity
    for (let pass = 0; pass < 2; pass++) {
      const ys = ctrl.map((p, i) => {
        const yp = ctrl[(i - 1 + n) % n].pos.y;
        const yn = ctrl[(i + 1) % n].pos.y;
        return yp * 0.18 + p.pos.y * 0.64 + yn * 0.18;
      });
      for (let i = 0; i < n; i++) ctrl[i].pos.y = ys[i];
    }
    return ctrl;
  }

  function computeGeneratedBank(ctrl, intensity = 1) {
    const n = ctrl.length;
    if (n < 3) return ctrl;
    const maxBank = 18;
    const turnDeadzoneDeg = 1.2;
    const bankIntoTurnSign = -1; // negative maps bank direction toward inside of turn for this renderer
    for (let i = 0; i < n; i++) {
      const a = ctrl[(i - 1 + n) % n].pos;
      const b = ctrl[i].pos;
      const c = ctrl[(i + 1) % n].pos;
      const turn = signedTurnXZ(a, b, c) * (180 / Math.PI);
      if (Math.abs(turn) < turnDeadzoneDeg) {
        ctrl[i].bank = 0;
        continue;
      }
      // Bank strictly follows turn direction and always leans into the corner.
      ctrl[i].bank = clamp(turn * (1.15 * intensity) * bankIntoTurnSign, -maxBank, maxBank);
    }
    return ctrl;
  }

  function applyBezierHandles(ctrl, smoothness = 1) {
    const n = ctrl.length;
    if (n < 2) return ctrl;
    const s = clamp(smoothness, 0, 1.2);
    for (let i = 0; i < n; i++) {
      const prev = ctrl[(i - 1 + n) % n].pos;
      const curr = ctrl[i].pos;
      const next = ctrl[(i + 1) % n].pos;
      const inVec = sub(curr, prev);
      const outVec = sub(next, curr);
      const inLen = Math.max(0.001, len(inVec));
      const outLen = Math.max(0.001, len(outVec));

      const tangent = norm(add(norm(inVec), norm(outVec)));
      const t = (len(tangent) < 1e-5) ? norm(outVec) : tangent;
      const hIn = inLen * (0.22 + 0.22 * s);
      const hOut = outLen * (0.22 + 0.22 * s);

      ctrl[i].hin = { x: -t.x * hIn, z: -t.z * hIn };
      ctrl[i].hout = { x: t.x * hOut, z: t.z * hOut };
      ctrl[i].node = 'smooth';
    }
    return ctrl;
  }

  function smoothGeneratedLayout(ctrl, passes = 2, xyStrength = 0.34, yStrength = 0.18) {
    const n = ctrl.length;
    if (n < 4) return ctrl;
    for (let pass = 0; pass < passes; pass++) {
      const nx = new Array(n);
      const nz = new Array(n);
      const ny = new Array(n);
      for (let i = 0; i < n; i++) {
        const p = ctrl[(i - 1 + n) % n].pos;
        const c = ctrl[i].pos;
        const q = ctrl[(i + 1) % n].pos;
        const ax = (p.x + q.x) * 0.5;
        const az = (p.z + q.z) * 0.5;
        const ay = (p.y + q.y) * 0.5;
        nx[i] = c.x * (1 - xyStrength) + ax * xyStrength;
        nz[i] = c.z * (1 - xyStrength) + az * xyStrength;
        ny[i] = c.y * (1 - yStrength) + ay * yStrength;
      }
      for (let i = 0; i < n; i++) {
        ctrl[i].pos.x = nx[i];
        ctrl[i].pos.z = nz[i];
        ctrl[i].pos.y = ny[i];
      }
    }
    return ctrl;
  }


  function relaxSelfCollisions(ctrl, opts = {}) {
    const n = ctrl.length;
    if (n < 8) return ctrl;
    const minSep = Math.max(2, opts.minNeighborGap || 3);
    const targetDist = Math.max(2.2, opts.targetDist || 7.8);
    const passes = Math.max(1, Math.min(8, opts.passes || 4));
    for (let pass = 0; pass < passes; pass++) {
      for (let i = 0; i < n; i++) {
        for (let j = i + minSep; j < n; j++) {
          if (Math.abs(i - j) > n - minSep) continue;
          const a = ctrl[i].pos;
          const b = ctrl[j].pos;
          const dx = b.x - a.x;
          const dz = b.z - a.z;
          const d = Math.hypot(dx, dz);
          if (d < 1e-5 || d >= targetDist) continue;
          const push = (targetDist - d) * 0.15;
          const nx = dx / d;
          const nz = dz / d;
          a.x -= nx * push;
          a.z -= nz * push;
          b.x += nx * push;
          b.z += nz * push;
        }
      }
    }
    return ctrl;
  }

  // Width-aware segment separation for generated loops so parallel runs do not collapse together.
  function relaxLoopSegmentClearance(ctrl, opts = {}) {
    const n = ctrl.length;
    if (n < 8) return ctrl;
    const minGap = Math.max(1.2, Number(opts.minGap || Math.max(2.6, num('roadWidth') * 1.08)));
    const yClearance = Math.max(0.35, Number(opts.yClearance || Math.max(0.75, num('roadThickness') * 1.9)));
    const minNeighborGap = Math.max(2, Math.round(Number(opts.minNeighborGap || 3)));
    const passes = Math.max(1, Math.min(8, Math.round(Number(opts.passes || 4))));
    const strength = clamp(Number(opts.strength || 0.22), 0.05, 0.55);

    for (let pass = 0; pass < passes; pass++) {
      let moved = 0;
      for (let i = 0; i < n; i++) {
        const i1 = (i + 1) % n;
        for (let j = i + 1; j < n; j++) {
          const circ = Math.min(Math.abs(i - j), n - Math.abs(i - j));
          if (circ <= minNeighborGap) continue;
          const j1 = (j + 1) % n;
          const A0 = ctrl[i].pos;
          const A1 = ctrl[i1].pos;
          const B0 = ctrl[j].pos;
          const B1 = ctrl[j1].pos;
          const near = segmentClosestXZDetail(A0, A1, B0, B1, 1e-7);
          if (!near || !Number.isFinite(near.dist) || near.dist >= minGap) continue;
          const yA = A0.y + (A1.y - A0.y) * near.s;
          const yB = B0.y + (B1.y - B0.y) * near.t;
          if (Math.abs(yA - yB) >= yClearance) continue;

          let nx = near.bx - near.ax;
          let nz = near.bz - near.az;
          const dm = Math.hypot(nx, nz);
          if (dm > 1e-6) {
            nx /= dm;
            nz /= dm;
          } else {
            const sx = A1.x - A0.x;
            const sz = A1.z - A0.z;
            const sm = Math.hypot(sx, sz);
            if (sm <= 1e-6) continue;
            nx = -sz / sm;
            nz = sx / sm;
          }

          const push = (minGap - near.dist) * strength;
          if (push <= 1e-5) continue;
          const wA0 = 1 - near.s;
          const wA1 = near.s;
          const wB0 = 1 - near.t;
          const wB1 = near.t;

          ctrl[i].pos.x -= nx * push * wA0;
          ctrl[i].pos.z -= nz * push * wA0;
          ctrl[i1].pos.x -= nx * push * wA1;
          ctrl[i1].pos.z -= nz * push * wA1;
          ctrl[j].pos.x += nx * push * wB0;
          ctrl[j].pos.z += nz * push * wB0;
          ctrl[j1].pos.x += nx * push * wB1;
          ctrl[j1].pos.z += nz * push * wB1;
          moved += push;
        }
      }
      if (moved < 1e-4) break;
    }
    return ctrl;
  }

  function enforceCornerStepLimit(ctrl, maxTurnDeg = 33.33, maxPoints = 220, relevanceFloor = 0.16) {
    const maxTurn = clamp(maxTurnDeg, 4, 170) * Math.PI / 180;
    if (!Array.isArray(ctrl) || ctrl.length < 3) return ctrl;
    let guard = 0;
    while (guard++ < 900 && ctrl.length < maxPoints) {
      let changed = false;
      const n = ctrl.length;
      for (let i = 0; i < n && ctrl.length < maxPoints; i++) {
        const pi = (i - 1 + ctrl.length) % ctrl.length;
        const ni = (i + 1) % ctrl.length;
        const P = ctrl[pi].pos;
        const C = ctrl[i].pos;
        const N = ctrl[ni].pos;
        const vin = v3(C.x - P.x, 0, C.z - P.z);
        const vout = v3(N.x - C.x, 0, N.z - C.z);
        const lin = Math.hypot(vin.x, vin.z);
        const lout = Math.hypot(vout.x, vout.z);
        if (lin < 0.7 || lout < 0.7) continue;
        const turn = Math.acos(clamp((vin.x * vout.x + vin.z * vout.z) / (lin * lout), -1, 1));
        if (turn <= maxTurn) continue;

        const t = clamp((turn - maxTurn) / Math.max(1e-6, Math.PI - maxTurn), 0, 1);
        const sizeRel = clamp(Math.min(lin, lout) / Math.max(0.8, num('roadWidth') * 1.85), 0, 1);
        const relevance = t * sizeRel;
        if (relevance < relevanceFloor) continue;
        const cut = 0.22 + 0.34 * t;
        const cutIn = Math.min(lin * cut, lin * 0.46);
        const cutOut = Math.min(lout * cut, lout * 0.46);
        const inDir = v3((P.x - C.x) / lin, 0, (P.z - C.z) / lin);
        const outDir = v3((N.x - C.x) / lout, 0, (N.z - C.z) / lout);
        const A = v3(C.x + inDir.x * cutIn, C.y * 0.72 + P.y * 0.28, C.z + inDir.z * cutIn);
        const B = v3(C.x + outDir.x * cutOut, C.y * 0.72 + N.y * 0.28, C.z + outDir.z * cutOut);

        const ins = cloneCtrlPoint(ctrl[i]);
        ctrl[i].pos = A;
        ins.pos = B;
        ctrl.splice(i + 1, 0, ins);
        changed = true;
        i++;
      }
      if (!changed) break;
    }
    return ctrl;
  }

  function enforceLayoutVariety(ctrl, strength = 1) {
    const n = ctrl.length;
    if (n < 12) return ctrl;
    let absSum = 0;
    const turns = [];
    for (let i = 0; i < n; i++) {
      const a = ctrl[(i - 1 + n) % n].pos;
      const b = ctrl[i].pos;
      const c = ctrl[(i + 1) % n].pos;
      const t = Math.abs(signedTurnXZ(a, b, c));
      turns.push(t);
      absSum += t;
    }
    const mean = absSum / n;
    if (mean < 1e-5) return ctrl;
    let v = 0;
    for (const t of turns) v += (t - mean) * (t - mean);
    const stdev = Math.sqrt(v / n);
    if (stdev / mean > 0.30) return ctrl; // already varied enough

    let cx = 0, cz = 0;
    for (const p of ctrl) { cx += p.pos.x; cz += p.pos.z; }
    cx /= n; cz /= n;
    const c1 = Math.random() * Math.PI * 2;
    const c2 = c1 + Math.PI * (0.55 + Math.random() * 0.5);
    const w1 = 0.26 + Math.random() * 0.35;
    const w2 = 0.24 + Math.random() * 0.34;
    const k1 = (0.10 + Math.random() * 0.18) * strength;
    const k2 = (0.08 + Math.random() * 0.16) * strength;

    for (let i = 0; i < n; i++) {
      const p = ctrl[i].pos;
      const t = (i / n) * Math.PI * 2;
      const d1 = angDelta(t, c1);
      const d2 = angDelta(t, c2);
      const g1 = Math.exp(-(d1 * d1) / (2 * w1 * w1));
      const g2 = Math.exp(-(d2 * d2) / (2 * w2 * w2));
      const dx = p.x - cx;
      const dz = p.z - cz;
      const rr = Math.max(0.001, Math.hypot(dx, dz));
      const nx = dx / rr, nz = dz / rr;
      const scale = 1 + k1 * g1 - k2 * g2;
      p.x = cx + dx * scale + nz * rr * 0.08 * (g1 - g2);
      p.z = cz + dz * scale - nx * rr * 0.08 * (g1 - g2);
    }
    return ctrl;
  }

  function wrapLoopIndex(i, n) {
    if (!Number.isFinite(i) || n <= 0) return 0;
    return ((Math.round(i) % n) + n) % n;
  }

  function loopIndexAt(n, frac) {
    return wrapLoopIndex(frac * n, n);
  }

  function circularIndexDistance(a, b, n) {
    const d = Math.abs(wrapLoopIndex(a, n) - wrapLoopIndex(b, n));
    return Math.min(d, n - d);
  }

  function isInterchangeStyle(style) {
    return style === 'diamond' || style === 'partialClover' || style === 'trumpet' || style === 'stackLite';
  }

  function buildGeneratedBranchSpec(ctrl, iA, iB, kind = 'fork', opts = {}) {
    const n = Array.isArray(ctrl) ? ctrl.length : 0;
    if (n < 2) return null;
    const a = wrapLoopIndex(iA, n);
    const b = wrapLoopIndex(iB, n);
    if (a === b) return null;
    const A = ctrl[a]?.pos;
    const B = ctrl[b]?.pos;
    if (!A || !B) return null;
    const d = Math.hypot(B.x - A.x, B.z - A.z);
    if (d < 1.25) return null;
    const liftBase = Math.max(num('roadThickness') * 1.25, 0.7);
    const defaultClass = roadClassKey(opts.roadClass || (kind === 'fork' ? 'ramp' : 'collector'));
    const defaultDir = roadDirKey(opts.direction || (kind === 'fork' ? 'a_to_b' : 'two_way'));
    const spec = normalizeRoadEdgeSpec({
      roadClass: defaultClass,
      direction: defaultDir,
      lanesForward: Number.isFinite(opts.lanesForward) ? opts.lanesForward : (kind === 'fork' ? 1 : 1),
      lanesReverse: Number.isFinite(opts.lanesReverse) ? opts.lanesReverse : (kind === 'fork' ? 0 : 1),
      speedTarget: Number.isFinite(opts.speedTarget) ? opts.speedTarget : undefined,
      minRadius: Number.isFinite(opts.minRadius) ? opts.minRadius : undefined,
      maxGrade: Number.isFinite(opts.maxGrade) ? opts.maxGrade : undefined,
    }, defaultClass, defaultDir);
    return {
      a,
      b,
      kind: kind === 'fork' ? 'fork' : 'join',
      bend: Number.isFinite(opts.bend) ? Number(opts.bend) : (a < b ? 1 : -1),
      lift: Number.isFinite(opts.lift) ? Number(opts.lift) : (liftBase + Math.min(3.4, d * (kind === 'fork' ? 0.055 : 0.040))),
      roadClass: spec.roadClass,
      direction: spec.direction,
      lanesForward: spec.lanesForward,
      lanesReverse: spec.lanesReverse,
      speedTarget: spec.speedTarget,
      minRadius: spec.minRadius,
      maxGrade: spec.maxGrade,
      mids: [],
    };
  }

  function buildInterchangeBranchPlan(ctrl, style, randomness = 0.5, flow = 0.5) {
    if (!isInterchangeStyle(style) || !Array.isArray(ctrl) || ctrl.length < 14) return [];
    const n = ctrl.length;
    const q0 = loopIndexAt(n, 0.00);
    const q1 = loopIndexAt(n, 0.25);
    const q2 = loopIndexAt(n, 0.50);
    const q3 = loopIndexAt(n, 0.75);
    const off = Math.max(2, Math.round(n * (0.040 + 0.018 * randomness + 0.016 * (1 - flow))));
    const out = [];
    const seen = new Set();
    const add = (a, b, kind = 'fork', opts = {}) => {
      const ia = wrapLoopIndex(a, n);
      const ib = wrapLoopIndex(b, n);
      if (ia === ib) return;
      if (circularIndexDistance(ia, ib, n) < Math.max(2, off - 1)) return;
      const lo = Math.min(ia, ib), hi = Math.max(ia, ib);
      const key = `${kind}:${lo}:${hi}:${opts.roadClass || ''}:${opts.direction || ''}`;
      if (seen.has(key)) return;
      const sec = buildGeneratedBranchSpec(ctrl, ia, ib, kind, opts);
      if (!sec) return;
      seen.add(key);
      out.push(sec);
    };

    if (style === 'diamond') {
      add(q2 + off, q1 - off, 'fork', { bend: 1, lift: 1.10 + 0.24 * randomness, speedTarget: 45, minRadius: 40 });
      add(q2 - off, q3 + off, 'fork', { bend: -1, lift: 1.10 + 0.24 * randomness, speedTarget: 45, minRadius: 40 });
      add(q0 + off, q1 + off, 'fork', { bend: -1, lift: 1.10 + 0.24 * randomness, speedTarget: 45, minRadius: 40 });
      add(q0 - off, q3 - off, 'fork', { bend: 1, lift: 1.10 + 0.24 * randomness, speedTarget: 45, minRadius: 40 });
      add(q1, q3, 'join', { roadClass: 'collector', direction: 'two_way', lanesForward: 1, lanesReverse: 1, lift: 0.72, speedTarget: 35, bend: -1 });
    } else if (style === 'partialClover') {
      const o2 = Math.max(2, Math.round(off * 1.45));
      add(q2 + o2, q1 - off, 'fork', { bend: 1, lift: 1.18 + 0.20 * randomness, speedTarget: 42, minRadius: 34 });
      add(q1 + off, q0 - o2, 'fork', { bend: 1, lift: 1.28 + 0.18 * randomness, speedTarget: 40, minRadius: 32 });
      add(q0 + o2, q3 - off, 'fork', { bend: 1, lift: 1.18 + 0.20 * randomness, speedTarget: 42, minRadius: 34 });
      add(q3 + off, q2 - o2, 'fork', { bend: 1, lift: 1.28 + 0.18 * randomness, speedTarget: 40, minRadius: 32 });
      add(q2 - off, q0 + off, 'fork', { bend: -1, lift: 1.60 + 0.26 * randomness, speedTarget: 48, minRadius: 46, maxGrade: 0.08 });
      add(q0 - off, q2 + off, 'fork', { bend: 1, lift: 1.60 + 0.26 * randomness, speedTarget: 48, minRadius: 46, maxGrade: 0.08 });
    } else if (style === 'trumpet') {
      const hub = q0;
      add(q2 + off, hub - off, 'fork', { bend: 1, lift: 1.20 + 0.24 * randomness, speedTarget: 44, minRadius: 36 });
      add(hub + off, q1 + off, 'fork', { bend: -1, lift: 1.06 + 0.18 * randomness, speedTarget: 40, minRadius: 34 });
      add(hub - off, q3 - off, 'fork', { bend: 1, lift: 1.06 + 0.18 * randomness, speedTarget: 40, minRadius: 34 });
      add(q3 + off * 2, q1 - off * 2, 'fork', { bend: 1, lift: 1.72 + 0.32 * randomness, speedTarget: 46, minRadius: 40, maxGrade: 0.08 });
      add(q1, q3, 'join', { roadClass: 'collector', direction: 'two_way', lanesForward: 1, lanesReverse: 1, lift: 0.68, speedTarget: 32, bend: -1 });
    } else if (style === 'stackLite') {
      const hi = 1.72 + 0.36 * (1 - flow) + 0.25 * randomness;
      add(q2 + off, q1 - off, 'fork', { bend: 1, lift: hi + 0.26, speedTarget: 52, minRadius: 52, maxGrade: 0.07 });
      add(q0 - off, q3 + off, 'fork', { bend: -1, lift: hi + 0.26, speedTarget: 52, minRadius: 52, maxGrade: 0.07 });
      add(q2 - off, q3 + off, 'fork', { bend: -1, lift: 1.16 + 0.16 * randomness, speedTarget: 44, minRadius: 40 });
      add(q0 + off, q1 - off, 'fork', { bend: 1, lift: 1.16 + 0.16 * randomness, speedTarget: 44, minRadius: 40 });
      add(q1 + off, q0 - off, 'fork', { bend: -1, lift: 0.98 + 0.12 * randomness, speedTarget: 40, minRadius: 34 });
      add(q3 - off, q2 + off, 'fork', { bend: 1, lift: 0.98 + 0.12 * randomness, speedTarget: 40, minRadius: 34 });
      add(q1, q3, 'join', { roadClass: 'arterial', direction: 'two_way', lanesForward: 1, lanesReverse: 1, lift: 0.76, speedTarget: 42, minRadius: 45 });
      add(q0, q2, 'join', { roadClass: 'arterial', direction: 'two_way', lanesForward: 1, lanesReverse: 1, lift: 0.76, speedTarget: 42, minRadius: 45, bend: 1 });
    }
    return out;
  }

  function generateOverlapPoints() {
    const out = [];
    const stylePool = ['f1long', 'diamond', 'partialClover', 'trumpet', 'stackLite', 'f1long', 'diamond', 'partialClover', 'splitS', 'mountainSpiral', 'clover'];
    const pick = txt('genStyle');
    const style = pick === 'random'
      ? stylePool[Math.floor(Math.random() * stylePool.length)]
      : pick;
    const comboCount = isInterchangeStyle(style) ? 1 : clamp(Math.round(num('genComboCount')), 1, 3);
    const modY = chk('genModY');
    const modRound = chk('genModRound');
    const modCross = chk('genModCross');
    const r = clamp(num('genRandomness'), 0, 1);
    const sizeMul = clamp(num('genScale'), 0.6, 3.8);
    const lenMul = clamp(num('genLength'), 0.7, 3.5);
    const bends = clamp(Math.round(num('genCurves')), 2, 16);
    const pointCap = clamp(Math.round(num('genPointCap')), 16, 120);
    const straightBias = clamp(num('genStraights'), 0, 1);
    const flow = clamp(num('genFlow'), 0, 1);
    const roundExits = clamp(Math.round(num('genRoundExits')), 2, 4);
    const crossFreq = clamp(Math.round(num('genCrossFreq')), 1, 4);
    const comboStyles = (() => {
      const out = [style];
      if (comboCount <= 1) return out;
      const pool = stylePool.filter((s) => s !== style);
      while (out.length < comboCount && pool.length) {
        const k = Math.floor(Math.random() * pool.length);
        out.push(pool.splice(k, 1)[0]);
      }
      return out;
    })();
    const baseN = Math.max(14, (bends * 3.2) + 6 + Math.floor(4 * r));
    let n = Math.round(baseN * (0.86 + 0.64 * lenMul));
    const hasF1 = comboStyles.includes('f1long');
    if (hasF1) {
      n = Math.max(n, Math.round((34 + bends * 7 + Math.floor(10 * r)) * (1.0 + 0.45 * lenMul)));
    }
    n = clamp(n, 20, pointCap);
    let radius = (10 + r * 7 + Math.random() * (1.8 * r)) * sizeMul * (0.88 + 0.50 * lenMul);
    if (hasF1) radius *= (1.25 + 0.55 * straightBias);
    const twist = (Math.random() * 2 - 1) * (0.05 + 0.35 * r) * (hasF1 ? 0.55 : 1);
    const rot = Math.random() * Math.PI * 2;
    const c = Math.cos(rot), s = Math.sin(rot);
    const yAmp = (hasF1 ? (0.02 + Math.random() * 0.26) : (0.05 + Math.random() * 0.75)) * r * (0.85 + 0.35 * lenMul);
    const yFreq = 1 + Math.floor(Math.random() * 2);
    const bankAmp = hasF1 ? (2.4 + 6.2 * r) : (4 + 10 * r);
    const f1Variant = Math.floor(Math.random() * 4); // 0 superellipse, 1 dogbone, 2 tri-lobe, 3 chicane
    const asymSkewX = (Math.random() * 2 - 1) * (0.06 + 0.18 * r);
    const asymSkewZ = (Math.random() * 2 - 1) * (0.05 + 0.16 * r);
    const asymWarpA = (Math.random() * 2 - 1) * (0.05 + 0.11 * r);
    const asymWarpB = (Math.random() * 2 - 1) * (0.04 + 0.10 * r);
    const featureCount = hasF1 ? 2 + Math.floor(Math.random() * 2) : 1 + (Math.random() < 0.35 ? 1 : 0);
    const features = [];
    for (let fi = 0; fi < featureCount; fi++) {
      features.push({
        c: Math.random() * Math.PI * 2,
        w: 0.28 + Math.random() * 0.46,
        amp: (0.08 + Math.random() * 0.16) * (hasF1 ? (0.6 + 0.55 * (1 - flow)) : 0.42),
      });
    }

    const comboPhases = comboStyles.map((_, i) => ((i / comboStyles.length) * Math.PI * 2) + (Math.random() * 2 - 1) * 0.55);
    const comboOffsets = comboStyles.map((_, i) => {
      if (comboStyles.length <= 1) return { x: 0, z: 0 };
      const a = (i / comboStyles.length) * Math.PI * 2 + (Math.random() * 2 - 1) * 0.35;
      const m = 0.12 + 0.07 * Math.random();
      return { x: Math.cos(a) * m, z: Math.sin(a) * m };
    });

    function stylePoint(st, t) {
      let x, z;
      if (st === 'figure8') {
        x = Math.sin(t) * radius;
        z = Math.sin(2 * t) * radius * 0.66;
      } else if (st === 'clover') {
        const rr = radius * (1 + 0.11 * Math.cos((2 + Math.floor(bends * 0.5)) * t));
        x = Math.cos(t) * rr;
        z = Math.sin(t) * rr * 0.92;
      } else if (st === 'serpentine') {
        const k = clamp(2 + Math.floor(bends * 0.5), 2, 6);
        x = Math.sin(t) * radius * (1.15 + 0.10 * (1 - flow));
        z = (Math.sin(k * t) * 0.34 + Math.sin((k - 1) * t + 0.35) * 0.18) * radius * (0.98 + 0.16 * r);
      } else if (st === 'mountainSpiral') {
        const theta = t + 0.92 * Math.sin(t + 0.20) + 0.34 * Math.sin(2 * t - 0.35);
        const rBase = radius * (0.68 + 0.22 * Math.cos(t - 0.45) + 0.15 * Math.cos(2 * t + 0.95) + 0.10 * Math.sin(3 * t - 0.60));
        x = Math.cos(theta) * rBase * (1.08 + 0.10 * (1 - flow));
        z = Math.sin(theta) * rBase * 0.96;
        x += Math.sin(4 * t + 0.65) * radius * (0.09 + 0.08 * r);
        z += Math.sin(6 * t - 0.40) * radius * (0.06 + 0.07 * r);
      } else if (st === 'splitS') {
        x = Math.sin(t) * radius * 0.98;
        z = (Math.sin(2 * t) * 0.42 + Math.sin((2 + Math.floor(bends / 3)) * t) * 0.13) * radius;
      } else if (st === 'f1long') {
        const ct = Math.cos(t), stt = Math.sin(t);
        const longAxis = 1.30 + 1.00 * straightBias + 0.30 * (lenMul - 1);
        const shortAxis = 0.56 + 0.28 * (1 - straightBias) + 0.16 * r;
        if (f1Variant === 0) {
          const p = 1.9 + straightBias * 3.0 + 0.6 * r;
          const ex = 2 / p;
          const sx = Math.sign(ct) * Math.pow(Math.abs(ct), ex);
          const sz = Math.sign(stt) * Math.pow(Math.abs(stt), ex);
          x = sx * radius * longAxis;
          z = sz * radius * shortAxis;
        } else if (f1Variant === 1) {
          const pinch = 0.70 + 0.22 * Math.cos(2 * t + 0.35);
          const bulge = 1 + 0.22 * Math.cos(t - 0.45) * Math.cos(t - 0.45);
          x = ct * radius * longAxis * bulge;
          z = stt * radius * shortAxis * pinch;
        } else if (f1Variant === 2) {
          const l1 = 1 + 0.24 * Math.sin(3 * t + 0.4) + 0.10 * Math.sin(2 * t - 0.25);
          x = ct * radius * longAxis * (0.92 + 0.22 * Math.max(0, Math.cos(t - 0.2)));
          z = stt * radius * shortAxis * l1;
        } else {
          const p = 2.2 + straightBias * 2.4;
          const ex = 2 / p;
          const sx = Math.sign(ct) * Math.pow(Math.abs(ct), ex);
          const sz = Math.sign(stt) * Math.pow(Math.abs(stt), ex);
          x = sx * radius * longAxis;
          z = sz * radius * shortAxis;
          x += Math.sin(3 * t + 0.9) * radius * (0.10 + 0.12 * r);
          z += Math.sin(5 * t - 0.3) * radius * (0.06 + 0.10 * r);
        }
        const hk = 2 + Math.floor(bends * 0.38);
        const vk = 3 + Math.floor(bends * 0.50);
        x += Math.sin(hk * t + twist * 0.6) * radius * (0.04 + 0.07 * r * (1 - straightBias));
        z += Math.sin(vk * t - twist * 0.4) * radius * (0.06 + 0.10 * r);
        x += radius * (asymWarpA * Math.sin(t + 0.35) + asymWarpB * Math.sin(2 * t - 0.65));
        z += radius * (asymWarpB * Math.sin(t - 0.9) - asymWarpA * 0.65 * Math.cos(2 * t + 0.22));
        let localScale = 1;
        for (const f of features) {
          const d = angDelta(t, f.c);
          localScale += f.amp * Math.exp(-(d * d) / (2 * f.w * f.w));
        }
        x *= localScale;
        z *= localScale;
      } else if (st === 'diamond') {
        const ct = Math.cos(t), stt = Math.sin(t);
        const p = 4.2 + 2.2 * straightBias + 0.6 * r;
        const ex = 2 / p;
        const sx = Math.sign(ct) * Math.pow(Math.abs(ct), ex);
        const sz = Math.sign(stt) * Math.pow(Math.abs(stt), ex);
        const longAxis = 1.18 + 0.86 * straightBias + 0.20 * (lenMul - 1);
        const shortAxis = 0.76 + 0.22 * (1 - straightBias) + 0.06 * r;
        x = sx * radius * longAxis;
        z = sz * radius * shortAxis;
        x += Math.sin(2 * t + 0.2) * radius * (0.06 + 0.04 * r);
      } else if (st === 'partialClover') {
        const rr = radius * (
          0.84
          + 0.24 * Math.cos(4 * t + 0.16)
          + 0.11 * Math.cos(2 * t - 0.34)
          + 0.06 * Math.sin(6 * t + 0.75)
        );
        x = Math.cos(t) * rr * (1.04 + 0.26 * straightBias);
        z = Math.sin(t) * rr * (0.86 + 0.10 * (1 - straightBias));
        x += Math.sin(2 * t - 0.22) * radius * (0.11 + 0.07 * r);
        z += Math.cos(2 * t + 0.31) * radius * (0.05 + 0.05 * r);
      } else if (st === 'trumpet') {
        const rr = radius * (0.72 + 0.24 * Math.cos(t - 0.72) + 0.14 * Math.cos(2 * t + 0.45));
        x = Math.cos(t) * rr * (1.08 + 0.52 * straightBias);
        z = Math.sin(t) * rr * (0.78 + 0.16 * (1 - straightBias));
        const stem = Math.max(0, Math.cos(t - 0.2));
        x += stem * radius * (0.48 + 0.24 * straightBias);
        z += Math.sin(2 * t - 0.38) * radius * (0.08 + 0.08 * r);
      } else if (st === 'stackLite') {
        const rr = radius * (0.84 + 0.20 * Math.cos(2 * t - 0.15) + 0.10 * Math.cos(4 * t + 0.50));
        x = Math.sin(t) * rr * (1.18 + 0.36 * straightBias);
        z = Math.sin(2 * t) * rr * (0.52 + 0.20 * (1 - flow));
        x += Math.sin(4 * t + 0.24) * radius * (0.06 + 0.06 * r);
        z += Math.cos(3 * t - 0.27) * radius * (0.04 + 0.06 * r);
      } else {
        x = Math.sin(t) * radius;
        z = Math.sin((2 + Math.floor(bends / 3)) * t) * radius * 0.58;
      }
      return { x, z };
    }

    for (let i = 0; i < n; i++) {
      const t = (i / n) * Math.PI * 2;
      let x = 0, z = 0;
      if (comboStyles.length <= 1) {
        const p = stylePoint(style, t);
        x = p.x; z = p.z;
      } else {
        const sigma = (Math.PI / comboStyles.length) * 0.72;
        let wsum = 0;
        for (let ci = 0; ci < comboStyles.length; ci++) {
          const center = (ci / comboStyles.length) * Math.PI * 2;
          const d = angDelta(t, center);
          const w = Math.exp(-(d * d) / (2 * sigma * sigma));
          const p = stylePoint(comboStyles[ci], t + comboPhases[ci]);
          x += w * (p.x + comboOffsets[ci].x * radius);
          z += w * (p.z + comboOffsets[ci].z * radius);
          wsum += w;
        }
        if (wsum > 1e-6) {
          x /= wsum;
          z /= wsum;
        }
      }
      if (modY) {
        z += Math.max(0, Math.sin(t)) * radius * (0.1 + 0.13 * r);
      }
      if (modRound) {
        // Always bias wider roundabout geometry.
        const rr = radius * (0.66 + 0.12 * Math.cos(roundExits * t));
        const ringX = Math.cos(t) * rr;
        const ringZ = Math.sin(t) * rr;
        const arm = Math.max(0, Math.cos(roundExits * t));
        const ax = ringX + Math.cos(t) * arm * radius * (0.44 + 0.14 * r);
        const az = ringZ + Math.sin(t) * arm * radius * (0.32 + 0.12 * r);
        const blend = 0.36 + 0.24 * r;
        x = x * (1 - blend) + ax * blend;
        z = z * (1 - blend) + az * blend;
      }
      if (modCross) {
        const crossScale = (style === 'f1long' && comboStyles.length <= 1) ? 0.45 : 1.0;
        z += Math.sin(crossFreq * 2 * t + 0.5) * radius * (0.06 + 0.08 * r) * crossScale;
      }
      // Controlled wobble while keeping the layout drivable.
      const wob = comboStyles.length > 1
        ? 0.19
        : (style === 'figure8'
          ? 1.0
          : (style === 'f1long'
            ? 0.08
            : (isInterchangeStyle(style) ? 0.12 : 0.24)));
      x += Math.sin(t * 3 + twist) * (radius * (0.01 + 0.08 * r) * wob);
      z += Math.cos(t * 4 - twist) * (radius * (0.01 + 0.07 * r) * wob);

      // Rotate final shape.
      let rx = x * c - z * s;
      let rz = x * s + z * c;
      if (style === 'f1long' || comboStyles.includes('f1long')) {
        const sxw = rx + rz * asymSkewX;
        const szw = rz + rx * asymSkewZ;
        rx = sxw;
        rz = szw;
      } else if (isInterchangeStyle(style) || comboStyles.some((st) => isInterchangeStyle(st))) {
        const sxw = rx + rz * asymSkewX * 0.55;
        const szw = rz + rx * asymSkewZ * 0.50;
        rx = sxw;
        rz = szw;
      }

      let y = Math.sin(t * yFreq + twist * 2) * yAmp + bridgeProfile(style, t, r, modY, modCross);
      if (style === 'serpentine') {
        // Keep one side consistently higher than the other.
        y += Math.sin(t) * (0.95 + 2.2 * r);
      } else if (style === 'mountainSpiral') {
        // Spiral-like climb/descent around center mountain.
        y += Math.sin(t * 1.55 - 0.3) * (1.2 + 2.0 * r) + Math.cos(t * 0.5 + 0.15) * (0.55 + 0.95 * r);
      } else if (comboStyles.includes('mountainSpiral')) {
        y += Math.sin(t * 1.28 - 0.18) * (0.65 + 1.25 * r);
      } else if (style === 'diamond') {
        y += Math.sin(2 * t + 0.35) * (0.62 + 0.90 * r);
      } else if (style === 'partialClover') {
        y += Math.sin(2 * t - 0.12) * (0.70 + 1.20 * r) + Math.sin(4 * t + 0.52) * (0.22 + 0.36 * r);
      } else if (style === 'trumpet') {
        y += Math.max(0, Math.cos(t - 0.24)) * (0.78 + 1.18 * r) + Math.sin(2 * t + 0.18) * (0.24 + 0.32 * r);
      } else if (style === 'stackLite') {
        y += Math.sin(2 * t - 0.20) * (0.92 + 1.35 * r) + Math.sin(4 * t + 0.75) * (0.34 + 0.42 * r);
      }
      const bank = Math.sin(t * 2 + twist) * bankAmp;
      out.push({
        pos: v3(rx, y, rz),
        bank,
        node: 'smooth',
        hin: { x: 0, z: 0 },
        hout: { x: 0, z: 0 },
      });
    }
    if (comboStyles.length > 1) {
      smoothGeneratedLayout(out, 2 + Math.round(flow * 2), 0.20 + 0.14 * flow, 0.16 + 0.08 * flow);
    } else if (style === 'f1long') {
      const varKeep = 1 - flow * 0.45;
      smoothGeneratedLayout(out, 3 + Math.round(flow * 2), 0.24 + 0.16 * flow * varKeep, 0.15 + 0.08 * flow);
    } else if (style === 'mountainSpiral') {
      smoothGeneratedLayout(out, 2 + Math.round(flow * 1.5), 0.22 + 0.14 * flow, 0.18 + 0.10 * flow);
    } else if (isInterchangeStyle(style)) {
      smoothGeneratedLayout(out, 2 + Math.round(flow * 1.7), 0.20 + 0.12 * flow, 0.14 + 0.07 * flow);
    } else if (style !== 'figure8') {
      smoothGeneratedLayout(out, 3 + Math.round(flow * 2), 0.36 + 0.18 * flow + 0.06 * r, 0.20 + 0.08 * flow);
    } else {
      smoothGeneratedLayout(out, 1 + Math.round(flow), 0.16 + 0.12 * flow, 0.08 + 0.04 * flow);
    }
    const roadW = Math.max(1, num('roadWidth'));
    const overlapTarget = style === 'figure8'
      ? (roadW * (1.65 + 0.55 * (1 - flow)))
      : (style === 'serpentine'
        ? (roadW * (2.95 + 0.95 * (1 - flow)))
        : (style === 'mountainSpiral'
          ? (roadW * (2.75 + 0.90 * (1 - flow)))
          : (isInterchangeStyle(style)
            ? (roadW * (3.05 + 0.90 * (1 - flow)))
            : (roadW * (2.1 + 0.7 * (1 - flow))))));
    const segGapTarget = style === 'figure8'
      ? (roadW * (0.92 + 0.12 * (1 - flow)))
      : (isInterchangeStyle(style)
        ? (roadW * (1.02 + 0.20 * (1 - flow)))
        : (roadW * (0.98 + 0.18 * (1 - flow))));
    const megaTarget = comboStyles.length > 1 ? overlapTarget * (1.14 + 0.08 * comboStyles.length) : overlapTarget;
    relaxSelfCollisions(out, {
      targetDist: megaTarget,
      minNeighborGap: comboStyles.length > 1 ? 4 : (style === 'f1long' ? 4 : ((style === 'serpentine' || style === 'mountainSpiral' || isInterchangeStyle(style)) ? 4 : 3)),
      passes: comboStyles.length > 1 ? 7 : (style === 'f1long' ? 5 : (style === 'serpentine' ? 6 : (style === 'mountainSpiral' || isInterchangeStyle(style) ? 6 : 4))),
    });
    relaxLoopSegmentClearance(out, {
      minGap: comboStyles.length > 1 ? segGapTarget * (1.06 + 0.03 * comboStyles.length) : segGapTarget,
      yClearance: Math.max(0.75, num('roadThickness') * 1.9),
      minNeighborGap: comboStyles.length > 1 ? 4 : (style === 'f1long' ? 4 : 3),
      passes: comboStyles.length > 1 ? 6 : (isInterchangeStyle(style) ? 5 : 4),
      strength: isInterchangeStyle(style) ? 0.24 : 0.22,
    });
    enforceCornerStepLimit(out, 33.33, pointCap + 24, 0.20);
    if (style === 'f1long' || isInterchangeStyle(style)) {
      enforceLayoutVariety(out, 0.9 + 0.8 * (1 - flow));
    }
    smoothGeneratedLayout(out, 1 + Math.round(flow), 0.08, 0.03);
    relaxLoopSegmentClearance(out, {
      minGap: segGapTarget * 0.96,
      yClearance: Math.max(0.75, num('roadThickness') * 1.9),
      minNeighborGap: comboStyles.length > 1 ? 4 : 3,
      passes: 2,
      strength: 0.16,
    });
    applyTrackRules(out);
    const baseBankIntensity = style === 'f1long'
      ? (0.42 + 0.34 * r)
      : (isInterchangeStyle(style) ? (0.32 + 0.22 * r) : (0.65 + 0.55 * r));
    const bankFlowScale = 1 - flow * 0.2;
    computeGeneratedBank(out, baseBankIntensity * bankFlowScale);
    applyBezierHandles(out, 0.58 + 0.50 * flow);
    const allowInterchangeBranches = chk('genModCross');
    const branchPlan = (allowInterchangeBranches && comboStyles.length <= 1)
      ? buildInterchangeBranchPlan(out, style, r, flow)
      : [];
    return {
      points: out,
      style,
      comboStyles,
      branchPlan,
    };
  }

  function buildGeneratedCandidateState(gen) {
    const outPoints = Array.isArray(gen?.points) ? gen.points.map(cloneCtrlPoint) : [];
    const outBranches = Array.isArray(gen?.branchPlan) ? gen.branchPlan.map(cloneBranchSection) : [];
    const genSnap = generationSnapCfg();
    if (chk('roadIsoSnap')) {
      for (const p of outPoints) {
        const sp = snapRoadXYZWithCfg(p.pos.x, p.pos.y, p.pos.z, genSnap);
        p.pos.x = sp.x;
        p.pos.y = sp.y;
        p.pos.z = sp.z;
      }
    }
    relaxLoopSegmentClearance(outPoints, {
      minGap: Math.max(0.9, num('roadWidth') * 0.98),
      yClearance: Math.max(0.75, num('roadThickness') * 1.9),
      minNeighborGap: 3,
      passes: 3,
      strength: 0.20,
    });
    return { points: outPoints, branchSections: outBranches };
  }

  function evaluateGeneratedCandidate(gen) {
    const prevPoints = points;
    const prevBranches = branchSections;
    const prevSplitEnds = splitEnds;
    const prevMainBreaks = new Set(mainBreaks);
    const cand = buildGeneratedCandidateState(gen);
    points = cand.points;
    branchSections = cand.branchSections;
    splitEnds = [];
    mainBreaks.clear();
    sanitizeBranchSections();
    for (const sec of branchSections) {
      if (sec.kind === 'fork') splitEnds.push(sec.a, sec.b);
    }
    sanitizeSplitEnds();

    const net = sampleRoadNetwork();
    const netDesc = buildRoadNetworkDescriptor(net);
    const report = buildMathConformityReport(net, netDesc);
    const out = {
      report,
      points: points.map(cloneCtrlPoint),
      branchSections: branchSections.map(cloneBranchSection),
      splitEnds: splitEnds.slice(),
      mainBreaks: Array.from(mainBreaks),
    };

    points = prevPoints;
    branchSections = prevBranches;
    splitEnds = prevSplitEnds;
    mainBreaks = prevMainBreaks;
    return out;
  }

  function generatedMathPenalty(report) {
    if (!report) return Number.POSITIVE_INFINITY;
    const selfX = Math.max(0, Number(report.selfX || 0));
    const overlap = Math.max(0, Number(report.overlapConflicts || 0));
    const topo = Math.max(0, Number(report.topoIssueCount || 0));
    const issueCount = Math.max(0, Number(Array.isArray(report.issues) ? report.issues.length : 0));
    return selfX * 160 + overlap * 64 + topo * 36 + issueCount * 8;
  }

  function postFixGeneratedClearance(ctrl, closedMain = true) {
    if (!Array.isArray(ctrl) || ctrl.length < 6) return 0;
    const minGap = Math.max(0.9, num('roadWidth') * 0.98);
    const yClearance = Math.max(0.75, num('roadThickness') * 1.9);
    let remaining = 0;
    for (let iter = 0; iter < 6; iter++) {
      const scan = gatherNetworkSideClearanceConflicts({
        main: ctrl,
        branches: [],
        mainClosed: !!closedMain,
      }, {
        minGap,
        clearanceY: yClearance,
        dedupDist: Math.max(0.32, minGap * 0.55),
        maxPairs: 180000,
        mainOnly: true,
        ignoreSamePolyline: false,
      });
      remaining = Array.isArray(scan?.conflicts) ? scan.conflicts.length : 0;
      if (remaining <= 0) break;
      relaxLoopSegmentClearance(ctrl, {
        minGap,
        yClearance,
        minNeighborGap: 3,
        passes: 2 + Math.min(2, iter),
        strength: 0.22 + 0.03 * iter,
      });
      smoothGeneratedLayout(ctrl, 1, 0.04, 0.01);
    }
    return remaining;
  }

  function generateSafeHighwayFallback() {
    const out = [];
    const roadW = Math.max(1, num('roadWidth'));
    const sizeMul = clamp(num('genScale'), 0.7, 3.8);
    const lenMul = clamp(num('genLength'), 0.8, 3.5);
    const straightBias = clamp(num('genStraights'), 0, 1);
    const flow = clamp(num('genFlow'), 0, 1);
    const n = clamp(Math.round(22 + num('genCurves') * 2.2), 20, 56);
    const rx = (11.5 + roadW * 1.35) * sizeMul * (0.78 + 0.34 * lenMul);
    const rz = rx * (0.46 + 0.34 * straightBias);
    const yAmp = (0.16 + 0.24 * (1 - flow)) * (0.7 + 0.6 * clamp(num('genRandomness'), 0, 1));

    for (let i = 0; i < n; i++) {
      const t = (i / n) * Math.PI * 2;
      const x = Math.cos(t) * rx * (1 + 0.05 * Math.cos(2 * t - 0.2));
      const z = Math.sin(t) * rz * (1 + 0.08 * Math.cos(2 * t + 0.3));
      const y = Math.sin(2 * t - 0.15) * yAmp;
      out.push({
        pos: v3(x, y, z),
        bank: 0,
        node: 'smooth',
        hin: { x: 0, z: 0 },
        hout: { x: 0, z: 0 },
      });
    }

    smoothGeneratedLayout(out, 3, 0.24, 0.12);
    relaxLoopSegmentClearance(out, {
      minGap: Math.max(0.95, roadW * 0.98),
      yClearance: Math.max(0.75, num('roadThickness') * 1.9),
      minNeighborGap: 3,
      passes: 3,
      strength: 0.18,
    });
    enforceCornerStepLimit(out, 33.33, clamp(Math.round(num('genPointCap')) + 20, 24, 180), 0.18);
    applyTrackRules(out);
    computeGeneratedBank(out, 0.40);
    applyBezierHandles(out, 0.86);
    return {
      points: out,
      style: 'safe_highway',
      comboStyles: ['safe_highway'],
      branchPlan: [],
    };
  }

  function runGenerateTrack() {
    pushUndo();
    const maxAttempts = 9;
    let best = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const gen = generateOverlapPoints();
      const evalRes = evaluateGeneratedCandidate(gen);
      const penalty = generatedMathPenalty(evalRes.report);
      if (!best || penalty < best.penalty) {
        best = {
          attempt,
          penalty,
          report: evalRes.report,
          points: evalRes.points.map(cloneCtrlPoint),
          branchSections: evalRes.branchSections.map(cloneBranchSection),
          splitEnds: evalRes.splitEnds.slice(),
          mainBreaks: Array.from(evalRes.mainBreaks || []),
          style: String(gen?.style || txt('genStyle')),
          comboStyles: Array.isArray(gen?.comboStyles) ? gen.comboStyles.slice() : [String(gen?.style || txt('genStyle'))],
        };
      }
      if (evalRes.report?.ok) break;
      const hardErrors = Number(evalRes.report?.selfX || 0) + Number(evalRes.report?.overlapConflicts || 0);
      if (hardErrors <= 0 && (evalRes.report?.issues?.length || 0) <= 1) break;
    }
    const bestHardErrors = Number(best?.report?.selfX || 0) + Number(best?.report?.overlapConflicts || 0);
    if (bestHardErrors > 0) {
      const fallback = generateSafeHighwayFallback();
      const evalRes = evaluateGeneratedCandidate(fallback);
      const penalty = generatedMathPenalty(evalRes.report);
      if (!best || penalty <= best.penalty) {
        best = {
          attempt: Math.max(1, maxAttempts),
          penalty,
          report: evalRes.report,
          points: evalRes.points.map(cloneCtrlPoint),
          branchSections: evalRes.branchSections.map(cloneBranchSection),
          splitEnds: evalRes.splitEnds.slice(),
          mainBreaks: Array.from(evalRes.mainBreaks || []),
          style: 'safe_highway',
          comboStyles: ['safe_highway'],
        };
      }
    }
    if (!best) {
      updateLabels();
      bumpSceneVersion();
      frame3D();
      return;
    }
    points = best.points.map(cloneCtrlPoint);
    branchSections = best.branchSections.map(cloneBranchSection);
    splitEnds = best.splitEnds.slice();
    mainBreaks = new Set((best.mainBreaks || []).filter((i) => Number.isInteger(i) && i >= 0 && i < Math.max(0, points.length - 1)));
    sanitizeMainBreaks();
    const remainingSideConflicts = postFixGeneratedClearance(points, true);
    lastGeneratedMeta = {
      style: best.style,
      comboStyles: best.comboStyles.slice(),
      branchCount: branchSections.length,
      attemptsUsed: best.attempt,
      mathIssues: Math.max(0, Number(best.report?.issues?.length || 0) - Math.max(0, Number(best.report?.sideGapConflicts || 0)) + remainingSideConflicts),
    };
    smoothAllPointHandles();
    placedTrees = [];
    placedFences = [];
    placedBoulders = [];
    fencePlaceStart = null;
    clearPropSelection();
    $('closed').checked = true;
    if (num('subdiv') < 8) $('subdiv').value = '8';
    selected = -1;
    selectedBranch = null;
    selectedBranchSet.clear();
    selectedSet.clear();
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    gizmo.active = false;
    gizmo.target = null;
    gizmo.mode = 'move';
    gizmo.axis = null;
    gizmo.startProp = null;
    gizmo.startSel = null;
    gizmoHoverAxis = null;
    gizmoGhost = null;
    syncSelectedUI();
    updateLabels();
    bumpSceneVersion();
    frame3D();
  }
  $('genBtn').onclick = runGenerateTrack;
  genQuickBtn?.addEventListener('click', runGenerateTrack);

  const objText = $('objText');
  let showOBJ = false;
  $('toggleObj').onclick = () => {
    showOBJ = !showOBJ;
    objText.style.display = showOBJ ? 'block' : 'none';
    $('toggleObj').textContent = showOBJ ? 'Hide OBJ' : 'Show OBJ';
  };

  function autoBankCfg() {
    return {
      enabled: chk('autoBank'),
      strength: num('autoBankStrength'),
      maxDeg: num('autoBankMax'),
      scale: num('autoBankScale'),
    };
  }

  $('exportBtn').onclick = () => {
    const net = sampleRoadNetwork();
    if (net.main.length < 2) return;
    const mainClosed = !!net.mainClosed;
    const branchThemeInputs = [];
    const mainWidth = Math.max(1, Number(net.mainMeta?.width || num('roadWidth')));
    let networkRoadWidthMax = mainWidth;
    const mainRoad = buildRoadMesh(net.main, {
      width: mainWidth,
      thickness: num('roadThickness'),
      includeSides: chk('includeSides'),
      uvScale: 6,
      closed: mainClosed,
      capEnds: !mainClosed,
    });
    const roadTop = cloneMesh(mainRoad.roadTop, 'road_top');
    const roadSides = mainRoad.roadSides ? cloneMesh(mainRoad.roadSides, 'road_sides') : null;
    const roadBottom = mainRoad.roadBottom ? cloneMesh(mainRoad.roadBottom, 'road_bottom') : null;
    for (let bi = 0; bi < net.branches.length; bi++) {
      const bs = net.branches[bi];
      const bSpec = net.branchMeta?.[bi] || getNewBranchSpecDefaults('join');
      const bWidth = Math.max(1, Number(bSpec.width || (num('roadWidth') * roadWidthMultiplierForSpec(bSpec))));
      if (bWidth > networkRoadWidthMax) networkRoadWidthMax = bWidth;
      const extra = buildRoadMesh(bs, {
        width: bWidth,
        thickness: num('roadThickness'),
        includeSides: chk('includeSides'),
        uvScale: 6,
        closed: false,
        capEnds: true,
      });
      branchThemeInputs.push({ samples: bs, frames: extra.frames, spec: bSpec, width: bWidth });
      mergeMeshInto(roadTop, extra.roadTop);
      if (roadSides && extra.roadSides) mergeMeshInto(roadSides, extra.roadSides);
      if (roadBottom && extra.roadBottom) mergeMeshInto(roadBottom, extra.roadBottom);
    }
    addJunctionPads(roadTop, networkRoadWidthMax, {
      net,
      roadSides,
      roadBottom,
      thickness: num('roadThickness'),
    });
    const terrain = chk('terrainOn')
      ? buildTerrainMesh(net.all, terrainOptsFromUi(networkRoadWidthMax))
      : null;
    const themeMain = buildThemeMeshes(net.main, mainRoad.frames, {
      enabled: chk('themeOn'),
      roadWidth: mainWidth,
      roadThickness: num('roadThickness'),
      shoulderWidth: num('themeGrass'),
      curbHeight: num('themeCurb'),
      supportStyle: txt('supportStyle'),
      bridgeMaterial: txt('bridgeMaterial'),
      closed: mainClosed,
      capEnds: !mainClosed,
      junctionPads: true,
      net,
    });
    const themeBranches = [];
    for (const b of branchThemeInputs) {
      const tm = buildThemeMeshes(b.samples, b.frames, {
        enabled: chk('themeOn'),
        roadWidth: b.width,
        roadThickness: num('roadThickness'),
        shoulderWidth: num('themeGrass'),
        curbHeight: num('themeCurb'),
        supportStyle: txt('supportStyle'),
        bridgeMaterial: txt('bridgeMaterial'),
        closed: false,
        capEnds: false,
        junctionPads: false,
      });
      if (tm.length) themeBranches.push(...tm);
    }
    const theme = [...themeMain, ...themeBranches];
    const supportBlockCell = clamp(networkRoadWidthMax * 0.42, 0.85, 4.4);
    const roadBlockers = buildSupportBlockerIndex([roadTop, ...(roadSides ? [roadSides] : []), ...(roadBottom ? [roadBottom] : [])], { cellSize: supportBlockCell });
    const supportBlockerMeshes = [roadTop];
    if (roadSides) supportBlockerMeshes.push(roadSides);
    if (roadBottom) supportBlockerMeshes.push(roadBottom);
    for (const t of theme) if (t?.mesh) supportBlockerMeshes.push(t.mesh);
    let supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
    const supportMain = buildSupportMeshesWithFallback(net.main, mainRoad.frames, terrain, {
      enabled: chk('themeOn') && !!terrain,
      roadWidth: mainWidth,
      roadThickness: num('roadThickness'),
      closed: mainClosed,
      isBranch: false,
      style: txt('supportStyle'),
      blockerIndex: supportBlockers,
      roadBlockerIndex: roadBlockers,
    });
    if (supportMain.length) {
      for (const sm of supportMain) if (sm?.mesh) supportBlockerMeshes.push(sm.mesh);
      supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
    }
    const supportBranches = [];
    for (const b of branchThemeInputs) {
      const sm = buildSupportMeshesWithFallback(b.samples, b.frames, terrain, {
        enabled: chk('themeOn') && !!terrain,
        roadWidth: b.width,
        roadThickness: num('roadThickness'),
        closed: false,
        isBranch: true,
        style: txt('supportStyle'),
        blockerIndex: supportBlockers,
        roadBlockerIndex: roadBlockers,
      });
      if (sm.length) {
        supportBranches.push(...sm);
        for (const se of sm) if (se?.mesh) supportBlockerMeshes.push(se.mesh);
        supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
      }
    }
    const supports = [...supportMain, ...supportBranches];
    const placed = buildPlacedPropMeshes({
      enabled: chk('themeOn'),
      fenceScale: num('themeFence'),
      treeScale: num('themeTrees'),
      rockScale: num('themeRocks'),
    }, {
      fences: placedFences,
      trees: placedTrees,
      boulders: placedBoulders,
    });
    const themeMeshes = [...theme, ...supports, ...placed].map(t => t.mesh);
    const name = (txt('trackName') || 'track').trim();
    const mtlFile = `${name}.mtl`;
    const obj = meshesToOBJ([roadTop, ...(roadSides ? [roadSides] : []), ...(roadBottom ? [roadBottom] : []), ...(terrain ? [terrain] : []), ...themeMeshes], { mtllib: mtlFile });
    const mtl = buildDefaultMtlLibrary();
    objText.value = obj;
    try { downloadText(name + '.obj', obj); }
    catch {
      showOBJ = true;
      objText.style.display = 'block';
      $('toggleObj').textContent = 'Hide OBJ';
      return;
    }
    try { downloadText(name + '.mtl', mtl); } catch {}
  };

  $('exportFbxBtn').onclick = () => {
    const scene = getMesh();
    if (!scene?.roadTop) {
      showErr('No mesh to export. Generate or draw a track first.');
      return;
    }
    const name = (txt('trackName') || 'track').trim().replace(/[^a-z0-9._-]+/gi, '_') || 'track';
    try {
      const models = buildEnfusionFbxModels(scene);
      const fbx = meshesToFbxAscii(models, { creator: 'KARTMAKER ARGH Enfusion FBX' });
      if (!fbx) throw new Error('FBX build produced no geometry.');
      downloadText(name + '_enfusion.fbx', fbx);
      const note = [
        'KARTMAKER Enfusion FBX export',
        '',
        'Included objects:',
        '- VIS_Main_LOD0 : visual render mesh',
        '- GEO_Collision : geometry collision helper mesh',
        '- ROADWAY_Collision : roadway collision helper mesh',
        '',
        'Next step:',
        'Import this FBX in Blender and use Enfusion Blender Tools to map these objects to your exact Enfusion LOD setup before packing.',
      ].join('\n');
      downloadText(name + '_enfusion_fbx_notes.txt', note);
    } catch (e) {
      showErr('FBX export failed: ' + String(e?.message || e));
    }
  };

  $('exportTerrainBtn').onclick = () => {
    const scene = getMesh();
    if (!scene?.terrain) {
      showErr('No terrain mesh to export. Enable Terrain and generate a track first.');
      return;
    }
    const name = (txt('trackName') || 'track').trim().replace(/[^a-z0-9._-]+/gi, '_') || 'track';
    try {
      exportTerrainForEnfusion(name, scene.terrain);
    } catch (e) {
      showErr('Terrain export failed: ' + String(e?.message || e));
    }
  };

  // ---------- pro handle rules ----------
  function setHandle(target, which, hx, hz, opts = { rotateOnly: false, breakMirror: false }) {
    let p = null;
    if (target?.kind === 'branch') {
      const sec = branchSections[target.sec];
      p = sec?.mids?.[target.mid] || null;
      if (p) {
        if (!p.hin) p.hin = { x: 0, z: 0 };
        if (!p.hout) p.hout = { x: 0, z: 0 };
        if (!p.node) p.node = 'smooth';
      }
    } else {
      p = points[target?.i];
      if (p) ensurePointShape(p);
    }
    if (!p) return;
    const node = p.node || 'smooth';

    // rotateOnly: preserve original length
    const cur = which === 'in' ? p.hin : p.hout;
    let nx = hx, nz = hz;
    if (opts.rotateOnly) {
      const L = Math.hypot(cur.x, cur.z) || 1;
      const ang = Math.atan2(hz, hx);
      nx = Math.cos(ang) * L;
      nz = Math.sin(ang) * L;
    }

    if (which === 'in') p.hin = { x: nx, z: nz }; else p.hout = { x: nx, z: nz };

    // Corner (or breakMirror) => no coupling
    if (node === 'corner' || opts.breakMirror) return;

    // Mirror the opposite handle angle (and optionally length)
    const oppWhich = which === 'in' ? 'out' : 'in';
    const opp = oppWhich === 'in' ? p.hin : p.hout;

    const ang = Math.atan2(nz, nx);
    const oppAng = ang + Math.PI; // opposite direction

    if (node === 'smooth') {
      const L = Math.hypot(nx, nz) || 1;
      const ox = Math.cos(oppAng) * L;
      const oz = Math.sin(oppAng) * L;
      if (oppWhich === 'in') p.hin = { x: ox, z: oz }; else p.hout = { x: ox, z: oz };
    } else if (node === 'aligned') {
      const L = Math.hypot(opp.x, opp.z) || 1;
      const ox = Math.cos(oppAng) * L;
      const oz = Math.sin(oppAng) * L;
      if (oppWhich === 'in') p.hin = { x: ox, z: oz }; else p.hout = { x: ox, z: oz };
    }
  }

  // ---------- 3D preview (software renderer) ----------
  function getMesh() {
    if (cached) return cached;
    const net = sampleRoadNetwork();
    if (net.main.length < 2) { cached = null; return null; }
    const mainClosed = !!net.mainClosed;
    const branchThemeInputs = [];
    const mainWidth = Math.max(1, Number(net.mainMeta?.width || num('roadWidth')));
    let networkRoadWidthMax = mainWidth;
    const mainRoad = buildRoadMesh(net.main, {
      width: mainWidth,
      thickness: num('roadThickness'),
      includeSides: chk('includeSides'),
      uvScale: 6,
      closed: mainClosed,
      capEnds: !mainClosed,
    });
    const roadTop = cloneMesh(mainRoad.roadTop, 'road_top');
    const roadSides = mainRoad.roadSides ? cloneMesh(mainRoad.roadSides, 'road_sides') : null;
    const roadBottom = mainRoad.roadBottom ? cloneMesh(mainRoad.roadBottom, 'road_bottom') : null;
    for (let bi = 0; bi < net.branches.length; bi++) {
      const bs = net.branches[bi];
      const bSpec = net.branchMeta?.[bi] || getNewBranchSpecDefaults('join');
      const bWidth = Math.max(1, Number(bSpec.width || (num('roadWidth') * roadWidthMultiplierForSpec(bSpec))));
      if (bWidth > networkRoadWidthMax) networkRoadWidthMax = bWidth;
      const extra = buildRoadMesh(bs, {
        width: bWidth,
        thickness: num('roadThickness'),
        includeSides: chk('includeSides'),
        uvScale: 6,
        closed: false,
        capEnds: true,
      });
      branchThemeInputs.push({ samples: bs, frames: extra.frames, spec: bSpec, width: bWidth });
      mergeMeshInto(roadTop, extra.roadTop);
      if (roadSides && extra.roadSides) mergeMeshInto(roadSides, extra.roadSides);
      if (roadBottom && extra.roadBottom) mergeMeshInto(roadBottom, extra.roadBottom);
    }
    addJunctionPads(roadTop, networkRoadWidthMax, {
      net,
      roadSides,
      roadBottom,
      thickness: num('roadThickness'),
    });
    const terrain = chk('terrainOn')
      ? buildTerrainMesh(net.all, terrainOptsFromUi(networkRoadWidthMax))
      : null;
    const themeMain = buildThemeMeshes(net.main, mainRoad.frames, {
      enabled: chk('themeOn'),
      roadWidth: mainWidth,
      roadThickness: num('roadThickness'),
      shoulderWidth: num('themeGrass'),
      curbHeight: num('themeCurb'),
      supportStyle: txt('supportStyle'),
      bridgeMaterial: txt('bridgeMaterial'),
      closed: mainClosed,
      capEnds: !mainClosed,
      junctionPads: true,
      net,
    });
    const themeBranches = [];
    for (const b of branchThemeInputs) {
      const tm = buildThemeMeshes(b.samples, b.frames, {
        enabled: chk('themeOn'),
        roadWidth: b.width,
        roadThickness: num('roadThickness'),
        shoulderWidth: num('themeGrass'),
        curbHeight: num('themeCurb'),
        supportStyle: txt('supportStyle'),
        bridgeMaterial: txt('bridgeMaterial'),
        closed: false,
        capEnds: false,
        junctionPads: false,
      });
      if (tm.length) themeBranches.push(...tm);
    }
    const theme = [...themeMain, ...themeBranches];
    const supportBlockCell = clamp(networkRoadWidthMax * 0.42, 0.85, 4.4);
    const roadBlockers = buildSupportBlockerIndex([roadTop, ...(roadSides ? [roadSides] : []), ...(roadBottom ? [roadBottom] : [])], { cellSize: supportBlockCell });
    const supportBlockerMeshes = [roadTop];
    if (roadSides) supportBlockerMeshes.push(roadSides);
    if (roadBottom) supportBlockerMeshes.push(roadBottom);
    for (const t of theme) if (t?.mesh) supportBlockerMeshes.push(t.mesh);
    let supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
    const supportMain = buildSupportMeshesWithFallback(net.main, mainRoad.frames, terrain, {
      enabled: chk('themeOn') && !!terrain,
      roadWidth: mainWidth,
      roadThickness: num('roadThickness'),
      closed: mainClosed,
      isBranch: false,
      style: txt('supportStyle'),
      blockerIndex: supportBlockers,
      roadBlockerIndex: roadBlockers,
    });
    if (supportMain.length) {
      for (const sm of supportMain) if (sm?.mesh) supportBlockerMeshes.push(sm.mesh);
      supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
    }
    const supportBranches = [];
    for (const b of branchThemeInputs) {
      const sm = buildSupportMeshesWithFallback(b.samples, b.frames, terrain, {
        enabled: chk('themeOn') && !!terrain,
        roadWidth: b.width,
        roadThickness: num('roadThickness'),
        closed: false,
        isBranch: true,
        style: txt('supportStyle'),
        blockerIndex: supportBlockers,
        roadBlockerIndex: roadBlockers,
      });
      if (sm.length) {
        supportBranches.push(...sm);
        for (const se of sm) if (se?.mesh) supportBlockerMeshes.push(se.mesh);
        supportBlockers = buildSupportBlockerIndex(supportBlockerMeshes, { cellSize: supportBlockCell });
      }
    }
    const supports = [...supportMain, ...supportBranches];
    const placed = buildPlacedPropMeshes({
      enabled: chk('themeOn'),
      fenceScale: num('themeFence'),
      treeScale: num('themeTrees'),
      rockScale: num('themeRocks'),
    }, {
      fences: placedFences,
      trees: placedTrees,
      boulders: placedBoulders,
    });

    const tris = [];
    function pushMesh(mesh, kind) {
      for (const f of mesh.faces) {
        const a = mesh.verts[f.a - 1], b = mesh.verts[f.b - 1], c = mesh.verts[f.c - 1];
        if (!a || !b || !c) continue;
        tris.push({ a, b, c, kind });
      }
    }
    pushMesh(roadTop, 'top');
    if (roadSides) pushMesh(roadSides, 'side');
    if (roadBottom) pushMesh(roadBottom, 'side');
    if (terrain) pushMesh(terrain, 'terrain');
    for (const t of theme) pushMesh(t.mesh, t.kind);
    for (const t of supports) pushMesh(t.mesh, t.kind);
    for (const t of placed) pushMesh(t.mesh, t.kind);

    const allVerts = [
      ...roadTop.verts,
      ...(roadSides ? roadSides.verts : []),
      ...(roadBottom ? roadBottom.verts : []),
      ...(terrain ? terrain.verts : []),
      ...theme.flatMap(t => t.mesh.verts),
      ...supports.flatMap(t => t.mesh.verts),
      ...placed.flatMap(t => t.mesh.verts),
    ];
    const mn = v3(+1e9, +1e9, +1e9), mx = v3(-1e9, -1e9, -1e9);
    for (const p of allVerts) {
      mn.x = Math.min(mn.x, p.x); mn.y = Math.min(mn.y, p.y); mn.z = Math.min(mn.z, p.z);
      mx.x = Math.max(mx.x, p.x); mx.y = Math.max(mx.y, p.y); mx.z = Math.max(mx.z, p.z);
    }

    cached = {
      samples: net.main,
      branchSamples: net.branches,
      roadTop,
      roadSides,
      roadBottom,
      terrain,
      theme: [...theme, ...supports],
      placed,
      tris,
      network: buildRoadNetworkDescriptor(net),
      bbox: { min: mn, max: mx },
    };
    return cached;
  }

  function camForward() {
    const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    return norm(v3(cy * cp, sp, -sy * cp));
  }

  function camPos() { return camEye; }

  function setCameraLookAt(eye, target) {
    camEye = v3(eye.x, eye.y, eye.z);
    const d = norm(sub(target, eye));
    camPitch = clamp(Math.asin(clamp(d.y, -1, 1)), -1.48, 1.48);
    camYaw = Math.atan2(-d.z, d.x);
  }

  function updateCameraMove(dt, basis) {
    if (isTypingTarget(document.activeElement)) return;
    let mv = v3(0, 0, 0);
    if (keysDown.has('KeyW')) mv = add(mv, basis.f);
    if (keysDown.has('KeyS')) mv = add(mv, mul(basis.f, -1));
    if (keysDown.has('KeyD')) mv = add(mv, basis.r);
    if (keysDown.has('KeyA')) mv = add(mv, mul(basis.r, -1));
    if (keysDown.has('KeyQ')) mv = add(mv, v3(0, 1, 0));
    if (keysDown.has('KeyZ')) mv = add(mv, v3(0, -1, 0));
    const L = len(mv);
    if (L < 1e-6) return;
    const boost = keysDown.has('ShiftLeft') || keysDown.has('ShiftRight') ? 2.8 : 1.0;
    const step = camMoveSpeed * boost * dt;
    camEye = add(camEye, mul(norm(mv), step));
  }

  function lookAtBasis(eye, target) {
    const f = norm(sub(target, eye));
    const up0 = v3(0, 1, 0);
    let r = cross(f, up0);
    if (len(r) < 1e-6) r = v3(1, 0, 0);
    r = norm(r);
    const u = norm(cross(r, f));
    return { r, u, f };
  }

  function project3(p, eye, basis, w, h) {
    const q = sub(p, eye);
    const x = dot(q, basis.r);
    const y = dot(q, basis.u);
    const z = dot(q, basis.f);
    const fov = 60 * Math.PI / 180;
    const s = 1 / Math.tan(fov / 2);
    const aspect = w / h;
    const nz = z <= 0.02 ? 0.02 : z;
    const px = (x * s / aspect) / nz;
    const py = (y * s) / nz;
    return { sx: (px * 0.5 + 0.5) * w, sy: (-py * 0.5 + 0.5) * h, z: nz };
  }

  function shadeTri(a, b, c) {
    const n = norm(cross(sub(b, a), sub(c, a)));
    const light = norm(v3(-0.35, 0.85, 0.4));
    return clamp(dot(n, light) * 0.7 + 0.3, 0, 1);
  }

  function frame3D() {
    const m = getMesh();
    if (!m || !m.bbox) return;
    const b = m.bbox;
    let tgt = null;
    let r = 0;

    if (selected >= 0 && points[selected]) {
      tgt = points[selected].pos;
      const pi = mainPrevIndex(selected);
      const ni = mainNextIndex(selected);
      const prev = pi >= 0 ? points[pi]?.pos : tgt;
      const next = ni >= 0 ? points[ni]?.pos : tgt;
      const avgSeg = (Math.hypot(tgt.x - prev.x, tgt.z - prev.z) + Math.hypot(next.x - tgt.x, next.z - tgt.z)) * 0.5;
      r = clamp(Math.max(num('roadWidth') * 1.35, avgSeg * 1.9), 2.8, 16);
    } else if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (ref?.mid) {
        tgt = v3(ref.mid.x, ref.mid.y, ref.mid.z);
        r = clamp(num('roadWidth') * 1.6, 2.8, 16);
      }
    }

    if (!tgt) {
      tgt = mul(add(b.min, b.max), 0.5);
      const ext = sub(b.max, b.min);
      r = Math.max(ext.x, ext.y, ext.z) * 0.9 + 1e-6;
    }

    const eye = add(tgt, v3(r * 1.22, r * 0.72, -r * 1.22));
    setCameraLookAt(eye, tgt);
    camSpeedBase = camBaseSpeedFromRadius(r);
    camMoveSpeed = camSpeedBase;
  }

  function gizmoScreen(eye, basis, w, h) {
    let P = null;
    if (mode === 'propedit') P = selectedProp ? propPivot(selectedProp) : null;
    else if (selected >= 0) P = points[selected]?.pos || null;
    else if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (ref?.mid) P = v3(ref.mid.x, ref.mid.y, ref.mid.z);
    }
    if (!P) return null;
    const center = project3(P, eye, basis, w, h);
    const size = Math.max(1.5, len(sub(P, eye)) * 0.085);
    const px = project3(add(P, v3(size, 0, 0)), eye, basis, w, h);
    const py = project3(add(P, v3(0, size, 0)), eye, basis, w, h);
    const pz = project3(add(P, v3(0, 0, size)), eye, basis, w, h);
    const ringRadius = size * 0.92;
    const segs = 30;
    const ringFor = (axis) => {
      const pts = [];
      let U = v3(1, 0, 0);
      let V = v3(0, 0, 1);
      if (axis === 'x') {
        U = v3(0, 1, 0);
        V = v3(0, 0, 1);
      } else if (axis === 'y') {
        U = v3(1, 0, 0);
        V = v3(0, 0, 1);
      } else if (axis === 'z') {
        U = v3(1, 0, 0);
        V = v3(0, 1, 0);
      }
      for (let i = 0; i <= segs; i++) {
        const a = (i / segs) * Math.PI * 2;
        const local = add(mul(U, Math.cos(a) * ringRadius), mul(V, Math.sin(a) * ringRadius));
        pts.push(project3(add(P, local), eye, basis, w, h));
      }
      return pts;
    };
    return { P, center, px, py, pz, depth: center.z, size, rx: ringFor('x'), ry: ringFor('y'), rz: ringFor('z') };
  }

  function hitGizmoAxis(gs, sx, sy, modeHint = 'move') {
    if (!gs) return null;
    if (modeHint === 'rotate') {
      const rings = [
        { axis: 'x', pts: gs.rx },
        { axis: 'y', pts: gs.ry },
        { axis: 'z', pts: gs.rz },
      ];
      let best = null;
      let bd = 11;
      for (const r of rings) {
        const pts = r.pts;
        for (let i = 0; i < pts.length - 1; i++) {
          const a = pts[i], b = pts[i + 1];
          const hit = closestPointOnScreenSegment(sx, sy, a.sx, a.sy, b.sx, b.sy);
          if (hit.d < bd) {
            bd = hit.d;
            best = r.axis;
          }
        }
      }
      const centerHit = Math.hypot(sx - gs.center.sx, sy - gs.center.sy);
      if (centerHit <= 8) return 'free';
      return best;
    }
    const hitRad = 10;
    const centerHit = Math.hypot(sx - gs.center.sx, sy - gs.center.sy);
    if (centerHit <= 8) return 'free';
    const c = gs.center;
    const axes = [
      { axis: 'x', p: gs.px },
      { axis: 'y', p: gs.py },
      { axis: 'z', p: gs.pz },
    ];
    let best = null;
    let bd = hitRad;
    for (const a of axes) {
      const x1 = c.sx, y1 = c.sy, x2 = a.p.sx, y2 = a.p.sy;
      const vx = x2 - x1, vy = y2 - y1;
      const wx = sx - x1, wy = sy - y1;
      const vv = vx * vx + vy * vy || 1;
      const t = clamp((wx * vx + wy * vy) / vv, 0, 1);
      const px = x1 + vx * t, py = y1 + vy * t;
      const d = Math.hypot(sx - px, sy - py);
      if (d < bd) { bd = d; best = a.axis; }
    }
    return best;
  }

  function worldPerPixel(depth, h) {
    const fov = 60 * Math.PI / 180;
    const viewH = 2 * depth * Math.tan(fov / 2);
    return viewH / h;
  }

  function renderAxisHelper(basis, w, h) {
    const cx = w - 68;
    const cy = h - 68;
    const L = 28;
    const axes = [
      { name: 'X', dir: v3(1, 0, 0), col: '255,110,110' },
      { name: 'Y', dir: v3(0, 1, 0), col: '120,255,160' },
      { name: 'Z', dir: v3(0, 0, 1), col: '120,170,255' },
    ].map(a => ({
      ...a,
      dx: dot(a.dir, basis.r),
      dy: dot(a.dir, basis.u),
      dz: dot(a.dir, basis.f),
    }));

    vctx.save();
    vctx.globalAlpha = 0.45;
    vctx.fillStyle = 'rgba(11,15,25,0.85)';
    vctx.strokeStyle = 'rgba(183,197,255,0.45)';
    vctx.lineWidth = 1;
    vctx.beginPath();
    vctx.arc(cx, cy, 34, 0, Math.PI * 2);
    vctx.fill();
    vctx.stroke();

    axes.sort((a, b) => a.dz - b.dz);
    vctx.lineCap = 'round';
    vctx.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';

    for (const a of axes) {
      const ex = cx + a.dx * L;
      const ey = cy - a.dy * L;
      const alpha = 0.45 + 0.5 * ((a.dz + 1) * 0.5);

      vctx.globalAlpha = alpha;
      vctx.strokeStyle = `rgb(${a.col})`;
      vctx.lineWidth = 2.2;
      vctx.beginPath();
      vctx.moveTo(cx, cy);
      vctx.lineTo(ex, ey);
      vctx.stroke();

      vctx.fillStyle = `rgb(${a.col})`;
      vctx.beginPath();
      vctx.arc(ex, ey, 3.4, 0, Math.PI * 2);
      vctx.fill();

      vctx.globalAlpha = 0.95;
      vctx.fillStyle = '#e9ecf6';
      vctx.fillText(a.name, ex + 6, ey + 4);
    }
    vctx.restore();
  }

  let lastCamTick = performance.now();
  function render3D() {
    if (viewCard.classList.contains('hidden')) {
      requestAnimationFrame(render3D);
      return;
    }
    try {
      const r = viewWrap.getBoundingClientRect();
      const w = r.width, h = r.height;
      vctx.clearRect(0, 0, w, h);
      vctx.fillStyle = '#0b0f19';
      vctx.fillRect(0, 0, w, h);

      const m = getMesh();
      if (!m) { requestAnimationFrame(render3D); return; }

    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0, (now - lastCamTick) / 1000));
    lastCamTick = now;

    let eye = camPos();
    let target = add(eye, camForward());
    let basis = lookAtBasis(eye, target);
    updateCameraMove(dt, basis);
    eye = camPos();
    target = add(eye, camForward());
    basis = lookAtBasis(eye, target);

    // grid hint
    vctx.save();
    vctx.globalAlpha = 0.15;
    vctx.strokeStyle = '#24345f';
    vctx.lineWidth = 1;
    const step = 5, span = 50;
    for (let i = -span; i <= span; i += step) {
      const p0 = v3(i, 0, -span), p1 = v3(i, 0, span);
      const q0 = project3(p0, eye, basis, w, h), q1 = project3(p1, eye, basis, w, h);
      vctx.beginPath(); vctx.moveTo(q0.sx, q0.sy); vctx.lineTo(q1.sx, q1.sy); vctx.stroke();
      const r0 = v3(-span, 0, i), r1 = v3(span, 0, i);
      const s0 = project3(r0, eye, basis, w, h), s1 = project3(r1, eye, basis, w, h);
      vctx.beginPath(); vctx.moveTo(s0.sx, s0.sy); vctx.lineTo(s1.sx, s1.sy); vctx.stroke();
    }
    vctx.restore();

    const projected = [];
    for (const t of m.tris) {
      const pa = project3(t.a, eye, basis, w, h);
      const pb = project3(t.b, eye, basis, w, h);
      const pc = project3(t.c, eye, basis, w, h);
      const z = (pa.z + pb.z + pc.z) / 3;
      const n = norm(cross(sub(t.b, t.a), sub(t.c, t.a)));
      projected.push({ pa, pb, pc, z, kind: t.kind, a: t.a, b: t.b, c: t.c, n });
    }
    projected.sort((A, B) => B.z - A.z);

    if (viewMode !== 'wireframe') {
      for (const t of projected) {
        if (viewMode === 'normal') {
          const nr = Math.round((t.n.x * 0.5 + 0.5) * 255);
          const ng = Math.round((t.n.y * 0.5 + 0.5) * 255);
          const nb = Math.round((t.n.z * 0.5 + 0.5) * 255);
          vctx.fillStyle = `rgb(${nr},${ng},${nb})`;
        } else {
          const d = shadeTri(t.a, t.b, t.c);
          let base = [20, 24, 35];
          if (t.kind === 'top') base = [42, 47, 58];
          else if (t.kind === 'terrain') base = [117, 102, 78];
          else if (t.kind === 'grass') base = [74, 136, 82];
          else if (t.kind === 'curb') base = [206, 186, 134];
          else if (t.kind === 'underdeck') base = [98, 104, 116];
          else if (t.kind === 'bridgeDeckFreeway') base = [122, 128, 138];
          else if (t.kind === 'bridgeDeckWood') base = [160, 111, 67];
          else if (t.kind === 'bridgeDeckSteel') base = [124, 138, 156];
          else if (t.kind === 'support') base = [144, 149, 157];
          else if (t.kind === 'fence') base = [126, 92, 58];
          else if (t.kind === 'treeTrunk') base = [108, 77, 45];
          else if (t.kind === 'treeLeaf') base = [79, 166, 90];
          else if (t.kind === 'rock') base = [134, 138, 146];
          vctx.fillStyle = `rgb(${Math.round(base[0] * d)},${Math.round(base[1] * d)},${Math.round(base[2] * d)})`;
        }
        vctx.beginPath();
        vctx.moveTo(t.pa.sx, t.pa.sy);
        vctx.lineTo(t.pb.sx, t.pb.sy);
        vctx.lineTo(t.pc.sx, t.pc.sy);
        vctx.closePath();
        vctx.fill();
      }
    }

    if (viewMode !== 'normal') {
      vctx.save();
      vctx.globalAlpha = viewMode === 'wireframe' ? 0.96 : 0.35;
      vctx.strokeStyle = viewMode === 'wireframe' ? '#e5eeff' : '#b7c5ff';
      vctx.lineWidth = viewMode === 'wireframe' ? 1.35 : 1;
      for (const t of projected) {
        vctx.beginPath();
        vctx.moveTo(t.pa.sx, t.pa.sy);
        vctx.lineTo(t.pb.sx, t.pb.sy);
        vctx.lineTo(t.pc.sx, t.pc.sy);
        vctx.closePath();
        vctx.stroke();
      }
      vctx.restore();
    }

    // centerline
    vctx.save();
    vctx.globalAlpha = 0.9;
    vctx.strokeStyle = '#ffd36e';
    vctx.setLineDash([6, 6]);
    vctx.beginPath();
    for (let i = 0; i < m.samples.length; i++) {
      const p = project3(m.samples[i].pos, eye, basis, w, h);
      if (i === 0) vctx.moveTo(p.sx, p.sy); else vctx.lineTo(p.sx, p.sy);
    }
    vctx.stroke();
    vctx.setLineDash([]);
    vctx.restore();

    const overlapMarks3D = Array.isArray(latestMathReport?.overlaps) ? latestMathReport.overlaps : [];
    if (overlapMarks3D.length) {
      const maxMarks = 120;
      for (let i = 0; i < overlapMarks3D.length && i < maxMarks; i++) {
        const o = overlapMarks3D[i];
        const wp = v3(o.x, o.y, o.z);
        const q = sub(wp, eye);
        if (dot(q, basis.f) <= 0.04) continue;
        const sp = project3(wp, eye, basis, w, h);
        if (o.type === 'conflict') {
          vctx.save();
          vctx.globalAlpha = 0.96;
          vctx.strokeStyle = '#ff8d8d';
          vctx.lineWidth = 2;
          vctx.beginPath(); vctx.arc(sp.sx, sp.sy, 7, 0, Math.PI * 2); vctx.stroke();
          vctx.beginPath(); vctx.moveTo(sp.sx - 4.5, sp.sy - 4.5); vctx.lineTo(sp.sx + 4.5, sp.sy + 4.5); vctx.stroke();
          vctx.beginPath(); vctx.moveTo(sp.sx + 4.5, sp.sy - 4.5); vctx.lineTo(sp.sx - 4.5, sp.sy + 4.5); vctx.stroke();
          vctx.restore();
        } else {
          vctx.save();
          vctx.globalAlpha = 0.90;
          vctx.strokeStyle = '#8bd9ff';
          vctx.lineWidth = 1.35;
          vctx.beginPath(); vctx.arc(sp.sx, sp.sy, 4.8, 0, Math.PI * 2); vctx.stroke();
          vctx.restore();
        }
      }
    }

    // control polygon + clickable control points in 3D
    if (points.length > 1) {
      vctx.save();
      vctx.globalAlpha = 0.45;
      vctx.strokeStyle = '#9fb3ff';
      vctx.lineWidth = 1;
      const segsMain = mainConnectedSegments();
      for (const seg of segsMain) {
        const pa = project3(points[seg.a].pos, eye, basis, w, h);
        const pb = project3(points[seg.b].pos, eye, basis, w, h);
        vctx.beginPath();
        vctx.moveTo(pa.sx, pa.sy);
        vctx.lineTo(pb.sx, pb.sy);
        vctx.stroke();
      }
      vctx.restore();
    }
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const q = sub(p.pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const sp = project3(p.pos, eye, basis, w, h);
      vctx.save();
      vctx.fillStyle = i === selected ? '#ffd36e' : '#f5f7ff';
      vctx.globalAlpha = i === selected ? 1 : 0.92;
      vctx.beginPath(); vctx.arc(sp.sx, sp.sy, i === selected ? 5.4 : 4.2, 0, Math.PI * 2); vctx.fill();
      vctx.restore();
    }

    const drawBezierHandles3D = (target) => {
      if (!target) return;
      const anchor = bezierHandleAnchor(target);
      if (!anchor) return;
      const q0 = sub(anchor, eye);
      if (dot(q0, basis.f) <= 0.04) return;
      const aSp = project3(anchor, eye, basis, w, h);
      const hIn = bezierHandleWorldPoint(target, 'in');
      const hOut = bezierHandleWorldPoint(target, 'out');
      if (!hIn || !hOut) return;
      const qIn = sub(hIn, eye);
      const qOut = sub(hOut, eye);
      if (dot(qIn, basis.f) <= 0.04 || dot(qOut, basis.f) <= 0.04) return;
      const inSp = project3(hIn, eye, basis, w, h);
      const outSp = project3(hOut, eye, basis, w, h);
      const inHover = sameBezierHandle(bezier3DHover, { ...target, which: 'in' }) || sameBezierHandle(bezier3DDrag, { ...target, which: 'in' });
      const outHover = sameBezierHandle(bezier3DHover, { ...target, which: 'out' }) || sameBezierHandle(bezier3DDrag, { ...target, which: 'out' });

      vctx.save();
      vctx.globalAlpha = 0.95;
      vctx.lineWidth = 1.4;
      vctx.strokeStyle = '#9bb4ff';
      vctx.beginPath();
      vctx.moveTo(aSp.sx, aSp.sy);
      vctx.lineTo(inSp.sx, inSp.sy);
      vctx.moveTo(aSp.sx, aSp.sy);
      vctx.lineTo(outSp.sx, outSp.sy);
      vctx.stroke();

      const drawDot = (sp, fill, hover) => {
        vctx.fillStyle = fill;
        vctx.beginPath();
        vctx.arc(sp.sx, sp.sy, hover ? 5.0 : 4.0, 0, Math.PI * 2);
        vctx.fill();
        vctx.lineWidth = hover ? 2.0 : 1.2;
        vctx.strokeStyle = hover ? '#f7fbff' : '#d7e6ff';
        vctx.stroke();
      };
      drawDot(inSp, '#7ea8ff', inHover);
      drawDot(outSp, '#8cf6a7', outHover);
      vctx.restore();
    };
    if (selectedBranch) drawBezierHandles3D({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid });
    else if (selected >= 0 && points[selected]) drawBezierHandles3D({ kind: 'main', i: selected });

    // placed props overlays
    if (placedFences.length) {
      vctx.save();
      vctx.globalAlpha = 0.8;
      vctx.strokeStyle = '#9bc2ff';
      vctx.lineWidth = 2;
      for (const f of placedFences) {
        const a = project3(f.a, eye, basis, w, h);
        const b = project3(f.b, eye, basis, w, h);
        vctx.beginPath();
        vctx.moveTo(a.sx, a.sy);
        vctx.lineTo(b.sx, b.sy);
        vctx.stroke();
      }
      vctx.restore();
    }
    if (placedTrees.length) {
      vctx.save();
      for (const t of placedTrees) {
        const q = sub(t.pos, eye);
        if (dot(q, basis.f) <= 0.04) continue;
        const p = project3(t.pos, eye, basis, w, h);
        vctx.fillStyle = '#78ffa0';
        vctx.globalAlpha = 0.95;
        vctx.beginPath();
        vctx.arc(p.sx, p.sy, 4.2, 0, Math.PI * 2);
        vctx.fill();
      }
      vctx.restore();
    }
    if (placedBoulders.length) {
      vctx.save();
      for (const r of placedBoulders) {
        const q = sub(r.pos, eye);
        if (dot(q, basis.f) <= 0.04) continue;
        const p = project3(r.pos, eye, basis, w, h);
        vctx.fillStyle = '#c9d5e6';
        vctx.globalAlpha = 0.96;
        vctx.beginPath();
        vctx.arc(p.sx, p.sy, 4.0, 0, Math.PI * 2);
        vctx.fill();
      }
      vctx.restore();
    }
    sanitizePropSelection();
    if (mode === 'propedit' || selectedProp || propHover) {
      const drawPropMarker = (sel, color, fill = false) => {
        if (!sel) return;
        if (sel.kind === 'tree') {
          const t = placedTrees[sel.i];
          if (!t) return;
          const q = sub(t.pos, eye);
          if (dot(q, basis.f) <= 0.04) return;
          const p = project3(t.pos, eye, basis, w, h);
          vctx.strokeStyle = color;
          vctx.lineWidth = 2;
          vctx.beginPath();
          vctx.arc(p.sx, p.sy, 7.5, 0, Math.PI * 2);
          fill ? vctx.fill() : vctx.stroke();
          return;
        }
        if (sel.kind === 'boulder') {
          const r = placedBoulders[sel.i];
          if (!r) return;
          const q = sub(r.pos, eye);
          if (dot(q, basis.f) <= 0.04) return;
          const p = project3(r.pos, eye, basis, w, h);
          vctx.strokeStyle = color;
          vctx.lineWidth = 2;
          vctx.beginPath();
          vctx.arc(p.sx, p.sy, 7.2, 0, Math.PI * 2);
          fill ? vctx.fill() : vctx.stroke();
          return;
        }
        const f = placedFences[sel.i];
        if (!f) return;
        const qa = sub(f.a, eye);
        const qb = sub(f.b, eye);
        if (dot(qa, basis.f) <= 0.04 || dot(qb, basis.f) <= 0.04) return;
        const a = project3(f.a, eye, basis, w, h);
        const b = project3(f.b, eye, basis, w, h);
        vctx.strokeStyle = color;
        vctx.lineWidth = 2.4;
        vctx.beginPath();
        vctx.moveTo(a.sx, a.sy);
        vctx.lineTo(b.sx, b.sy);
        vctx.stroke();
        if (sel.kind === 'fenceEndpoint') {
          const p = sel.end === 'b' ? b : a;
          vctx.beginPath();
          vctx.arc(p.sx, p.sy, 6.8, 0, Math.PI * 2);
          fill ? vctx.fill() : vctx.stroke();
        }
      };
      vctx.save();
      vctx.globalAlpha = 0.95;
      vctx.fillStyle = 'rgba(138, 215, 255, 0.22)';
      drawPropMarker(propHover, '#8ad7ff', true);
      vctx.fillStyle = 'rgba(255, 211, 110, 0.24)';
      drawPropMarker(selectedProp, '#ffd36e', true);
      vctx.restore();
    }
    if (mode === 'fenceplace' && fencePlaceStart) {
      const p = project3(fencePlaceStart, eye, basis, w, h);
      vctx.save();
      vctx.strokeStyle = '#ffd36e';
      vctx.lineWidth = 2;
      vctx.globalAlpha = 0.95;
      vctx.beginPath(); vctx.arc(p.sx, p.sy, 6.5, 0, Math.PI * 2); vctx.stroke();
      vctx.restore();
    }

    // gizmo + hover highlight + ghost
    const gs = gizmoScreen(eye, basis, w, h);
    if (gs) {
      const gizmoModeNow = (mode === 'propedit' && selectedProp) ? propGizmoMode : 'move';
      // ghost (snapped target) for X/Z
      if (gizmoGhost && (gizmoGhost.axis === 'x' || gizmoGhost.axis === 'z')) {
        const gsp = project3(gizmoGhost.pos, eye, basis, w, h);
        vctx.save();
        vctx.globalAlpha = 0.65;
        vctx.fillStyle = 'rgba(255,211,110,0.6)';
        vctx.beginPath(); vctx.arc(gsp.sx, gsp.sy, 6, 0, Math.PI * 2); vctx.fill();
        vctx.restore();
      }

      const hover = gizmoHoverAxis;
      const pick = (ax) => (ax === hover) ? 4.5 : 3;
      const alp = (ax) => (ax === hover) ? 1.0 : 0.92;

      vctx.save();
      vctx.lineCap = 'round';
      if (gizmoModeNow === 'rotate') {
        const drawRing = (axis, pts, col) => {
          vctx.globalAlpha = alp(axis);
          vctx.lineWidth = pick(axis);
          vctx.strokeStyle = col;
          vctx.beginPath();
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            if (i === 0) vctx.moveTo(p.sx, p.sy);
            else vctx.lineTo(p.sx, p.sy);
          }
          vctx.stroke();
        };
        drawRing('x', gs.rx, 'rgb(255,110,110)');
        drawRing('y', gs.ry, 'rgb(120,255,160)');
        drawRing('z', gs.rz, 'rgb(120,170,255)');
        vctx.globalAlpha = 0.95;
        vctx.fillStyle = '#ffd36e';
        vctx.beginPath(); vctx.arc(gs.center.sx, gs.center.sy, 3.6, 0, Math.PI * 2); vctx.fill();
      } else {
        // X
        vctx.globalAlpha = alp('x');
        vctx.lineWidth = pick('x');
        vctx.strokeStyle = 'rgb(255,110,110)';
        vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.px.sx, gs.px.sy); vctx.stroke();
        // Y
        vctx.globalAlpha = alp('y');
        vctx.lineWidth = pick('y');
        vctx.strokeStyle = 'rgb(120,255,160)';
        vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.py.sx, gs.py.sy); vctx.stroke();
        // Z
        vctx.globalAlpha = alp('z');
        vctx.lineWidth = pick('z');
        vctx.strokeStyle = 'rgb(120,170,255)';
        vctx.beginPath(); vctx.moveTo(gs.center.sx, gs.center.sy); vctx.lineTo(gs.pz.sx, gs.pz.sy); vctx.stroke();
        if (gizmoModeNow === 'scale') {
          const box = (p, ax) => {
            vctx.fillStyle = ax === 'x' ? 'rgb(255,110,110)' : (ax === 'y' ? 'rgb(120,255,160)' : 'rgb(120,170,255)');
            const s = ax === hover ? 7 : 6;
            vctx.globalAlpha = ax === hover ? 1 : 0.94;
            vctx.fillRect(p.sx - s * 0.5, p.sy - s * 0.5, s, s);
          };
          box(gs.px, 'x');
          box(gs.py, 'y');
          box(gs.pz, 'z');
        }
        // center dot
        vctx.globalAlpha = 1;
        vctx.fillStyle = '#ffd36e';
        vctx.beginPath(); vctx.arc(gs.center.sx, gs.center.sy, 4, 0, Math.PI * 2); vctx.fill();
      }
      vctx.restore();
    }

      renderAxisHelper(basis, w, h);
    } catch (err) {
      showErr('3D render error:\n' + String(err && err.message ? err.message : err));
      cached = null;
    }

    requestAnimationFrame(render3D);
  }

  // 3D interactions
  view.addEventListener('contextmenu', (e) => e.preventDefault());
  view.addEventListener('dblclick', () => frame3D());

  function pickControlPoint3D(sx, sy, eye, basis, w, h, maxPix = 11) {
    let best = -1;
    let bd = maxPix;
    for (let i = 0; i < points.length; i++) {
      const q = sub(points[i].pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const p = project3(points[i].pos, eye, basis, w, h);
      const d = Math.hypot(p.sx - sx, p.sy - sy);
      if (d < bd) { bd = d; best = i; }
    }
    return best;
  }

  function bezierHandleAnchor(target) {
    if (!target) return null;
    if (target.kind === 'branch') {
      const ref = branchMidRef({ sec: target.sec, mid: target.mid });
      if (!ref?.mid) return null;
      return v3(ref.mid.x, ref.mid.y, ref.mid.z);
    }
    const p = points[target.i];
    if (!p) return null;
    return p.pos;
  }

  function bezierHandleVector(target, which) {
    if (!target) return null;
    if (target.kind === 'branch') {
      const ref = branchMidRef({ sec: target.sec, mid: target.mid });
      const m = ref?.mid;
      if (!m) return null;
      const h = which === 'in' ? m.hin : m.hout;
      return h ? { x: Number(h.x || 0), z: Number(h.z || 0) } : { x: 0, z: 0 };
    }
    const p = points[target.i];
    if (!p) return null;
    ensurePointShape(p);
    const h = which === 'in' ? p.hin : p.hout;
    return { x: Number(h.x || 0), z: Number(h.z || 0) };
  }

  function bezierHandleWorldPoint(target, which) {
    if (!target) return null;
    if (target.kind === 'branch') return branchHandleWorld({ sec: target.sec, mid: target.mid }, which);
    if (!Number.isInteger(target.i)) return null;
    return handleWorld(target.i, which);
  }

  function sameBezierHandle(a, b) {
    if (a?.target) a = { ...a.target, which: a.which };
    if (b?.target) b = { ...b.target, which: b.which };
    if (!a || !b) return false;
    if ((a.kind || 'main') !== (b.kind || 'main')) return false;
    if (a.which !== b.which) return false;
    if ((a.kind || 'main') === 'branch') return a.sec === b.sec && a.mid === b.mid;
    return a.i === b.i;
  }

  function pickBezierHandle3D(sx, sy, eye, basis, w, h, maxPix = 12) {
    let best = null;
    let bd = maxPix;
    const candidates = [];
    if (selectedBranch) {
      candidates.push({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'in' });
      candidates.push({ kind: 'branch', sec: selectedBranch.sec, mid: selectedBranch.mid, which: 'out' });
    } else if (selected >= 0 && points[selected]) {
      candidates.push({ kind: 'main', i: selected, which: 'in' });
      candidates.push({ kind: 'main', i: selected, which: 'out' });
    }
    for (const c of candidates) {
      const wp = bezierHandleWorldPoint(c, c.which);
      if (!wp) continue;
      const q = sub(wp, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const sp = project3(wp, eye, basis, w, h);
      const d = Math.hypot(sp.sx - sx, sp.sy - sy);
      if (d < bd) {
        bd = d;
        best = c;
      }
    }
    return best;
  }

  function screenRay3D(sx, sy, w, h, eye, basis) {
    const fov = 60 * Math.PI / 180;
    const tan = Math.tan(fov * 0.5);
    const aspect = w / h;
    const nx = (sx / w) * 2 - 1;
    const ny = 1 - (sy / h) * 2;
    const dir = norm(add(add(basis.f, mul(basis.r, nx * aspect * tan)), mul(basis.u, ny * tan)));
    return { o: eye, d: dir };
  }

  function rayTriHit(o, d, a, b, c) {
    const eps = 1e-6;
    const ab = sub(b, a);
    const ac = sub(c, a);
    const p = cross(d, ac);
    const det = dot(ab, p);
    if (Math.abs(det) < eps) return null;
    const invDet = 1 / det;
    const tvec = sub(o, a);
    const u = dot(tvec, p) * invDet;
    if (u < 0 || u > 1) return null;
    const q = cross(tvec, ab);
    const v = dot(d, q) * invDet;
    if (v < 0 || (u + v) > 1) return null;
    const t = dot(ac, q) * invDet;
    if (t <= eps) return null;
    return { t, p: add(o, mul(d, t)) };
  }

  function pickPlacementPoint3D(sx, sy, w, h) {
    const m = getMesh();
    if (!m) return null;
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const ray = screenRay3D(sx, sy, w, h, eye, basis);

    const castKinds = (kinds) => {
      let best = null;
      for (const t of m.tris) {
        if (!kinds.has(t.kind)) continue;
        const hit = rayTriHit(ray.o, ray.d, t.a, t.b, t.c);
        if (!hit) continue;
        if (!best || hit.t < best.t) best = hit;
      }
      return best ? best.p : null;
    };

    const pTerrain = castKinds(new Set(['terrain']));
    if (pTerrain) return pTerrain;
    const pGrass = castKinds(new Set(['grass']));
    if (pGrass) return pGrass;

    if (Math.abs(ray.d.y) > 1e-6) {
      const t = (0 - ray.o.y) / ray.d.y;
      if (t > 0) return add(ray.o, mul(ray.d, t));
    }
    return null;
  }

  function pickPlacedProp3D(sx, sy, eye, basis, w, h, maxPix = 14) {
    let best = null;
    let bd = maxPix;
    const keep = (cand, d) => {
      if (d > bd) return;
      bd = d;
      best = cand;
    };

    for (let i = 0; i < placedTrees.length; i++) {
      const t = placedTrees[i];
      const q = sub(t.pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const p = project3(t.pos, eye, basis, w, h);
      keep({ kind: 'tree', i }, Math.hypot(p.sx - sx, p.sy - sy));
    }

    for (let i = 0; i < placedBoulders.length; i++) {
      const r = placedBoulders[i];
      const q = sub(r.pos, eye);
      if (dot(q, basis.f) <= 0.04) continue;
      const p = project3(r.pos, eye, basis, w, h);
      keep({ kind: 'boulder', i }, Math.hypot(p.sx - sx, p.sy - sy));
    }

    for (let i = 0; i < placedFences.length; i++) {
      const f = placedFences[i];
      const qa = sub(f.a, eye);
      const qb = sub(f.b, eye);
      if (dot(qa, basis.f) <= 0.04 || dot(qb, basis.f) <= 0.04) continue;
      const a = project3(f.a, eye, basis, w, h);
      const b = project3(f.b, eye, basis, w, h);
      const da = Math.hypot(a.sx - sx, a.sy - sy);
      const db = Math.hypot(b.sx - sx, b.sy - sy);
      keep({ kind: 'fenceEndpoint', i, end: 'a' }, da * 0.84);
      keep({ kind: 'fenceEndpoint', i, end: 'b' }, db * 0.84);
      const seg = closestPointOnScreenSegment(sx, sy, a.sx, a.sy, b.sx, b.sy);
      keep({ kind: 'fence', i }, seg.d);
    }

    return best;
  }

  function projectVisible3D(p, eye, basis, w, h, minForward = 0.04) {
    const q = sub(p, eye);
    if (dot(q, basis.f) <= minForward) return null;
    return project3(p, eye, basis, w, h);
  }

  function nearestCurveHit3D(sx, sy, eye, basis, w, h, maxPix = 12) {
    if (points.length < 2) return null;
    ensureHandles(points);
    const segs = mainConnectedSegments();
    if (!segs.length) return null;
    const steps = Math.max(10, Math.min(48, Math.round(effectiveSubdiv() * 2)));
    let best = null;

    for (const segDesc of segs) {
      const i = segDesc.a;
      const j = segDesc.b;
      const a = points[i];
      const b = points[j];
      const p0 = a.pos;
      const p1 = b.pos;
      const c0 = add(p0, v3(a.hout.x, 0, a.hout.z));
      const c1 = add(p1, v3(b.hin.x, 0, b.hin.z));
      let prev = null;
      let prevSp = null;
      let prevT = 0;
      for (let k = 0; k <= steps; k++) {
        const t = k / steps;
        const cur = bezier(p0, c0, c1, p1, t);
        const curSp = projectVisible3D(cur, eye, basis, w, h);
        if (!curSp) {
          prev = null;
          prevSp = null;
          continue;
        }
        if (prev && prevSp) {
          const hit = closestPointOnScreenSegment(sx, sy, prevSp.sx, prevSp.sy, curSp.sx, curSp.sy);
          if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
            const tmix = prevT + (t - prevT) * hit.t;
            const pos = bezier(p0, c0, c1, p1, tmix);
            const tan = bezierDeriv(p0, c0, c1, p1, tmix);
            best = {
              dist: hit.d,
              seg: segDesc.seg,
              segA: i,
              segB: j,
              t: tmix,
              pos,
              tan,
              insertIndex: segDesc.insertIndex,
              bank: (1 - tmix) * a.bank + tmix * b.bank,
            };
          }
        }
        prev = cur;
        prevSp = curSp;
        prevT = t;
      }
    }
    return best;
  }

  function nearestBranchCurveHit3D(sx, sy, eye, basis, w, h, maxPix = 12) {
    sanitizeBranchSections();
    const subdiv = effectiveSubdiv();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const sec = branchSections[si];
      const smp = sampleBranchSection(sec, subdiv);
      if (smp.length < 2) continue;
      let prev = smp[0];
      let prevSp = projectVisible3D(prev.pos, eye, basis, w, h);
      for (let i = 1; i < smp.length; i++) {
        const cur = smp[i];
        const curSp = projectVisible3D(cur.pos, eye, basis, w, h);
        if (prevSp && curSp) {
          const hit = closestPointOnScreenSegment(sx, sy, prevSp.sx, prevSp.sy, curSp.sx, curSp.sy);
          if (hit.d <= maxPix && (!best || hit.d < best.dist)) {
            const u = prev.u + (cur.u - prev.u) * hit.t;
            const pos = add(mul(prev.pos, 1 - hit.t), mul(cur.pos, hit.t));
            const tan = norm(sub(cur.pos, prev.pos));
            best = { dist: hit.d, sec: si, u, pos, tan };
          }
        }
        prev = cur;
        prevSp = curSp;
      }
    }
    return best;
  }

  function nearestBranchMidpoint3D(sx, sy, eye, basis, w, h, maxPix = 12) {
    sanitizeBranchSections();
    let best = null;
    for (let si = 0; si < branchSections.length; si++) {
      const mids = branchSections[si]?.mids || [];
      for (let mi = 0; mi < mids.length; mi++) {
        const m = mids[mi];
        const sp = projectVisible3D(v3(m.x, m.y, m.z), eye, basis, w, h);
        if (!sp) continue;
        const d = Math.hypot(sp.sx - sx, sp.sy - sy);
        if (d <= maxPix && (!best || d < best.dist)) best = { sec: si, mid: mi, dist: d };
      }
    }
    return best;
  }

  function nearestRoadAnchor3D(sx, sy, eye, basis, w, h, maxPointPix = 12, maxBranchPix = 11) {
    let best = null;
    const pi = pickControlPoint3D(sx, sy, eye, basis, w, h, maxPointPix);
    if (pi >= 0) {
      const sp = projectVisible3D(points[pi].pos, eye, basis, w, h);
      if (sp) {
        const d = Math.hypot(sp.sx - sx, sp.sy - sy);
        best = { kind: 'point', i: pi, dist: d };
      }
    }
    const bm = nearestBranchMidpoint3D(sx, sy, eye, basis, w, h, maxBranchPix);
    if (bm && (!best || bm.dist < best.dist)) best = { kind: 'branchMid', sec: bm.sec, mid: bm.mid, dist: bm.dist };
    return best;
  }

  function rayHitYPlane3D(sx, sy, w, h, eye, basis, yPlane = 0) {
    const ray = screenRay3D(sx, sy, w, h, eye, basis);
    if (Math.abs(ray.d.y) <= 1e-6) return null;
    const t = (yPlane - ray.o.y) / ray.d.y;
    if (t <= 1e-6) return null;
    return add(ray.o, mul(ray.d, t));
  }

  function beginRoadGizmoDrag3D(targetKind, sx, sy, eye, basis, w, h) {
    let P = null;
    if (targetKind === 'branch') {
      const ref = branchMidRef(selectedBranch);
      if (ref?.mid) P = v3(ref.mid.x, ref.mid.y, ref.mid.z);
    } else {
      if (selected >= 0 && points[selected]) P = v3(points[selected].pos.x, points[selected].pos.y, points[selected].pos.z);
    }
    if (!P) return false;
    const gsNow = gizmoScreen(eye, basis, w, h);
    const ctr = gsNow?.center || project3(P, eye, basis, w, h);
    pushUndo();
    bezier3DDrag = null;
    gizmo.active = true;
    gizmo.target = targetKind === 'branch' ? 'branch' : 'point';
    gizmo.mode = 'move';
    gizmo.axis = 'free';
    gizmo.startMouse = { x: sx, y: sy };
    gizmo.startPos = v3(P.x, P.y, P.z);
    gizmo.startProp = null;
    gizmo.startSel = null;
    gizmo.depth = Math.max(0.2, ctr?.z || 1);
    gizmo.startCenter = ctr;
    gizmo.startSize = Math.max(1.5, gsNow?.size || len(sub(P, eye)) * 0.085);
    gizmo.startAxisPt = gsNow?.px || { sx: ctr.sx + 1, sy: ctr.sy };
    gizmoGhost = null;
    view.style.cursor = 'grabbing';
    return true;
  }

  function handleRoadToolClick3D(e, sx, sy, eye, basis, w, h) {
    if (mode === 'propedit' || mode === 'treeplace' || mode === 'fenceplace' || mode === 'boulderplace') return false;
    const activeRoadTool = mode === 'draw' || mode === 'move' || mode === 'erase' || mode === 'join' || mode === 'ysplit' || mode === 'roundabout';
    if (!activeRoadTool) return false;
    const modsMulti = e.shiftKey || e.ctrlKey || e.metaKey;
    const anchor = nearestRoadAnchor3D(sx, sy, eye, basis, w, h, 12, 11);
    const hitPoint = anchor?.kind === 'point' ? anchor.i : -1;
    const hitBranchMid = anchor?.kind === 'branchMid' ? { sec: anchor.sec, mid: anchor.mid } : null;

    if (mode === 'ysplit') {
      if (ySplitTool.phase === 0) {
        if (hitPoint < 0) {
          const curveHit = nearestCurveHit3D(sx, sy, eye, basis, w, h, 12);
          if (!curveHit) return true;
          pushUndo();
          const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
          const prevIdx = Number.isInteger(curveHit.segA) ? curveHit.segA : (curveHit.insertIndex - 1 + points.length) % points.length;
          const nextIdx = Number.isInteger(curveHit.segB) ? curveHit.segB : (curveHit.insertIndex % points.length);
          const prevPos = points[prevIdx]?.pos || curveHit.pos;
          const nextPos = points[nextIdx]?.pos || curveHit.pos;
          const hIn = Math.max(0.05, len(sub(curveHit.pos, prevPos)) * 0.30);
          const hOut = Math.max(0.05, len(sub(nextPos, curveHit.pos)) * 0.30);
          const np = {
            pos: v3(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z),
            bank: curveHit.bank,
            node: 'smooth',
            hin: { x: -tan.x * hIn, z: -tan.z * hIn },
            hout: { x: tan.x * hOut, z: tan.z * hOut },
          };
          points.splice(curveHit.insertIndex, 0, np);
          remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
          const idx = curveHit.insertIndex;
          smoothNeighborhood([idx - 1, idx, idx + 1]);
          selectOnly(idx);
          ySplitTool.phase = 1;
          ySplitTool.startIdx = idx;
          ySplitTool.action = 'split';
          syncSelectedUI();
          bumpSceneVersion();
          return true;
        }
        ySplitTool.phase = 1;
        ySplitTool.startIdx = hitPoint;
        ySplitTool.action = (e.ctrlKey || e.metaKey) ? 'trim' : (e.altKey ? 'join' : 'split');
        selectOnly(hitPoint);
        syncSelectedUI();
        return true;
      }
      if (ySplitTool.startIdx >= 0) {
        if (hitPoint >= 0) {
          pushUndo();
          if (ySplitTool.action === 'split' && ySplitTool.startIdx === hitPoint) splitPointForFork(hitPoint);
          else if (ySplitTool.startIdx !== hitPoint) {
            if (ySplitTool.action === 'trim') trimSection(ySplitTool.startIdx, hitPoint);
            else if (ySplitTool.action === 'join') joinSection(ySplitTool.startIdx, hitPoint);
            else addBranchSection(ySplitTool.startIdx, hitPoint, 'fork');
          }
          ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
          syncSelectedUI();
          bumpSceneVersion();
        }
      }
      return true;
    }

    if (mode === 'join') {
      if (hitPoint < 0) return true;
      if (joinTool.phase === 0) {
        joinTool.phase = 1;
        joinTool.startIdx = hitPoint;
        selectOnly(hitPoint);
        syncSelectedUI();
        return true;
      }
      if (joinTool.startIdx >= 0 && joinTool.startIdx !== hitPoint) {
        pushUndo();
        joinSection(joinTool.startIdx, hitPoint);
        joinTool = { phase: 0, startIdx: -1 };
        syncSelectedUI();
        bumpSceneVersion();
      }
      return true;
    }

    if (mode === 'roundabout') {
      if (roundTool.phase === 0) {
        if (hitPoint < 0) return true;
        roundTool.phase = 1;
        roundTool.startIdx = hitPoint;
        roundTool.isSizing = true;
        selectOnly(hitPoint);
        syncSelectedUI();
        const S = points[hitPoint].pos;
        const T = tangentAtIndex(hitPoint);
        const N = norm(v3(-T.z, 0, T.x));
        const r0 = Math.max(3.2, num('roadWidth') * 2.45);
        roundTool.radius = r0;
        roundTool.dir = 1;
        const c0 = add(S, mul(N, r0));
        const c0s = snapRoadXZ(c0.x, c0.z);
        roundTool.center = v3(c0s.x, S.y, c0s.z);
        roundTool.previewExit = null;
        return true;
      }
      if (roundTool.phase === 2 && roundTool.center) {
        const sy0 = points[roundTool.startIdx]?.pos.y || 0;
        const wp = rayHitYPlane3D(sx, sy, w, h, eye, basis, sy0);
        if (!wp) return true;
        const ex = snapRoadXZ(wp.x, wp.z);
        const exit = { x: ex.x, z: ex.z };
        const exitAng = Math.atan2(exit.z - roundTool.center.z, exit.x - roundTool.center.x);
        pushUndo();
        insertRoundaboutAt(roundTool.startIdx, roundTool.center, roundTool.radius, exitAng, roundTool.dir);
        roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
        setTool('draw');
        syncSelectedUI();
        bumpSceneVersion();
      }
      return true;
    }

    if (mode === 'erase') {
      if (hitBranchMid) {
        pushUndo();
        const mids = branchSections[hitBranchMid.sec]?.mids;
        if (Array.isArray(mids) && mids[hitBranchMid.mid]) mids.splice(hitBranchMid.mid, 1);
        sanitizeBranchSections();
        selectedBranch = null;
        selectedBranchSet.clear();
        syncSelectedUI();
        bumpSceneVersion();
        return true;
      }
      if (hitPoint >= 0) {
        pushUndo();
        points.splice(hitPoint, 1);
        remapSplitEndsForSplice(hitPoint, 1, 0);
        selectOnly(-1);
        syncSelectedUI();
        bumpSceneVersion();
        return true;
      }
      const hitBranchCurve = nearestBranchCurveHit3D(sx, sy, eye, basis, w, h, 12);
      if (hitBranchCurve) {
        pushUndo();
        branchSections.splice(hitBranchCurve.sec, 1);
        sanitizeBranchSections();
        selectedBranch = null;
        selectedBranchSet.clear();
        syncSelectedUI();
        bumpSceneVersion();
      }
      return true;
    }

    if (hitBranchMid) {
      if (modsMulti) toggleBranchSelection(hitBranchMid.sec, hitBranchMid.mid);
      else if (!selectedBranchSet.has(branchSelKey(hitBranchMid.sec, hitBranchMid.mid)) || selectedBranchSet.size <= 1) selectBranchMidpoint(hitBranchMid.sec, hitBranchMid.mid);
      syncSelectedUI();
      if (!modsMulti && mode === 'move') beginRoadGizmoDrag3D('branch', sx, sy, eye, basis, w, h);
      return true;
    }

    if (hitPoint >= 0) {
      if (modsMulti) {
        toggleSelection(hitPoint);
        if (mode === 'draw') setDrawAnchor(hitPoint);
        if (mode === 'draw') drawTool.pendingNewLine = false;
        syncSelectedUI();
        return true;
      }
      if (mode === 'draw') {
        const anchorIdx = sanitizeDrawAnchor();
        if (anchorIdx >= 0 && anchorIdx !== hitPoint) {
          pushUndo();
          const didJoin = joinSection(anchorIdx, hitPoint);
          if (didJoin) {
            setDrawAnchor(selected >= 0 ? selected : hitPoint);
            bumpSceneVersion();
          } else {
            selectOnly(hitPoint);
            setDrawAnchor(hitPoint);
          }
          drawTool.pendingNewLine = false;
        } else {
          selectOnly(hitPoint);
          setDrawAnchor(hitPoint);
          drawTool.pendingNewLine = false;
        }
        syncSelectedUI();
        return true;
      }
      if (!selectedSet.has(hitPoint) || selectedSet.size <= 1) selectOnly(hitPoint);
      syncSelectedUI();
      if (mode === 'move') beginRoadGizmoDrag3D('point', sx, sy, eye, basis, w, h);
      return true;
    }

    if (mode === 'draw') {
      pushUndo();
      const curveHit = nearestCurveHit3D(sx, sy, eye, basis, w, h, 12);
      if (curveHit) {
        const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
        const snapped = snapRoadXYZ(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z);
        const insPos = v3(snapped.x, snapped.y, snapped.z);
        const prevIdx = Number.isInteger(curveHit.segA) ? curveHit.segA : (curveHit.insertIndex - 1 + points.length) % points.length;
        const nextIdx = Number.isInteger(curveHit.segB) ? curveHit.segB : (curveHit.insertIndex % points.length);
        const prevPos = points[prevIdx]?.pos || insPos;
        const nextPos = points[nextIdx]?.pos || insPos;
        const hIn = Math.max(0.05, len(sub(insPos, prevPos)) * 0.30);
        const hOut = Math.max(0.05, len(sub(nextPos, insPos)) * 0.30);
        const np = {
          pos: insPos,
          bank: curveHit.bank,
          node: 'smooth',
          hin: { x: -tan.x * hIn, z: -tan.z * hIn },
          hout: { x: tan.x * hOut, z: tan.z * hOut },
        };
        points.splice(curveHit.insertIndex, 0, np);
        remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
        const idx = curveHit.insertIndex;
        smoothNeighborhood([idx - 1, idx, idx + 1]);
        selectOnly(idx);
        setDrawAnchor(idx);
        drawTool.pendingNewLine = false;
      } else {
        const branchHit = nearestBranchCurveHit3D(sx, sy, eye, basis, w, h, 12);
        if (branchHit) {
          insertBranchMidpoint(branchHit.sec, branchHit.u, branchHit.pos, branchHit.tan);
          drawTool.pendingNewLine = false;
        } else {
          const anchorIdx = sanitizeDrawAnchor();
          const yRef = anchorIdx >= 0 && points[anchorIdx] ? points[anchorIdx].pos.y : (selected >= 0 && points[selected] ? points[selected].pos.y : 0);
          const wp = rayHitYPlane3D(sx, sy, w, h, eye, basis, yRef);
          if (!wp) return true;
          const snap = snapRoadXYZ(wp.x, yRef, wp.z);
          addDrawPointAt(snap, yRef);
        }
      }
      syncSelectedUI();
      bumpSceneVersion();
      return true;
    }

    return true;
  }

  view.addEventListener('mousemove', (e) => {
    // hover axis + cursor
    const rect = view.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const r2 = viewWrap.getBoundingClientRect();
    const w = r2.width, h = r2.height;
    lastViewMouse = { sx, sy, w, h };
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const gs = gizmoScreen(eye, basis, w, h);

    if (mode === 'roundabout' && roundTool.phase >= 1 && roundTool.startIdx >= 0 && points[roundTool.startIdx]) {
      const S = points[roundTool.startIdx].pos;
      const wp = rayHitYPlane3D(sx, sy, w, h, eye, basis, S.y);
      if (wp) {
        const v = v3(wp.x - S.x, 0, wp.z - S.z);
        if (roundTool.isSizing || roundTool.phase === 1) {
          const T = tangentAtIndex(roundTool.startIdx);
          const N = norm(v3(-T.z, 0, T.x));
          const sign = dot(v, N) >= 0 ? 1 : -1;
          const r = clamp(Math.hypot(v.x, v.z), Math.max(3.2, num('roadWidth') * 2.05), 45);
          roundTool.radius = r;
          roundTool.dir = sign;
          const c = add(S, mul(N, sign * r));
          const cs = snapRoadXZ(c.x, c.z);
          roundTool.center = v3(cs.x, S.y, cs.z);
          roundTool.previewExit = null;
        } else if (roundTool.phase === 2 && roundTool.center) {
          const ex = snapRoadXZ(wp.x, wp.z);
          roundTool.previewExit = { x: ex.x, z: ex.z };
        }
      }
      if (roundTool.isSizing && !(isLookL || isLookR || isPan3 || isOrbitSel || gizmo.active || !!bezier3DDrag)) {
        view.style.cursor = 'crosshair';
      }
    }

    if (bezier3DDrag) {
      const anchor = bezierHandleAnchor(bezier3DDrag.target);
      const vec0 = { x: bezier3DDrag.startHX, z: bezier3DDrag.startHZ };
      if (!anchor) {
        bezier3DDrag = null;
      } else {
        let hx = vec0.x;
        let hz = vec0.z;
        const ray = screenRay3D(sx, sy, w, h, eye, basis);
        if (Math.abs(ray.d.y) > 1e-6) {
          const tPlane = (anchor.y - ray.o.y) / ray.d.y;
          if (tPlane > 1e-6) {
            const hit = add(ray.o, mul(ray.d, tPlane));
            hx = hit.x - anchor.x;
            hz = hit.z - anchor.z;
          } else {
            const mdx = sx - bezier3DDrag.startMouse.x;
            const mdy = sy - bezier3DDrag.startMouse.y;
            const pp = worldPerPixel(Math.max(0.2, bezier3DDrag.depth || 1), h);
            const drag = add(mul(basis.r, mdx * pp), mul(basis.u, -mdy * pp));
            hx += drag.x;
            hz += drag.z;
          }
        }
        setHandle(bezier3DDrag.target, bezier3DDrag.which, hx, hz, {
          rotateOnly: e.altKey,
          breakMirror: e.shiftKey,
        });
        bezier3DHover = { ...bezier3DDrag.target, which: bezier3DDrag.which };
        syncSelectedUI();
        bumpSceneVersion();
        view.style.cursor = 'grabbing';
        return;
      }
    }

    if (gizmo.active) {
      const axisPt = gizmo.startAxisPt;
      const c = gizmo.startCenter;
      const vx = axisPt.sx - c.sx, vy = axisPt.sy - c.sy;
      const vv = vx * vx + vy * vy || 1;
      const mdx = sx - gizmo.startMouse.x, mdy = sy - gizmo.startMouse.y;
      const t = (mdx * vx + mdy * vy) / vv;
      const delta = t * gizmo.startSize * dragFineScale(e);

      if (gizmo.target === 'prop') {
        const sel = gizmo.startSel ? clonePropSel(gizmo.startSel) : clonePropSel(selectedProp);
        const start = gizmo.startProp;
        if (!sel || !start) {
          gizmo.active = false;
          gizmo.target = null;
          gizmo.mode = 'move';
          gizmo.axis = null;
          gizmo.startProp = null;
          gizmo.startSel = null;
        } else {
          const modeNow = gizmo.mode || 'move';
          if (modeNow === 'move') {
            let dv = v3(0, 0, 0);
            if (gizmo.axis === 'x') dv = v3(delta, 0, 0);
            else if (gizmo.axis === 'y') dv = v3(0, delta, 0);
            else if (gizmo.axis === 'z') dv = v3(0, 0, delta);
            else {
              const pp = worldPerPixel(Math.max(0.2, gizmo.depth), h) * dragFineScale(e);
              dv = add(mul(basis.r, mdx * pp), mul(basis.u, -mdy * pp));
            }
            applyPropTranslate(sel, start, dv);
          } else if (modeNow === 'rotate') {
            const rotScale = 0.80;
            applyPropRotate(sel, start, gizmo.axis, delta * rotScale);
          } else {
            const scaleFactor = clamp(1 + delta * 0.45, 0.1, 12);
            applyPropScale(sel, start, scaleFactor);
          }
          gizmoGhost = null;
        }
      } else {
        const isBranchTarget = gizmo.target === 'branch';
        const ref = isBranchTarget ? branchMidRef(selectedBranch) : null;
        const p = isBranchTarget ? ref?.mid : (selected >= 0 && points[selected] ? points[selected].pos : null);
        if (!p) {
          gizmo.active = false;
          gizmo.target = null;
          gizmo.mode = 'move';
          gizmo.axis = null;
          gizmo.startProp = null;
          gizmo.startSel = null;
          gizmoGhost = null;
          return;
        }
        const snapDrag = shouldSnap3DDrag(e);
        if (gizmo.axis === 'x') {
          const xRaw = gizmo.startPos.x + delta;
          p.x = snapDrag ? snapRoadXZ(xRaw, p.z).x : xRaw;
          gizmoGhost = { axis: 'x', pos: v3(p.x, p.y, p.z) };
        } else if (gizmo.axis === 'y') {
          const yRaw = gizmo.startPos.y + delta;
          p.y = snapDrag ? snapRoadY(yRaw) : yRaw;
          gizmoGhost = null;
        } else if (gizmo.axis === 'z') {
          const zRaw = gizmo.startPos.z + delta;
          p.z = snapDrag ? snapRoadXZ(p.x, zRaw).z : zRaw;
          gizmoGhost = { axis: 'z', pos: v3(p.x, p.y, p.z) };
        } else if (gizmo.axis === 'free') {
          const pp = worldPerPixel(Math.max(0.2, gizmo.depth), h) * dragFineScale(e);
          const drag = add(mul(basis.r, mdx * pp), mul(basis.u, -mdy * pp));
          const xRaw = gizmo.startPos.x + drag.x;
          const yRaw = gizmo.startPos.y + drag.y;
          const zRaw = gizmo.startPos.z + drag.z;
          if (snapDrag) {
            const sp = snapRoadXYZ(xRaw, yRaw, zRaw);
            p.x = sp.x;
            p.y = sp.y;
            p.z = sp.z;
          } else {
            p.x = xRaw;
            p.y = yRaw;
            p.z = zRaw;
          }
          gizmoGhost = { axis: 'free', pos: v3(p.x, p.y, p.z) };
        }
      }
      syncSelectedUI();
      bumpSceneVersion();
      view.style.cursor = 'grabbing';
      return;
    }

    if (mode === 'propedit') {
      bezier3DHover = null;
      propHover = pickPlacedProp3D(sx, sy, eye, basis, w, h, 14);
      const gMode = selectedProp ? propGizmoMode : 'move';
      gizmoHoverAxis = hitGizmoAxis(gs, sx, sy, gMode);
      if (isLookL || isLookR || isPan3 || isOrbitSel) view.style.cursor = 'grabbing';
      else if (gizmoHoverAxis) view.style.cursor = 'grab';
      else view.style.cursor = propHover ? 'pointer' : 'default';
      if (!(isLookL || isLookR || isPan3 || isOrbitSel)) return;
    } else {
      propHover = null;
    }

    if (mode !== 'propedit') {
      bezier3DHover = pickBezierHandle3D(sx, sy, eye, basis, w, h, 12);
      if (bezier3DHover) {
        gizmoHoverAxis = null;
        view.style.cursor = 'grab';
      } else {
        gizmoHoverAxis = hitGizmoAxis(gs, sx, sy, 'move');
        if (gizmoHoverAxis) view.style.cursor = 'grab';
      }
      if (bezier3DHover || gizmoHoverAxis) {
        if (!(isLookL || isLookR || isPan3 || isOrbitSel)) return;
      }
      else if (isLookL || isLookR || isPan3 || isOrbitSel) view.style.cursor = 'grabbing';
      else if (mode === 'treeplace' || mode === 'fenceplace' || mode === 'boulderplace' || mode === 'draw' || mode === 'move' || mode === 'erase' || mode === 'join' || mode === 'ysplit' || mode === 'roundabout') view.style.cursor = 'crosshair';
      else view.style.cursor = 'default';
    }

    if (isOrbitSel && last3 && selected >= 0 && points[selected]) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      const pivot = points[selected].pos;
      const off = sub(camEye, pivot);
      const rxy = Math.max(1e-3, Math.hypot(off.x, off.z));
      let ay = Math.atan2(off.z, off.x);
      let ap = Math.atan2(off.y, rxy);
      ay -= dx * 0.008;
      ap = clamp(ap - dy * 0.008, -1.43, 1.43);
      const dist = Math.max(0.3, len(off));
      const cx = Math.cos(ay) * Math.cos(ap), sz = Math.sin(ay) * Math.cos(ap), sy = Math.sin(ap);
      camEye = add(pivot, v3(cx * dist, sy * dist, sz * dist));
      setCameraLookAt(camEye, pivot);
      last3 = { x: e.clientX, y: e.clientY };
      return;
    }

    if ((isLookR || isLookL) && last3) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      if (Math.hypot(dx, dy) > 1.3) lmbMoved = lmbMoved || isLookL;
      camYaw -= dx * 0.008;
      camPitch = clamp(camPitch - dy * 0.008, -1.48, 1.48);
      last3 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (isPan3 && last3) {
      const dx = e.clientX - last3.x;
      const dy = e.clientY - last3.y;
      if (Math.hypot(dx, dy) > 1.3) mmbMoved = true;
      const depthRef = Math.max(6, len(sub(camEye, selected >= 0 && points[selected] ? points[selected].pos : add(camEye, basis.f))));
      const s = worldPerPixel(depthRef, h) * 1.25;
      camEye = add(camEye, add(mul(basis.r, -dx * s), mul(basis.u, dy * s)));
      last3 = { x: e.clientX, y: e.clientY };
    }
  });

  view.addEventListener('mousedown', (e) => {
    const rect = view.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const r2 = viewWrap.getBoundingClientRect();
    const w = r2.width, h = r2.height;
    lastViewMouse = { sx, sy, w, h };
    const eye = camPos();
    const target = add(eye, camForward());
    const basis = lookAtBasis(eye, target);
    const gs = gizmoScreen(eye, basis, w, h);

    if (e.button === 0) {
      if (mode === 'treeplace' || mode === 'fenceplace' || mode === 'boulderplace') {
        const hit = pickPlacementPoint3D(sx, sy, w, h);
        if (!hit) return;
        if (mode === 'treeplace') {
          pushUndo();
          clearPropSelection();
          placedTrees.push({ pos: v3(hit.x, hit.y, hit.z), scale: 1, rot: { x: 0, y: hash01(hit.x * 0.11 + hit.z * 0.17) * Math.PI * 2, z: 0 } });
          bumpSceneVersion();
          syncSelectedUI();
          return;
        }
        if (mode === 'boulderplace') {
          pushUndo();
          clearPropSelection();
          const seed = hash01(hit.x * 0.173 + hit.z * 0.319 + Date.now() * 0.0001);
          placedBoulders.push({ pos: v3(hit.x, hit.y, hit.z), scale: 1, seed, rot: { x: 0, y: seed * Math.PI * 2, z: 0 } });
          bumpSceneVersion();
          syncSelectedUI();
          return;
        }
        if (!fencePlaceStart) {
          fencePlaceStart = v3(hit.x, hit.y, hit.z);
          return;
        }
        const d = Math.hypot(hit.x - fencePlaceStart.x, hit.z - fencePlaceStart.z);
        if (d >= 0.8) {
          pushUndo();
          clearPropSelection();
          placedFences.push({ a: v3(fencePlaceStart.x, fencePlaceStart.y, fencePlaceStart.z), b: v3(hit.x, hit.y, hit.z) });
          fencePlaceStart = v3(hit.x, hit.y, hit.z); // chain placement
          bumpSceneVersion();
          syncSelectedUI();
        }
        return;
      }

      if (mode === 'propedit') {
        sanitizePropSelection();
        const gHit = selectedProp ? hitGizmoAxis(gs, sx, sy, propGizmoMode) : null;
        if (gHit && selectedProp) {
          const start = capturePropTransform(selectedProp);
          if (start) {
            pushUndo();
            gizmo.active = true;
            gizmo.target = 'prop';
            gizmo.mode = propGizmoMode;
            gizmo.axis = gHit;
            gizmo.startMouse = { x: sx, y: sy };
            gizmo.startPos = propPivot(selectedProp);
            gizmo.startProp = start;
            gizmo.startSel = clonePropSel(selectedProp);
            gizmo.depth = gs ? gs.depth : 1;
            gizmo.startCenter = gs.center;
            gizmo.startSize = gs.size;
            gizmo.startAxisPt = gHit === 'x' ? gs.px : (gHit === 'y' ? gs.py : (gHit === 'z' ? gs.pz : gs.px));
            gizmoGhost = null;
            view.style.cursor = 'grabbing';
          }
          return;
        }
        const hitProp = pickPlacedProp3D(sx, sy, eye, basis, w, h, 14);
        if (hitProp) {
          setSelectedProp(hitProp);
          syncSelectedUI();
          view.style.cursor = 'pointer';
          return;
        }
        clearPropSelection();
        syncSelectedUI();
        isLookL = true;
        lmbMoved = false;
        last3 = { x: e.clientX, y: e.clientY };
        pickOnRelease = -1;
        view.style.cursor = 'grabbing';
        return;
      }

      const bezHit = pickBezierHandle3D(sx, sy, eye, basis, w, h, 12);
      if (bezHit) {
        const hv = bezierHandleVector(bezHit, bezHit.which);
        const an = bezierHandleAnchor(bezHit);
        if (!hv) return;
        if (!an) return;
        pushUndo();
        bezier3DDrag = {
          target: bezHit.kind === 'branch'
            ? { kind: 'branch', sec: bezHit.sec, mid: bezHit.mid }
            : { kind: 'main', i: bezHit.i },
          which: bezHit.which,
          depth: project3(an, eye, basis, w, h).z,
          startMouse: { x: sx, y: sy },
          startHX: hv.x,
          startHZ: hv.z,
        };
        bezier3DHover = { ...bezHit };
        view.style.cursor = 'grabbing';
        return;
      }

      const hit = hitGizmoAxis(gs, sx, sy, 'move');
      const hasBranchSel = !!branchMidRef(selectedBranch);
      if (hit && (selected >= 0 || hasBranchSel)) {
        const targetKind = (selected >= 0) ? 'point' : 'branch';
        const pRef = targetKind === 'point'
          ? points[selected]?.pos
          : (() => {
            const ref = branchMidRef(selectedBranch);
            return ref?.mid ? v3(ref.mid.x, ref.mid.y, ref.mid.z) : null;
          })();
        if (!pRef) return;
        pushUndo();
        bezier3DDrag = null;
        gizmo.active = true;
        gizmo.target = targetKind;
        gizmo.mode = 'move';
        gizmo.axis = hit;
        gizmo.startMouse = { x: sx, y: sy };
        gizmo.startPos = v3(pRef.x, pRef.y, pRef.z);
        gizmo.startProp = null;
        gizmo.startSel = null;
        gizmo.depth = gs ? gs.depth : Math.max(0.2, project3(pRef, eye, basis, w, h).z || 1);
        gizmo.startCenter = gs?.center || project3(pRef, eye, basis, w, h);
        gizmo.startSize = gs?.size || Math.max(1.5, len(sub(pRef, eye)) * 0.085);
        gizmo.startAxisPt = hit === 'x' ? gs?.px : (hit === 'y' ? gs?.py : (hit === 'z' ? gs?.pz : gs?.px));
        if (!gizmo.startAxisPt) gizmo.startAxisPt = { sx: gizmo.startCenter.sx + 1, sy: gizmo.startCenter.sy };
        gizmoGhost = null;
        view.style.cursor = 'grabbing';
        return;
      }
      if (handleRoadToolClick3D(e, sx, sy, eye, basis, w, h)) return;
      isLookL = true;
      lmbMoved = false;
      last3 = { x: e.clientX, y: e.clientY };
      pickOnRelease = mode === 'propedit' ? -1 : pickControlPoint3D(sx, sy, eye, basis, w, h, 12);
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 2 && mode === 'fenceplace' && fencePlaceStart && !e.altKey) {
      fencePlaceStart = null;
      return;
    }

    if (e.button === 2 && e.altKey && selected >= 0 && points[selected]) {
      isOrbitSel = true;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 2) {
      isLookR = true;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }

    if (e.button === 1 || isSpace()) {
      isPan3 = true;
      mmbMoved = false;
      last3 = { x: e.clientX, y: e.clientY };
      view.style.cursor = 'grabbing';
      return;
    }
  });

  window.addEventListener('mouseup', () => {
    if (bezier3DDrag) {
      bezier3DDrag = null;
      bumpSceneVersion();
    }
    if (gizmo.active) {
      gizmo.active = false;
      gizmo.target = null;
      gizmo.mode = 'move';
      gizmo.axis = null;
      gizmo.startProp = null;
      gizmo.startSel = null;
      gizmoGhost = null;
      bumpSceneVersion();
    }
    if (isLookL && !lmbMoved && pickOnRelease >= 0) {
      selectOnly(pickOnRelease);
      syncSelectedUI();
    }
    if (isPan3 && !mmbMoved) camMoveSpeed = camSpeedBase;
    isLookL = false;
    isLookR = false;
    isOrbitSel = false;
    isPan3 = false;
    last3 = null;
    lmbMoved = false;
    mmbMoved = false;
    pickOnRelease = -1;
  });

  view.addEventListener('mouseleave', () => {
    lastViewMouse = null;
    if (!gizmo.active && !bezier3DDrag && !isLookL && !isLookR && !isPan3 && !isOrbitSel) {
      bezier3DHover = null;
      gizmoHoverAxis = null;
      propHover = null;
      view.style.cursor = 'default';
    }
  });

  view.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (isLookR || (e.buttons & 2)) {
      if (e.deltaY < 0) camMoveSpeed = clamp(camMoveSpeed * 1.14, 1, 180);
      else camMoveSpeed = clamp(camMoveSpeed / 1.14, 1, 180);
      return;
    }
    // keep wheel dolly for convenience when not in RMB-speed mode
    const basis = lookAtBasis(camEye, add(camEye, camForward()));
    camEye = add(camEye, mul(basis.f, -e.deltaY * 0.018));
  }, { passive: false });

  // ---------- 2D render ----------
  function render2D() {
    if (editCard.classList.contains('hidden')) {
      requestAnimationFrame(render2D);
      return;
    }
    const r = editWrap.getBoundingClientRect();
    const w = r.width, h = r.height;
    const s = num('isoScale');
    const org = origin2();

    ectx.clearRect(0, 0, w, h);
    ectx.fillStyle = '#0b0f19';
    ectx.fillRect(0, 0, w, h);

    if (chk('showGrid')) {
      ectx.save();
      ectx.globalAlpha = 0.2;
      ectx.strokeStyle = '#24345f';
      ectx.lineWidth = 1;
      const gridStep = Math.max(0.5, num('grid'));
      const span = 80;
      for (let i = -span; i <= span; i += gridStep) {
        const a0 = screenFromWorld2(v3(i, 0, -span), org, s);
        const a1 = screenFromWorld2(v3(i, 0, span), org, s);
        const b0 = screenFromWorld2(v3(-span, 0, i), org, s);
        const b1 = screenFromWorld2(v3(span, 0, i), org, s);
        ectx.beginPath(); ectx.moveTo(a0.x, a0.y); ectx.lineTo(a1.x, a1.y); ectx.stroke();
        ectx.beginPath(); ectx.moveTo(b0.x, b0.y); ectx.lineTo(b1.x, b1.y); ectx.stroke();
      }
      ectx.restore();
    }

    const project2DPolyline = (samples) => {
      if (!Array.isArray(samples) || samples.length < 2) return null;
      const pts = [];
      const cum = [0];
      let total = 0;
      for (let i = 0; i < samples.length; i++) {
        const sp = screenFromWorld2(samples[i].pos, org, s);
        pts.push(sp);
        if (i > 0) {
          total += Math.hypot(sp.x - pts[i - 1].x, sp.y - pts[i - 1].y);
          cum.push(total);
        }
      }
      if (total < 1e-4) return null;
      return { pts, cum, total };
    };
    const sampleProjectedAt = (proj, dist) => {
      if (!proj || !proj.pts || proj.pts.length < 2) return null;
      const d = clamp(dist, 0, proj.total);
      let i = 1;
      while (i < proj.cum.length && proj.cum[i] < d) i++;
      i = clamp(i, 1, proj.pts.length - 1);
      const d0 = proj.cum[i - 1];
      const d1 = proj.cum[i];
      const segLen = Math.max(1e-6, d1 - d0);
      const t = clamp((d - d0) / segLen, 0, 1);
      const a = proj.pts[i - 1];
      const b = proj.pts[i];
      const x = a.x * (1 - t) + b.x * t;
      const y = a.y * (1 - t) + b.y * t;
      const tx = (b.x - a.x) / segLen;
      const ty = (b.y - a.y) / segLen;
      return { x, y, tx, ty };
    };
    const drawArrowGlyph2D = (x, y, tx, ty, col, alpha = 0.9, normalOffset = 0, size = 7.5) => {
      const m = Math.hypot(tx, ty) || 1;
      const ux = tx / m, uy = ty / m;
      const nx = -uy, ny = ux;
      const ox = x + nx * normalOffset;
      const oy = y + ny * normalOffset;
      const tipX = ox + ux * size;
      const tipY = oy + uy * size;
      const tailX = ox - ux * size * 0.8;
      const tailY = oy - uy * size * 0.8;
      const wing = size * 0.50;
      ectx.save();
      ectx.globalAlpha = alpha;
      ectx.strokeStyle = col;
      ectx.fillStyle = col;
      ectx.lineWidth = 1.15;
      ectx.beginPath();
      ectx.moveTo(tailX, tailY);
      ectx.lineTo(tipX, tipY);
      ectx.stroke();
      ectx.beginPath();
      ectx.moveTo(tipX, tipY);
      ectx.lineTo(tipX - ux * size * 0.72 + nx * wing, tipY - uy * size * 0.72 + ny * wing);
      ectx.lineTo(tipX - ux * size * 0.72 - nx * wing, tipY - uy * size * 0.72 - ny * wing);
      ectx.closePath();
      ectx.fill();
      ectx.restore();
    };
    const drawLaneFlowOverlay = (samples, spec, col, labelPrefix = '') => {
      if (!spec || !Array.isArray(samples) || samples.length < 2) return;
      const proj = project2DPolyline(samples);
      if (!proj) return;
      const arrowCount = clamp(Math.floor(proj.total / 118), 1, 10);
      const placeArrows = (forward = true, offset = 0, alpha = 0.9) => {
        for (let i = 1; i <= arrowCount; i++) {
          const baseDist = proj.total * (i / (arrowCount + 1));
          const d = forward ? baseDist : (proj.total - baseDist);
          const hit = sampleProjectedAt(proj, d);
          if (!hit) continue;
          const tx = forward ? hit.tx : -hit.tx;
          const ty = forward ? hit.ty : -hit.ty;
          drawArrowGlyph2D(hit.x, hit.y, tx, ty, col, alpha, offset, 7.4);
        }
      };
      if (spec.direction === 'two_way') {
        placeArrows(true, 3.2, 0.90);
        placeArrows(false, -3.2, 0.58);
      } else if (spec.direction === 'b_to_a') {
        placeArrows(false, 0, 0.96);
      } else {
        placeArrows(true, 0, 0.96);
      }

      const mid = sampleProjectedAt(proj, proj.total * 0.5);
      if (!mid) return;
      const nx = -mid.ty;
      const ny = mid.tx;
      const lx = mid.x + nx * 10;
      const ly = mid.y + ny * 10;
      const lanesText = spec.direction === 'two_way'
        ? `${spec.lanesForward}/${spec.lanesReverse}`
        : `${spec.direction === 'a_to_b' ? '>' : '<'}${spec.lanesForward}`;
      const label = `${labelPrefix ? `${labelPrefix} ` : ''}${lanesText}`;
      ectx.save();
      ectx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      ectx.textAlign = 'center';
      ectx.textBaseline = 'middle';
      const tw = ectx.measureText(label).width + 7;
      ectx.fillStyle = 'rgba(11,15,25,0.72)';
      ectx.fillRect(lx - tw * 0.5, ly - 6.4, tw, 12.8);
      ectx.fillStyle = col;
      ectx.fillText(label, lx, ly);
      ectx.restore();
    };
    const drawJunctionControlOverlay = (desc) => {
      if (!desc?.junctions?.length) return;
      const typeColor = {
        stop: '#9fb3c8',
        signal: '#ffd36e',
        roundabout: '#7ed0ff',
        rcut: '#ffad7e',
        mut: '#ffcf7e',
        dlt: '#ffc07f',
        ddi: '#a8d8ff',
        ramp_terminal: '#d2b2ff',
        yield: '#a5d6a7',
      };
      const issueNodes = new Set([
        ...(desc.topology?.orphanNodes || []),
        ...(desc.topology?.deadEndNodes || []),
        ...(desc.topology?.laneBalanceIssues || []).map((x) => x.nodeId),
      ]);
      ectx.save();
      ectx.font = '10px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      ectx.textAlign = 'center';
      ectx.textBaseline = 'middle';
      for (const j of desc.junctions) {
        const p = points[j.nodeId]?.pos;
        if (!p) continue;
        const sp = screenFromWorld2(p, org, s);
        const short = CONTROL_TYPE_SHORT[j.controlType] || j.controlType || '?';
        const fill = typeColor[j.controlType] || '#7f8ba8';
        const isIssue = issueNodes.has(j.nodeId);
        const bx = sp.x;
        const by = sp.y - 12;
        const tw = Math.max(18, ectx.measureText(short).width + 8);
        ectx.fillStyle = isIssue ? 'rgba(190,52,52,0.85)' : 'rgba(11,15,25,0.72)';
        ectx.fillRect(bx - tw * 0.5, by - 6, tw, 12);
        ectx.strokeStyle = fill;
        ectx.lineWidth = isIssue ? 1.4 : 1;
        ectx.strokeRect(bx - tw * 0.5, by - 6, tw, 12);
        ectx.fillStyle = fill;
        ectx.fillText(short, bx, by);
      }
      ectx.restore();
    };
    const drawOverlapMarkers2D = (report) => {
      const overlaps = Array.isArray(report?.overlaps) ? report.overlaps : [];
      if (!overlaps.length) return;
      const maxMarkers = 120;
      for (let i = 0; i < overlaps.length && i < maxMarkers; i++) {
        const o = overlaps[i];
        const sp = screenFromWorld2(v3(o.x, o.y, o.z), org, s);
        if (o.type === 'conflict') {
          ectx.save();
          ectx.strokeStyle = '#ff6e6e';
          ectx.lineWidth = 2;
          ectx.beginPath(); ectx.arc(sp.x, sp.y, 7, 0, Math.PI * 2); ectx.stroke();
          ectx.beginPath(); ectx.moveTo(sp.x - 4.4, sp.y - 4.4); ectx.lineTo(sp.x + 4.4, sp.y + 4.4); ectx.stroke();
          ectx.beginPath(); ectx.moveTo(sp.x + 4.4, sp.y - 4.4); ectx.lineTo(sp.x - 4.4, sp.y + 4.4); ectx.stroke();
          ectx.restore();
        } else {
          ectx.save();
          ectx.strokeStyle = 'rgba(126,208,255,0.92)';
          ectx.lineWidth = 1.35;
          ectx.beginPath(); ectx.arc(sp.x, sp.y, 5.2, 0, Math.PI * 2); ectx.stroke();
          ectx.restore();
        }
      }
    };

    const overlayData = getOverlay2DData();
    const net = overlayData.net;
    const netDesc = overlayData.netDesc;
    const mathReport = overlayData.mathReport;
    syncMathConformityUI(mathReport);
    const clsColor = { local: '#79c87a', collector: '#78aaff', arterial: '#ffd36e', freeway: '#ff9b6a', ramp: '#d2b2ff' };
    if (net.main.length > 1) {
      ectx.save();
      ectx.strokeStyle = '#ffd36e';
      ectx.lineWidth = 2;
      ectx.beginPath();
      for (let i = 0; i < net.main.length; i++) {
        const sp = screenFromWorld2(net.main[i].pos, org, s);
        if (i === 0) ectx.moveTo(sp.x, sp.y); else ectx.lineTo(sp.x, sp.y);
      }
      ectx.stroke();
      ectx.restore();
    }
    if (net.branches.length) {
      ectx.save();
      ectx.lineWidth = 2;
      for (let bi = 0; bi < net.branches.length; bi++) {
        const bs = net.branches[bi];
        if (bs.length < 2) continue;
        const cls = roadClassKey(net.branchMeta?.[bi]?.roadClass || 'collector');
        ectx.strokeStyle = clsColor[cls] || '#78aaff';
        ectx.beginPath();
        for (let i = 0; i < bs.length; i++) {
          const sp = screenFromWorld2(bs[i].pos, org, s);
          if (i === 0) ectx.moveTo(sp.x, sp.y); else ectx.lineTo(sp.x, sp.y);
        }
        ectx.stroke();
      }
      ectx.restore();
    }
    if (net.main.length > 1) {
      drawLaneFlowOverlay(net.main, net.mainMeta || getMainRoadSpec(), '#ffeabc', 'M');
    }
    if (net.branches.length) {
      for (let bi = 0; bi < net.branches.length; bi++) {
        const bs = net.branches[bi];
        if (bs.length < 2) continue;
        const spec = net.branchMeta?.[bi] || getNewBranchSpecDefaults('join');
        const cls = roadClassKey(spec.roadClass || 'collector');
        drawLaneFlowOverlay(bs, spec, clsColor[cls] || '#9ec2ff', `B${bi + 1}`);
      }
    }
    drawJunctionControlOverlay(netDesc);
    drawOverlapMarkers2D(mathReport);
    if (lastGeneratedMeta?.style) {
      ectx.save();
      ectx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      ectx.textAlign = 'left';
      ectx.textBaseline = 'top';
      const tries = Math.max(1, Number(lastGeneratedMeta.attemptsUsed || 1));
      const issues = Math.max(0, Number(lastGeneratedMeta.mathIssues || 0));
      const issueTxt = issues > 0 ? ` • math ${issues}` : '';
      const msg = `Gen: ${lastGeneratedMeta.style} • branches ${Number(lastGeneratedMeta.branchCount || 0)} • tries ${tries}${issueTxt}`;
      const tw = ectx.measureText(msg).width + 10;
      ectx.fillStyle = 'rgba(11,15,25,0.70)';
      ectx.fillRect(10, 10, tw, 16);
      ectx.fillStyle = '#b8cbe8';
      ectx.fillText(msg, 15, 13);
      ectx.restore();
    }
    if (mathReport?.autoOverpassAdjusted > 0) {
      const msg = `Auto overpass: ${mathReport.autoOverpassAdjusted}`;
      ectx.save();
      ectx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      ectx.textAlign = 'left';
      ectx.textBaseline = 'top';
      const tw = ectx.measureText(msg).width + 10;
      ectx.fillStyle = 'rgba(18,48,78,0.76)';
      ectx.fillRect(10, 30, tw, 16);
      ectx.fillStyle = '#bfe7ff';
      ectx.fillText(msg, 15, 33);
      ectx.restore();
    }
    if (mathReport && !mathReport.ok) {
      const overlapTxt = mathReport.overlapConflicts > 0 ? ` • overlap ${mathReport.overlapConflicts}` : '';
      const warn = `Math issues: ${mathReport.issues.length}${overlapTxt}`;
      ectx.save();
      ectx.font = '11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
      ectx.textAlign = 'left';
      ectx.textBaseline = 'top';
      const tw = ectx.measureText(warn).width + 10;
      ectx.fillStyle = 'rgba(78,34,18,0.78)';
      ectx.fillRect(10, mathReport.autoOverpassAdjusted > 0 ? 50 : 30, tw, 16);
      ectx.fillStyle = '#ffd2b2';
      ectx.fillText(warn, 15, mathReport.autoOverpassAdjusted > 0 ? 53 : 33);
      ectx.restore();
    }
    sanitizeBranchSections();
    sanitizeBranchSelection();
    for (let si = 0; si < branchSections.length; si++) {
      const mids = branchSections[si]?.mids || [];
      for (let mi = 0; mi < mids.length; mi++) {
        const m = mids[mi];
        const sp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const key = branchSelKey(si, mi);
        const isSel = selectedBranchSet.has(key) || (selectedBranch && selectedBranch.sec === si && selectedBranch.mid === mi);
        ectx.beginPath();
        ectx.arc(sp.x, sp.y, isSel ? 6.2 : 5, 0, Math.PI * 2);
        ectx.fillStyle = isSel ? '#7ed0ff' : '#9ec2ff';
        ectx.fill();
        ectx.strokeStyle = '#0b0f19';
        ectx.lineWidth = isSel ? 1.35 : 1;
        ectx.stroke();
      }
    }

    if (selectedBranch) {
      const ref = branchMidRef(selectedBranch);
      if (ref) {
        const m = ref.mid;
        const psp = screenFromWorld2(v3(m.x, m.y, m.z), org, s);
        const hi = branchHandleWorld(selectedBranch, 'in');
        const ho = branchHandleWorld(selectedBranch, 'out');
        if (hi && ho) {
          const hInSp = screenFromWorld2(hi, org, s);
          const hOutSp = screenFromWorld2(ho, org, s);
          ectx.save();
          ectx.strokeStyle = 'rgba(163,208,255,0.9)';
          ectx.lineWidth = 1;
          ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hInSp.x, hInSp.y); ectx.stroke();
          ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hOutSp.x, hOutSp.y); ectx.stroke();
          ectx.fillStyle = '#78ffa0';
          ectx.fillRect(hInSp.x - 4, hInSp.y - 4, 8, 8);
          ectx.fillStyle = '#78aaff';
          ectx.fillRect(hOutSp.x - 4, hOutSp.y - 4, 8, 8);
          ectx.restore();
        }
      }
    }

    if (selected >= 0 && points[selected]) {
      const p = points[selected];
      const psp = screenFromWorld2(p.pos, org, s);
      const hin = handleWorld(selected, 'in');
      const hout = handleWorld(selected, 'out');
      const hInSp = screenFromWorld2(hin, org, s);
      const hOutSp = screenFromWorld2(hout, org, s);

      ectx.save();
      ectx.strokeStyle = 'rgba(183,197,255,0.85)';
      ectx.lineWidth = 1;
      ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hInSp.x, hInSp.y); ectx.stroke();
      ectx.beginPath(); ectx.moveTo(psp.x, psp.y); ectx.lineTo(hOutSp.x, hOutSp.y); ectx.stroke();

      ectx.fillStyle = '#78ffa0';
      ectx.fillRect(hInSp.x - 4, hInSp.y - 4, 8, 8);
      ectx.fillStyle = '#78aaff';
      ectx.fillRect(hOutSp.x - 4, hOutSp.y - 4, 8, 8);
      ectx.restore();
    }

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const sp = screenFromWorld2(p.pos, org, s);
      const isPrimary = i === selected;
      const isMulti = selectedSet.has(i);
      ectx.beginPath();
      ectx.arc(sp.x, sp.y, isPrimary ? 7 : (isMulti ? 6 : 5), 0, Math.PI * 2);
      ectx.fillStyle = isPrimary ? '#ffd36e' : (isMulti ? '#ffdba0' : '#e9ecf6');
      ectx.fill();
      if (isPrimary || isMulti) {
        ectx.strokeStyle = '#0b0f19';
        ectx.lineWidth = isPrimary ? 1.5 : 1.2;
        ectx.stroke();
      }
    }

    // tool previews
    if (mode === 'ysplit' && ySplitTool.phase === 1 && ySplitTool.startIdx >= 0 && points[ySplitTool.startIdx]) {
      const sp = screenFromWorld2(points[ySplitTool.startIdx].pos, org, s);
      ectx.save();
      ectx.strokeStyle = '#78ffa0';
      ectx.lineWidth = 2;
      ectx.setLineDash([5, 4]);
      ectx.beginPath(); ectx.arc(sp.x, sp.y, 12, 0, Math.PI * 2); ectx.stroke();
      ectx.setLineDash([]);
      ectx.restore();
    }
    if (mode === 'join' && joinTool.phase === 1 && joinTool.startIdx >= 0 && points[joinTool.startIdx]) {
      const sp = screenFromWorld2(points[joinTool.startIdx].pos, org, s);
      ectx.save();
      ectx.strokeStyle = '#78aaff';
      ectx.lineWidth = 2;
      ectx.setLineDash([5, 4]);
      ectx.beginPath(); ectx.arc(sp.x, sp.y, 12, 0, Math.PI * 2); ectx.stroke();
      ectx.setLineDash([]);
      ectx.restore();
    }
    sanitizeSplitEnds();
    if (splitEnds.length) {
      ectx.save();
      ectx.strokeStyle = '#ff6e6e';
      ectx.lineWidth = 2;
      for (const idx of splitEnds) {
        const p = points[idx];
        if (!p) continue;
        const sp = screenFromWorld2(p.pos, org, s);
        ectx.beginPath();
        ectx.arc(sp.x, sp.y, 9, 0, Math.PI * 2);
        ectx.stroke();
      }
      ectx.restore();
    }
    if (mode === 'roundabout' && roundTool.phase >= 1 && roundTool.center && roundTool.radius > 0.5) {
      const cp = screenFromWorld2(v3(roundTool.center.x, points[roundTool.startIdx]?.pos.y || 0, roundTool.center.z), org, s);
      const rp = Math.max(6, roundTool.radius * s * 0.95);
      ectx.save();
      ectx.strokeStyle = '#78aaff';
      ectx.lineWidth = 2;
      ectx.setLineDash([7, 4]);
      ectx.beginPath(); ectx.arc(cp.x, cp.y, rp, 0, Math.PI * 2); ectx.stroke();
      if (roundTool.previewExit) {
        const ep = screenFromWorld2(v3(roundTool.previewExit.x, points[roundTool.startIdx]?.pos.y || 0, roundTool.previewExit.z), org, s);
        ectx.setLineDash([]);
        ectx.strokeStyle = '#ffd36e';
        ectx.beginPath(); ectx.moveTo(cp.x, cp.y); ectx.lineTo(ep.x, ep.y); ectx.stroke();
      }
      ectx.setLineDash([]);
      ectx.restore();
    }

    requestAnimationFrame(render2D);
  }

  // ---------- 2D interactions ----------
  edit.addEventListener('contextmenu', (e) => e.preventDefault());

  edit.addEventListener('mousedown', (e) => {
    const rect = edit.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const s = num('isoScale');
    const org = origin2();

    if (isSpace() || e.shiftKey || e.button === 1) {
      isPanning2 = true;
      last2 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (e.button !== 0) return;
    const hitPoint = nearestPointScreen(sx, sy, org, s, 12);
    const hitBranchMid = nearestBranchMidpointScreen(sx, sy, org, s, 10);

    if (mode === 'ysplit') {
      if (ySplitTool.phase === 0) {
        if (hitPoint < 0) {
          const curveHit = nearestCurveHitScreen(sx, sy, org, s, 10);
          if (!curveHit) return;
          pushUndo();
          const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
          const prevIdx = Number.isInteger(curveHit.segA) ? curveHit.segA : (curveHit.insertIndex - 1 + points.length) % points.length;
          const nextIdx = Number.isInteger(curveHit.segB) ? curveHit.segB : (curveHit.insertIndex % points.length);
          const prevPos = points[prevIdx]?.pos || curveHit.pos;
          const nextPos = points[nextIdx]?.pos || curveHit.pos;
          const hIn = Math.max(0.05, len(sub(curveHit.pos, prevPos)) * 0.30);
          const hOut = Math.max(0.05, len(sub(nextPos, curveHit.pos)) * 0.30);
          const np = {
            pos: v3(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z),
            bank: curveHit.bank,
            node: 'smooth',
            hin: { x: -tan.x * hIn, z: -tan.z * hIn },
            hout: { x: tan.x * hOut, z: tan.z * hOut },
          };
          points.splice(curveHit.insertIndex, 0, np);
          remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
          const idx = curveHit.insertIndex;
          smoothNeighborhood([idx - 1, idx, idx + 1]);
          selectOnly(idx);
          ySplitTool.phase = 1;
          ySplitTool.startIdx = idx;
          ySplitTool.action = 'split';
          syncSelectedUI();
          bumpSceneVersion();
          return;
        }
        ySplitTool.phase = 1;
        ySplitTool.startIdx = hitPoint;
        ySplitTool.action = (e.ctrlKey || e.metaKey) ? 'trim' : (e.altKey ? 'join' : 'split');
        selectOnly(hitPoint);
        syncSelectedUI();
        return;
      }
      if (ySplitTool.startIdx >= 0) {
        if (hitPoint < 0) return;
        pushUndo();
        if (ySplitTool.action === 'split' && ySplitTool.startIdx === hitPoint) splitPointForFork(hitPoint);
        else if (ySplitTool.startIdx !== hitPoint) {
          if (ySplitTool.action === 'trim') trimSection(ySplitTool.startIdx, hitPoint);
          else if (ySplitTool.action === 'join') joinSection(ySplitTool.startIdx, hitPoint);
          else addBranchSection(ySplitTool.startIdx, hitPoint, 'fork');
        }
        ySplitTool = { phase: 0, startIdx: -1, action: 'split' };
        syncSelectedUI();
        bumpSceneVersion();
      }
      return;
    }

    if (mode === 'join') {
      if (hitPoint < 0) return;
      if (joinTool.phase === 0) {
        joinTool.phase = 1;
        joinTool.startIdx = hitPoint;
        selectOnly(hitPoint);
        syncSelectedUI();
        return;
      }
      if (joinTool.startIdx >= 0 && joinTool.startIdx !== hitPoint) {
        pushUndo();
        joinSection(joinTool.startIdx, hitPoint);
        joinTool = { phase: 0, startIdx: -1 };
        syncSelectedUI();
        bumpSceneVersion();
      }
      return;
    }

    if (mode === 'roundabout') {
      if (roundTool.phase === 0) {
        if (hitPoint < 0) return;
        roundTool.phase = 1;
        roundTool.startIdx = hitPoint;
        roundTool.isSizing = true;
        selectOnly(hitPoint);
        syncSelectedUI();
        const S = points[hitPoint].pos;
        const T = tangentAtIndex(hitPoint);
        const N = norm(v3(-T.z, 0, T.x));
        const r0 = Math.max(3.2, num('roadWidth') * 2.45);
        roundTool.radius = r0;
        roundTool.dir = 1;
        const c0 = add(S, mul(N, r0));
        const c0s = snapRoadXZ(c0.x, c0.z);
        roundTool.center = v3(c0s.x, S.y, c0s.z);
        roundTool.previewExit = null;
        return;
      }
      if (roundTool.phase === 2 && roundTool.center) {
        const sy0 = points[roundTool.startIdx]?.pos.y || 0;
        const wp = worldFromScreenXZWithY(sx, sy, org, s, sy0);
        const ex = snapRoadXZ(wp.x, wp.z);
        const exit = { x: ex.x, z: ex.z };
        const exitAng = Math.atan2(exit.z - roundTool.center.z, exit.x - roundTool.center.x);
        pushUndo();
        insertRoundaboutAt(roundTool.startIdx, roundTool.center, roundTool.radius, exitAng, roundTool.dir);
        roundTool = { phase: 0, startIdx: -1, center: null, radius: 0, dir: 1, isSizing: false, previewExit: null };
        setTool('draw');
        syncSelectedUI();
        bumpSceneVersion();
      }
      return;
    }

    const hitHandle = nearestHandle2D(sx, sy, org, s, 10);
    if (hitHandle) {
      pushUndo();
      dragHandle = hitHandle;
      return;
    }

    if (hitBranchMid) {
      const toggleMulti = e.shiftKey || e.ctrlKey || e.metaKey;
      if (toggleMulti) toggleBranchSelection(hitBranchMid.sec, hitBranchMid.mid);
      else if (!selectedBranchSet.has(branchSelKey(hitBranchMid.sec, hitBranchMid.mid)) || selectedBranchSet.size <= 1) selectBranchMidpoint(hitBranchMid.sec, hitBranchMid.mid);
      syncSelectedUI();
      if (mode === 'move') {
        pushUndo();
        dragBranch = { sec: hitBranchMid.sec, mid: hitBranchMid.mid };
        const ref = branchSections[hitBranchMid.sec]?.mids?.[hitBranchMid.mid];
        const active = collectActiveBranchSelection({ sec: hitBranchMid.sec, mid: hitBranchMid.mid });
        dragBranchGroupOffsets = ref ? active.map((a) => {
          const m = branchSections[a.sec]?.mids?.[a.mid];
          return m ? { sec: a.sec, mid: a.mid, dx: m.x - ref.x, dz: m.z - ref.z } : null;
        }).filter(Boolean) : null;
      }
      return;
    }

    if (mode === 'erase') {
      if (hitPoint >= 0) {
        pushUndo();
        points.splice(hitPoint, 1);
        remapSplitEndsForSplice(hitPoint, 1, 0);
        selectOnly(-1);
        syncSelectedUI();
        bumpSceneVersion();
      } else {
        const hitBranchCurve = nearestBranchCurveHitScreen(sx, sy, org, s, 10);
        if (hitBranchCurve) {
          pushUndo();
          branchSections.splice(hitBranchCurve.sec, 1);
          sanitizeBranchSections();
          selectedBranch = null;
          selectedBranchSet.clear();
          syncSelectedUI();
          bumpSceneVersion();
        }
      }
      return;
    }

    if (hitPoint >= 0) {
      const toggleMulti = e.shiftKey || e.ctrlKey || e.metaKey;
      if (toggleMulti) {
        toggleSelection(hitPoint);
        if (mode === 'draw') setDrawAnchor(hitPoint);
        if (mode === 'draw') drawTool.pendingNewLine = false;
        syncSelectedUI();
        return;
      }
      if (mode === 'draw') {
        const anchorIdx = sanitizeDrawAnchor();
        if (anchorIdx >= 0 && anchorIdx !== hitPoint) {
          pushUndo();
          const didJoin = joinSection(anchorIdx, hitPoint);
          if (didJoin) {
            setDrawAnchor(selected >= 0 ? selected : hitPoint);
            bumpSceneVersion();
          } else {
            selectOnly(hitPoint);
            setDrawAnchor(hitPoint);
          }
          drawTool.pendingNewLine = false;
        } else {
          selectOnly(hitPoint);
          setDrawAnchor(hitPoint);
          drawTool.pendingNewLine = false;
        }
        syncSelectedUI();
        return;
      }
      if (!selectedSet.has(hitPoint) || selectedSet.size <= 1) selectOnly(hitPoint);
      syncSelectedUI();
      if (mode === 'move') {
        pushUndo();
        dragIndex = hitPoint;
        const active = collectActiveSelection(hitPoint);
        dragGroupOffsets = active.map((idx) => ({
          idx,
          dx: points[idx].pos.x - points[hitPoint].pos.x,
          dz: points[idx].pos.z - points[hitPoint].pos.z,
        }));
      }
      return;
    }

    if (mode === 'draw') {
      pushUndo();
      const curveHit = nearestCurveHitScreen(sx, sy, org, s, 10);
      if (curveHit) {
        const tan = norm(v3(curveHit.tan.x, 0, curveHit.tan.z));
        const snapped = snapRoadXYZ(curveHit.pos.x, curveHit.pos.y, curveHit.pos.z);
        const insPos = v3(snapped.x, snapped.y, snapped.z);
        const prevIdx = Number.isInteger(curveHit.segA) ? curveHit.segA : (curveHit.insertIndex - 1 + points.length) % points.length;
        const nextIdx = Number.isInteger(curveHit.segB) ? curveHit.segB : (curveHit.insertIndex % points.length);
        const prevPos = points[prevIdx]?.pos || insPos;
        const nextPos = points[nextIdx]?.pos || insPos;
        const hIn = Math.max(0.05, len(sub(insPos, prevPos)) * 0.30);
        const hOut = Math.max(0.05, len(sub(nextPos, insPos)) * 0.30);
        const np = {
          pos: insPos,
          bank: curveHit.bank,
          node: 'smooth',
          hin: { x: -tan.x * hIn, z: -tan.z * hIn },
          hout: { x: tan.x * hOut, z: tan.z * hOut },
        };
        points.splice(curveHit.insertIndex, 0, np);
        remapSplitEndsForSplice(curveHit.insertIndex, 0, 1);
        const idx = curveHit.insertIndex;
        smoothNeighborhood([idx - 1, idx, idx + 1]);
        selectOnly(idx);
        setDrawAnchor(idx);
        drawTool.pendingNewLine = false;
      } else {
        const branchHit = nearestBranchCurveHitScreen(sx, sy, org, s, 10);
        if (branchHit) {
          insertBranchMidpoint(branchHit.sec, branchHit.u, branchHit.pos, branchHit.tan);
          drawTool.pendingNewLine = false;
        } else {
          const anchorIdx = sanitizeDrawAnchor();
          const yRef = anchorIdx >= 0 && points[anchorIdx] ? points[anchorIdx].pos.y : 0;
          const wp = worldFromScreenXZWithY(sx, sy, org, s, yRef);
          const snap = snapRoadXYZ(wp.x, yRef, wp.z);
          addDrawPointAt(snap, yRef);
        }
      }
      syncSelectedUI();
      bumpSceneVersion();
    }
  });

  edit.addEventListener('mousemove', (e) => {
    const rect = edit.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const s = num('isoScale');
    const org = origin2();

    if (isPanning2 && last2) {
      pan2.x += e.clientX - last2.x;
      pan2.y += e.clientY - last2.y;
      last2 = { x: e.clientX, y: e.clientY };
      return;
    }

    if (mode === 'roundabout' && roundTool.phase >= 1 && roundTool.startIdx >= 0 && points[roundTool.startIdx]) {
      const S = points[roundTool.startIdx].pos;
      const wp = worldFromScreenXZWithY(sx, sy, org, s, S.y);
      const v = v3(wp.x - S.x, 0, wp.z - S.z);
      if (roundTool.isSizing || roundTool.phase === 1) {
        const T = tangentAtIndex(roundTool.startIdx);
        const N = norm(v3(-T.z, 0, T.x));
        const sign = dot(v, N) >= 0 ? 1 : -1;
        const r = clamp(Math.hypot(v.x, v.z), Math.max(3.2, num('roadWidth') * 2.05), 45);
        roundTool.radius = r;
        roundTool.dir = sign;
        const c = add(S, mul(N, sign * r));
        const cs = snapRoadXZ(c.x, c.z);
        roundTool.center = v3(cs.x, S.y, cs.z);
        roundTool.previewExit = null;
      } else if (roundTool.phase === 2 && roundTool.center) {
        const ex = snapRoadXZ(wp.x, wp.z);
        roundTool.previewExit = { x: ex.x, z: ex.z };
      }
      return;
    }

    if (dragIndex !== null && points[dragIndex]) {
      const p = points[dragIndex];
      const wp = worldFromScreenXZWithY(sx, sy, org, s, p.pos.y);
      const sp = snapRoadXZ(wp.x, wp.z);
      if (dragGroupOffsets && dragGroupOffsets.length > 1) {
        for (const off of dragGroupOffsets) {
          const tp = points[off.idx];
          if (!tp) continue;
          const sn = snapRoadXZ(sp.x + off.dx, sp.z + off.dz);
          tp.pos.x = sn.x;
          tp.pos.z = sn.z;
        }
      } else {
        p.pos.x = sp.x;
        p.pos.z = sp.z;
      }
      bumpSceneVersion();
      return;
    }

    if (dragBranch) {
      const sec = branchSections[dragBranch.sec];
      const mid = sec?.mids?.[dragBranch.mid];
      if (mid) {
        const wp = worldFromScreenXZWithY(sx, sy, org, s, mid.y);
        const sp = snapRoadXZ(wp.x, wp.z);
        if (dragBranchGroupOffsets && dragBranchGroupOffsets.length > 1) {
          for (const off of dragBranchGroupOffsets) {
            const m = branchSections[off.sec]?.mids?.[off.mid];
            if (!m) continue;
            const sn = snapRoadXZ(sp.x + off.dx, sp.z + off.dz);
            m.x = sn.x;
            m.z = sn.z;
          }
        } else {
          mid.x = sp.x;
          mid.z = sp.z;
        }
        bumpSceneVersion();
      }
      return;
    }

    if (dragHandle) {
      let p = null;
      if (dragHandle.kind === 'branch') {
        const ref = branchMidRef({ sec: dragHandle.sec, mid: dragHandle.mid });
        p = ref ? { x: ref.mid.x, y: ref.mid.y, z: ref.mid.z } : null;
      } else {
        const mp = points[dragHandle.i];
        p = mp ? { x: mp.pos.x, y: mp.pos.y, z: mp.pos.z } : null;
      }
      if (!p) return;
      const wp = worldFromScreenXZWithY(sx, sy, org, s, p.y);
      const hx = wp.x - p.x;
      const hz = wp.z - p.z;
      setHandle(dragHandle, dragHandle.which, hx, hz, {
        rotateOnly: e.altKey,
        breakMirror: e.shiftKey,
      });
      bumpSceneVersion();
    }
  });

  window.addEventListener('mouseup', () => {
    if (mode === 'roundabout' && roundTool.isSizing) {
      roundTool.isSizing = false;
      if (roundTool.phase === 1 && roundTool.radius > 0.5) roundTool.phase = 2;
    }
    dragIndex = null;
    dragBranch = null;
    dragBranchGroupOffsets = null;
    dragGroupOffsets = null;
    dragHandle = null;
    isPanning2 = false;
    last2 = null;
  });

  edit.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (e.altKey && (selectedBranchSet.size || selectedBranch)) {
      applyHeightDeltaToBranchSelection(-e.deltaY * 0.01);
      syncSelectedUI();
      bumpSceneVersion();
      return;
    }
    if (e.altKey && (selectedSet.size || (selected >= 0 && points[selected]))) {
      applyHeightDeltaToMainSelection(-e.deltaY * 0.01);
      syncSelectedUI();
      bumpSceneVersion();
      return;
    }
    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const z = clamp(num('isoScale') * zoomFactor, 0.02, 240);
    $('isoScale').value = z.toFixed(2);
    updateLabels();
  }, { passive: false });

  // ---------- boot ----------
  smoothAllPointHandles();
  syncSelectedUI();
  frame3D();
  render2D();
  render3D();

  // tiny sanity checks
  console.assert(typeof meshesToOBJ === 'function', 'meshesToOBJ exists');
  console.assert(typeof meshesToFbxAscii === 'function', 'meshesToFbxAscii exists');
  console.assert(Array.isArray(points), 'points is array');
})();
</script>
</body>
</html>
